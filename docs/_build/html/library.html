<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Submodules &mdash; openhdemg 0.0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Open_HD-EMG package" href="openhdemg.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            openhdemg
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="openhdemg.html">Open_HD-EMG package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="openhdemg.html#library">Library</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">Submodules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="openhdemg.html#module-openhdemg.openhdemg_gui">Graphical User Interface</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">openhdemg</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">Documentation</a></li>
          <li class="breadcrumb-item"><a href="openhdemg.html">Open_HD-EMG package</a></li>
      <li class="breadcrumb-item active">Submodules</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/library.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="submodules">
<h1>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h1>
<section id="module-openhdemg.library.mathtools">
<span id="mathtools-module"></span><h2>mathtools module<a class="headerlink" href="#module-openhdemg.library.mathtools" title="Permalink to this heading"></a></h2>
<p>This module contains all the mathematical functions that are necessary for the
library.</p>
<dl class="py function">
<dt class="sig sig-object py" id="openhdemg.library.mathtools.compute_pnr">
<span class="sig-prename descclassname"><span class="pre">openhdemg.library.mathtools.</span></span><span class="sig-name descname"><span class="pre">compute_pnr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ipts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mupulses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsamp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separate_paired_firings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openhdemg.library.mathtools.compute_pnr" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the pulse to noise ratio for a single MU.</p>
<section id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>ipts<span class="classifier">pd.Series</span></dt><dd><p>The source of decomposition (or pulse train, IPTS[mu]) of the MU of
interest.</p>
</dd>
<dt>mupulses<span class="classifier">ndarray</span></dt><dd><p>The time of firing (MUPULSES[mu]) of the MU of interest.</p>
</dd>
<dt>separate_paired_firings<span class="classifier">bool, default False</span></dt><dd><p>Whether to treat differently paired and non-paired firings during
the estimation of the signal/noise threshold. According to Holobar
2012, this is common in pathological tremor. This can be set to
True when working with pathological tremor.</p>
</dd>
</dl>
</section>
<section id="returns">
<h3>Returns<a class="headerlink" href="#returns" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>pnr<span class="classifier">float</span></dt><dd><p>The PNR in decibels.</p>
</dd>
</dl>
</section>
<section id="see-also">
<h3>See also<a class="headerlink" href="#see-also" title="Permalink to this heading"></a></h3>
<p>compute_sil : to calculate the Silhouette score for a single MU.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="openhdemg.library.mathtools.compute_sil">
<span class="sig-prename descclassname"><span class="pre">openhdemg.library.mathtools.</span></span><span class="sig-name descname"><span class="pre">compute_sil</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ipts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mupulses</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openhdemg.library.mathtools.compute_sil" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the Silhouette score for a single MU.</p>
<p>The SIL is defined as the difference between the within-cluster sums of
point-to-centroid distances and the same measure calculated between
clusters. The output measure is normalised in a range between 0 and 1.</p>
<section id="id1">
<h3>Parameters<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>ipts<span class="classifier">pd.Series</span></dt><dd><p>The source of decomposition (or pulse train, IPTS[mu]) of the MU of
interest.</p>
</dd>
<dt>mupulses<span class="classifier">ndarray</span></dt><dd><p>The time of firing (MUPULSES[mu]) of the MU of interest.</p>
</dd>
</dl>
</section>
<section id="id2">
<h3>Returns<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>sil<span class="classifier">float</span></dt><dd><p>The SIL score.</p>
</dd>
</dl>
</section>
<section id="id3">
<h3>See also<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<p>compute_pnr : to calculate the Pulse to Noise ratio of a single MU.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="openhdemg.library.mathtools.derivatives_beamforming">
<span class="sig-prename descclassname"><span class="pre">openhdemg.library.mathtools.</span></span><span class="sig-name descname"><span class="pre">derivatives_beamforming</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">teta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openhdemg.library.mathtools.derivatives_beamforming" title="Permalink to this definition"></a></dt>
<dd><p>Calculate devivatives for the beamforming technique.</p>
<p>Calculate the first and second devivative of the mean square error for the
beamforming technique with the first signal as reference.</p>
<section id="id4">
<h3>Parameters<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>sig<span class="classifier">pd.Dataframe</span></dt><dd><p>The source signal to be used for the calculation.
Different channels should be organised in different rows.</p>
</dd>
<dt>row<span class="classifier">int</span></dt><dd><p>The actual row in the iterative procedure.</p>
</dd>
<dt>teta<span class="classifier">float</span></dt><dd><p>The value of teta.</p>
</dd>
</dl>
</section>
<section id="id5">
<h3>Returns<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>de1, de2<span class="classifier">float</span></dt><dd><p>The value of the first and second derivative.</p>
</dd>
</dl>
</section>
<section id="id6">
<h3>See also<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>mle_cv_est<span class="classifier">Estimate conduction velocity (CV) via maximum likelihood</span></dt><dd><p>estimation.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="openhdemg.library.mathtools.find_teta">
<span class="sig-prename descclassname"><span class="pre">openhdemg.library.mathtools.</span></span><span class="sig-name descname"><span class="pre">find_teta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sig1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ied</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsamp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openhdemg.library.mathtools.find_teta" title="Permalink to this definition"></a></dt>
<dd><p>Find the starting value for teta.</p>
<p>It is important to don’t fix teta and use a non-fixed starting point for
the CV algorithm.</p>
<section id="id7">
<h3>Parameters<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>sig1, sig2<span class="classifier">pd.Series</span></dt><dd><p>The two signals based on which to calculate teta.
These must be pd.Series, i.e., 1-dimensional data structures.</p>
</dd>
<dt>ied<span class="classifier">int</span></dt><dd><p>Interelectrode distance (mm).</p>
</dd>
<dt>fsamp<span class="classifier">int</span></dt><dd><p>Sampling frequency (Hz).</p>
</dd>
</dl>
</section>
<section id="id8">
<h3>Returns<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>teta<span class="classifier">int</span></dt><dd><p>The starting value teta.</p>
</dd>
</dl>
</section>
<section id="id9">
<h3>See also<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>mle_cv_est<span class="classifier">Estimate conduction velocity (CV) via maximum likelihood</span></dt><dd><p>estimation.</p>
</dd>
<dt>MUcv_gui<span class="classifier">Graphical user interface for the estimation of MUs conduction</span></dt><dd><p>velocity.</p>
</dd>
</dl>
</section>
<section id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this heading"></a></h3>
<p>Calculate the starting point for the maximum likelihood estimation.
In this example we calculate teta for the first MU on the channels 5,6,7
in the third column (“col3”) of the double differential representation of
the MUAPs.
First, obtain the spike-triggered average of the double differential
derivation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">openhdemg</span> <span class="k">as</span> <span class="nn">emg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">emgfile</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">askopenfile</span><span class="p">(</span><span class="n">filesource</span><span class="o">=</span><span class="s2">&quot;OTB&quot;</span><span class="p">,</span> <span class="n">otb_ext_factor</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">... </span><span class="n">sorted_rawemg</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">sort_rawemg</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">emgfile</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">code</span><span class="o">=</span><span class="s2">&quot;GR08MM1305&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">orientation</span><span class="o">=</span><span class="mi">180</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">dividebycolumn</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">double_diff</span><span class="p">(</span><span class="n">sorted_rawemg</span><span class="o">=</span><span class="n">sorted_rawemg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sta</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">sta</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">emgfile</span><span class="o">=</span><span class="n">emgfile</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">sorted_rawemg</span><span class="o">=</span><span class="n">sorted_rawemg</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">firings</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">50</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">timewindow</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>Second, prepare the signals for the estimation of teta.
The input (sig) provided for the estimation of teta contains a channel
each row and all the instants are contained in columns. For this reason,
the original content of the spike-triggered average has to be transposed.
After that, the 1D signals used to estimate teta are defined based on the
number of available channels.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">sta</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;col3&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">sig1</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">sig2</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">else</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">sig1</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">sig2</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Third, estimate teta.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">initial_teta</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">find_teta</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">sig1</span><span class="o">=</span><span class="n">sig1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">sig2</span><span class="o">=</span><span class="n">sig2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">ied</span><span class="o">=</span><span class="n">emgfile</span><span class="p">[</span><span class="s2">&quot;IED&quot;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">fsamp</span><span class="o">=</span><span class="n">emgfile</span><span class="p">[</span><span class="s2">&quot;FSAMP&quot;</span><span class="p">],</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="openhdemg.library.mathtools.min_max_scaling">
<span class="sig-prename descclassname"><span class="pre">openhdemg.library.mathtools.</span></span><span class="sig-name descname"><span class="pre">min_max_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">series_or_df</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openhdemg.library.mathtools.min_max_scaling" title="Permalink to this definition"></a></dt>
<dd><p>Min-max scaling of pd.series or pd.dataframes.</p>
<p>Min-max feature scaling is often simply referred to as normalization,
which rescales the dataset feature to a range of 0 - 1.
It’s calculated by subtracting the feature’s minimum value from the value
and then dividing it by the difference between the maximum and minimum
value.</p>
<p>The formula looks like this: xnorm = x - xmin / xmax - xmin.</p>
<section id="id10">
<h3>Parameters<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>series_or_df<span class="classifier">pd.Series or pd.DataFrame</span></dt><dd><p>The min-max scaling is performed for the entire series,
or for single columns in a pd.DataFrame.</p>
</dd>
</dl>
</section>
<section id="id11">
<h3>Returns<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>object<span class="classifier">pd.Series or pd.DataFrame</span></dt><dd><p>The normalised pd.Series or pd.DataFrame (normalised by column).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="openhdemg.library.mathtools.mle_cv_est">
<span class="sig-prename descclassname"><span class="pre">openhdemg.library.mathtools.</span></span><span class="sig-name descname"><span class="pre">mle_cv_est</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_teta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ied</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsamp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openhdemg.library.mathtools.mle_cv_est" title="Permalink to this definition"></a></dt>
<dd><p>Estimate conduction velocity (CV) via maximum likelihood estimation.</p>
<section id="id12">
<h3>Parameters<a class="headerlink" href="#id12" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>sig<span class="classifier">pd.Dataframe</span></dt><dd><p>The source signal to be used for the calculation.
Different channels should be organised in different rows.</p>
</dd>
<dt>initial_teta<span class="classifier">int</span></dt><dd><p>The starting value teta.</p>
</dd>
<dt>ied<span class="classifier">int</span></dt><dd><p>Interelectrode distance (mm).</p>
</dd>
<dt>fsamp<span class="classifier">int</span></dt><dd><p>Sampling frequency (Hz).</p>
</dd>
</dl>
</section>
<section id="id13">
<h3>Returns<a class="headerlink" href="#id13" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>cv<span class="classifier">float</span></dt><dd><p>Conduction velocity (M/s).</p>
</dd>
<dt>teta<span class="classifier">float</span></dt><dd><p>The final value of teta.</p>
</dd>
</dl>
</section>
<section id="id14">
<h3>See also<a class="headerlink" href="#id14" title="Permalink to this heading"></a></h3>
<p>find_teta : Find the starting value for teta.
MUcv_gui : Graphical user interface for the estimation of MUs conduction</p>
<blockquote>
<div><p>velocity.</p>
</div></blockquote>
</section>
<section id="id15">
<h3>Examples<a class="headerlink" href="#id15" title="Permalink to this heading"></a></h3>
<p>Refer to the examples of find_teta to obtain sig and initial_teta.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="openhdemg.library.mathtools.norm_twod_xcorr">
<span class="sig-prename descclassname"><span class="pre">openhdemg.library.mathtools.</span></span><span class="sig-name descname"><span class="pre">norm_twod_xcorr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openhdemg.library.mathtools.norm_twod_xcorr" title="Permalink to this definition"></a></dt>
<dd><p>Normalised 2-dimensional cross-correlation of STAs of two MUS.</p>
<p>Any pre-processing of the RAW_SIGNAL (i.e., normal, differential or double
differential) can be passed as long as the two inputs have same shape.</p>
<section id="id16">
<h3>Parameters<a class="headerlink" href="#id16" title="Permalink to this heading"></a></h3>
<dl>
<dt>df1<span class="classifier">pd.DataFrame</span></dt><dd><p>A pd.DataFrame containing the STA of the first MU without np.nan
column.</p>
</dd>
<dt>df2<span class="classifier">pd.DataFrame</span></dt><dd><p>A pd.DataFrame containing the STA of the second MU without np.nan
column.</p>
</dd>
<dt>mode<span class="classifier">str {“full”, “valid”, “same”}, default “full”</span></dt><dd><p>A string indicating the size of the output:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">full</span></code></dt><dd><p>The output is the full discrete linear cross-correlation
of the inputs. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In ‘valid’ mode, either <cite>sta_mu1</cite> or
<cite>sta_mu2</cite> must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the ‘full’ output.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id17">
<h3>Returns<a class="headerlink" href="#id17" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>normxcorr_df<span class="classifier">pd.DataFrame</span></dt><dd><p>The results of the normalised 2d cross-correlation.</p>
</dd>
<dt>normxcorr_max<span class="classifier">float</span></dt><dd><p>The maximum value of the 2d cross-correlation.</p>
</dd>
</dl>
</section>
<section id="id18">
<h3>See also<a class="headerlink" href="#id18" title="Permalink to this heading"></a></h3>
<p>align_by_xcorr : to align the two STAs before calling norm_twod_xcorr.
unpack_sta : for unpacking the sta dict in a pd.DataFrame</p>
<blockquote>
<div><p>before passing it to norm_twod_xcorr.</p>
</div></blockquote>
<dl class="simple">
<dt>pack_sta<span class="classifier">for packing the sta pd.DataFrame in a dict where</span></dt><dd><p>each matrix column corresponds to a dict key.</p>
</dd>
</dl>
</section>
<section id="id19">
<h3>Examples<a class="headerlink" href="#id19" title="Permalink to this heading"></a></h3>
<p>Full steps to pass two dataframes to norm_twod_xcorr from the same EMG
file.
1 Load the EMG file and band-pass filter the raw EMG signal
2 Sort the matrix channels and compute the spike-triggered average
3 Extract the STA of the MUs of interest from all the STAs
4 Unpack the STAs of single MUs and remove np.nan to pas them to</p>
<blockquote>
<div><p>norm_twod_xcorr</p>
</div></blockquote>
<p>5 Compute 2dxcorr to identify a common lag/delay</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">openhdemg</span> <span class="k">as</span> <span class="nn">emg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">emgfile</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">askopenfile</span><span class="p">(</span><span class="n">filesource</span><span class="o">=</span><span class="s2">&quot;OTB&quot;</span><span class="p">,</span> <span class="n">otb_ext_factor</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">emgfile</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">filter_rawemg</span><span class="p">(</span><span class="n">emgfile</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lowcut</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">highcut</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_rawemg</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">sort_rawemg</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">emgfile</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">code</span><span class="o">=</span><span class="s2">&quot;GR08MM1305&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">orientation</span><span class="o">=</span><span class="mi">180</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sta</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">sta</span><span class="p">(</span><span class="n">emgfile</span><span class="p">,</span> <span class="n">sorted_rawemg</span><span class="p">,</span> <span class="n">firings</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span> <span class="n">timewindow</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sta_mu1</span> <span class="o">=</span> <span class="n">sta</span><span class="p">[</span><span class="n">mu0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sta_mu2</span> <span class="o">=</span> <span class="n">sta</span><span class="p">[</span><span class="n">mu1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">unpack_sta</span><span class="p">(</span><span class="n">sta_mu1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">no_nan_sta1</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">unpack_sta</span><span class="p">(</span><span class="n">sta_mu2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">no_nan_sta2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normxcorr_df</span><span class="p">,</span> <span class="n">normxcorr_max</span> <span class="o">=</span> <span class="n">emg</span><span class="o">.</span><span class="n">norm_twod_xcorr</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">no_nan_sta1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">no_nan_sta2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normxcorr_max</span>
<span class="go">0.7241553627564273</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normxcorr_df</span>
<span class="go">            0             1             2               125       126</span>
<span class="go">0   -0.000002 -1.467778e-05 -3.013564e-05 ... -1.052780e-06  0.000001</span>
<span class="go">1   -0.000004 -2.818055e-05 -6.024427e-05 ... -4.452469e-06  0.000001</span>
<span class="go">2   -0.000007 -4.192479e-05 -9.223725e-05 ... -1.549197e-05 -0.000002</span>
<span class="go">3   -0.000009 -5.071660e-05 -1.174545e-04 ... -3.078518e-05 -0.000007</span>
<span class="go">4   -0.000007 -4.841255e-05 -1.239106e-04 ... -4.232094e-05 -0.000012</span>
<span class="go">..        ...           ...           ... ...           ...       ...</span>
<span class="go">402  0.000005  1.641773e-05  3.994943e-05 ...  8.170792e-07 -0.000006</span>
<span class="go">403 -0.000001  4.535878e-06  1.858700e-05 ...  2.087135e-06 -0.000003</span>
<span class="go">404 -0.000004 -1.241530e-06  5.704194e-06 ...  1.027966e-05  0.000002</span>
<span class="go">405 -0.000004 -1.693078e-06  1.054646e-06 ...  1.811828e-05  0.000007</span>
<span class="go">406 -0.000002 -2.473282e-07  6.006046e-07 ...  1.605406e-05  0.000007</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="openhdemg.library.mathtools.norm_xcorr">
<span class="sig-prename descclassname"><span class="pre">openhdemg.library.mathtools.</span></span><span class="sig-name descname"><span class="pre">norm_xcorr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sig1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openhdemg.library.mathtools.norm_xcorr" title="Permalink to this definition"></a></dt>
<dd><p>Normalized cross-correlation of 2 signals.</p>
<section id="id20">
<h3>Parameters<a class="headerlink" href="#id20" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>sig1, sig2<span class="classifier">pd.Series or np.ndarray</span></dt><dd><p>The two signals to correlate.
These signals must be 1-dimensional and of same length.</p>
</dd>
</dl>
</section>
<section id="id21">
<h3>Returns<a class="headerlink" href="#id21" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>xcc<span class="classifier">float</span></dt><dd><p>The maximum cross-correlation value.</p>
</dd>
</dl>
</section>
<section id="id22">
<h3>See also<a class="headerlink" href="#id22" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>norm_twod_xcorr<span class="classifier">Normalised 2-dimensional cross-correlation of STAs of</span></dt><dd><p>two MUS.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="openhdemg.html" class="btn btn-neutral float-left" title="Open_HD-EMG package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Giacomo Valli, Paul Ritsche.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>