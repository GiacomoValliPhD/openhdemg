{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to openhdemg","text":""},{"location":"#overview","title":"Overview","text":"<p>openhdemg is a powerful toolbox for the analysis of HD-EMG recordings.</p> <p>openhdemg is an open-source framework written in Python 3 with many functionalities specifically designed for the analysis of High-Density Electromyography (HD-EMG) recordings. Some of its main features are listed below, but there is much more to discover! For a full list of available functions, please refer to the API reference section.</p> <ol> <li>Load decomposed HD-EMG files from various sources, such as .mat and .csv files. This allows to interface openhdemg with the commonly used softwares like OTBioLab+, DEMUSE, Delsys NeuroMap and potentially with any other software.</li> <li>Visualise your EMG or force/reference signal, as well as the motor units' firing times and their action potentials shape.</li> <li>Edit your file changing the reference signal offset, filtering noise, calculating differential derivations and removing unwanted motor units.</li> <li>Analyse motor units' recruitment/derecruitment thresholds, discharge rate, conduction velocity, action potentials amplitude and more...</li> <li>Remove duplicates between different files from the same recording session and analyse them together to increase the number of motor units'.</li> <li>Track motor units' across different recording sessions.</li> <li>Save the results of the analyses and the edited file.</li> </ol>"},{"location":"#start-immediately","title":"Start immediately","text":"<p>If you already know how to use Python, that's the way to go! Otherwise, have a look at the tutorial explaining how to Setup your Python environment.</p> <p>openhdemg can be easily installed using pip:</p> <pre><code>pip install openhdemg\n</code></pre> <p>If you want an overview of what you can do with the openhdemg library, have a look at the Quick Start section and then explore all the functions in the API reference.</p>"},{"location":"#good-to-know","title":"Good to know","text":"<p>In addition to the rich set of modules and functions presented in the API reference, openhdemg offers also a practical graphical user interface (GUI) from which many tasks can be performed without writing a single line of code!</p> <p>After installing the openhdemg package, the GUI can be simply accessed from the command line (check to be into the virtual environment) with:</p> <pre><code>python -m openhdemg.gui.openhdemg_gui\n</code></pre> <p>Once opened, it will look like this. It is cool, isn't it?</p> <p></p>"},{"location":"#why-openhdemg","title":"Why openhdemg","text":"<p>The openhdemg project was born in 2022 with the aim to provide the HD-EMG community with a free and open-source framework to analyse motor units' properties.</p> <p>The field of EMG analysis in humans has always been characterized by a lack of available software for signal post-processing and analysis. This has forced users to code their own scripts, which can lead to problems when the scripts are not shared open-source. Why?</p> <ul> <li>If different users use different scripts, the results can differ.</li> <li>Any code can contain errors, if the code is not shared, the errors will never be known and them will repeat in the following analyses.</li> <li>There is a significant difference between the methods presented in research papers and the practical implementation of a script. Reproducing a script solely based on written instructions can be challenging, making the reproducibility of a study unrealistic.</li> <li>Anyone who doesn't code, will not be able to analyse the recordings.</li> </ul> <p>In order to overcome these problems, we developed a fully transparent framework for the analysis of motor units' properties.</p> <p>This project is intended for the users that already know the Python language, for those willing to learn it and even for those not interested in coding, thanks to a friendly graphical user interface (GUI).</p> <p>Both the openhdemg project and its contributors adhere to the Open Science Principles and especially to the idea of public release  of data and other scientific resources necessary for conducting honest research.</p>"},{"location":"about-us/","title":"About us","text":""},{"location":"about-us/#mission","title":"Mission","text":"\u201cTo build the most complete, easy-to-use, free, and open-source framework for the analysis of High-Density Electromyography (HD-EMG) recordings\u201d  <p> But we cannot achieve this alone! That's why openhdemg is a community-driven project where everyone's contribution is welcomed and essential.</p>"},{"location":"about-us/#goals","title":"Goals","text":"<p> community  inclusion  collaboration  knowledgesharing</p> <p>We aim to cultivate a culture of knowledge sharing, collaboration, and open-source contributions within the HD-EMG community, ensuring that expertise and advancements are accessible to all.</p> <p> advance  discover  research</p> <p>We want to empower researchers with an efficient, effective and comprehensive framework for the analysis of HD-EMG recordings and single motor unit properties to advance their research.</p>"},{"location":"about-us/#roadmap","title":"Roadmap","text":"<p>A roadmap is a collection of planned milestones and tasks that are necessary for the successful development and growth of the openhdemg project. It outlines the key steps and objectives that need to be achieved to meet the project's goals and deliver value to the community. The roadmap drives the project's evolution, ensuring that efforts are focused, organized, and aligned with the overall vision.</p> <p>At this stage, we have identified and set six major milestones for the openhdemg project. These milestones are divided into two categories: three on the development side and three on the engagement side.</p> <p>To read the complete roadmap, click on the next button.</p> <p>Complete roadmap \u00a0 </p> <p></p> <pre><code>graph TB;\n    A[Development] --&gt; B(Feedback from beta test)\n    B --&gt; C(Stable release v0.1)\n    C --&gt; D(Continuous updates)\n    E[Engagement] --&gt; F(Reach)\n    E[Engagement] --&gt; G(Outreach)\n    E[Engagement] --&gt; H(New contributors)\n    F --&gt; I(Feedback)\n    G --&gt; I(Feedback)\n    I --&gt; D\n    H --&gt; D\n    D --&gt; L(Release v1.0)</code></pre>"},{"location":"about-us/#meet-the-developers","title":"Meet the developers","text":"<p>Giacomo Valli:</p> <ul> <li> <p>giacomo.valli@unibs.it</p> </li> <li> <p>The creator/maintainer of the project and developer of the library.</p> </li> <li> <p>Giacomo Valli obtained a master degree in Sports Science and a research fellowship in molecular biology of exercise. He completed the PhD in neuromuscular physiology at the University of Padova (IT) and he is currently a PostDoc fellow at the University of Brescia (IT). His main focus is on investigating electrophysiological modifications that occur during periods of disuse, disease, and aging, and in linking this information to the molecular alterations of the muscle.</p> </li> </ul> <p>Paul Ritsche:</p> <ul> <li> <p>paul.ritsche@unibas.ch</p> </li> <li> <p>The developer of the GUI.</p> </li> <li> <p>Paul Ritsche obtained a master degree in Sports Science at the University of Basel (CH). He is currently a research associate at the University of Basel (CH) focusing on muscle ultrasonography. He is investigating automatic ultrasonography image analysis methods to evaluate muscle morphological as well architectural parameters.</p> </li> </ul> <p>Drew-James Beauchamp:</p> <ul> <li> <p>jbeaucha@andrew.cmu.edu</p> </li> <li> <p>Developer of the library.</p> </li> <li> <p>James (Drew) Beauchamp completed his doctoral studies in Engineering at Northwestern University, where his work focused on characterizing the deficits in human motor function that are introduced by neuromodulatory inputs to spinal motoneurons. He is interested in providing creative ways to decouple the structure of descending motor commands and is currently a post-doctoral researcher at Carnegie Mellon University. </p> </li> </ul>"},{"location":"about-us/#meet-the-contributors","title":"Meet the contributors","text":"<p>Francesco Negro:</p> <ul> <li> <p>francesco.negro@unibs.it</p> </li> <li> <p>Contribution: \u00a0  Knowledge sharing \u00a0  Code sharing \u00a0  Accuracy check</p> </li> <li> <p>Francesco Negro is a Full Professor at the Department of Clinical and Experimental Sciences at Universita\u2019 degli Studi di Brescia (IT). His research interests include applied physiology of the human motor system, signal processing of intramuscular and surface electromyography, and modeling of spinal neural networks.</p> </li> </ul> <p>Gregory EP Pearcey:</p> <ul> <li> <p>gpearcey@northwestern.edu</p> </li> <li> <p>Contribution: \u00a0  Knowledge sharing \u00a0  Code sharing \u00a0  Accuracy check</p> </li> <li> <p>Gregory Pearcey is an Assistant Professor in the School of Human Kinetics and Recreation at Memorial University of Newfoundland and holds a cross-appointment in BioMedical Sciences (Faculty of Medicine, Memorial), as well as an Adjunct Faculty position in Physical Therapy &amp; Human Movement Sciences (Northwestern University). He is interested in decoding the neural control of human movement via recording myoelectric signals from the surface and within human muscle with a goal of understanding and enhancing neuroplasticity and the recovery of motor function after neurological impairment.</p> </li> </ul> <p>Andrea Casolo:</p> <ul> <li> <p>andrea.casolo@unipd.it</p> </li> <li> <p>Contribution: \u00a0  Knowledge sharing \u00a0  Accuracy check</p> </li> <li> <p>Andrea Casolo is an Assistant Professor at the Department of Biomedical Sciences, University of Padova (IT). He obtained a MSc in Health and Physical Activity (2016) and a PhD in Human Movement and Sport Sciences (2020) from the University of Rome \"Foro Italico\". His research interests focus on the neural control of movement and the study of neuromuscular plasticity to physical exercise investigated with high-density surface electromyography.</p> </li> </ul> <p>Giuseppe De Vito:</p> <ul> <li> <p>giuseppe.devito@unipd.it</p> </li> <li> <p>Contribution: \u00a0  Knowledge sharing</p> </li> <li> <p>Giuseppe De Vito is a full Professor of Human Physiology in the Department of Biomedical Sciences at University of Padova (IT). He was, from 2007 until 2019, Professor and Dean in the School of Public Health, Physiotherapy &amp; Sports Science at University College Dublin (IE) (Head of School between 2014 and 2019). Giuseppe does research in Human and Exercise Physiology.</p> </li> </ul>"},{"location":"api_analysis/","title":"analysis","text":""},{"location":"api_analysis/#description","title":"Description","text":"<p>This module contains all the functions used to analyse the MUs properties apart from those involving:</p> <ul> <li>The MUs action potential shape =&gt; Available in the muap module</li> <li>DeltaF / PICs estimation =&gt; available in the pic module</li> </ul> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"api_analysis/#openhdemg.library.analysis.compute_thresholds","title":"<code>compute_thresholds(emgfile, event_='rt_dert', type_='abs_rel', n_firings=1, mvc=0)</code>","text":"<p>Calculates recruitment/derecruitment thresholds.</p> <p>Values are calculated both in absolute and relative terms.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>event_</code> <p>When to calculate the thresholds.</p> <p><code>rt_dert</code>     Both recruitment and derecruitment tresholds will be calculated.</p> <p><code>rt</code>     Only recruitment tresholds will be calculated.</p> <p><code>dert</code>     Only derecruitment tresholds will be calculated.</p> <p> TYPE: <code>str {\"rt_dert\", \"rt\", \"dert\"}</code> DEFAULT: <code>\"rt_dert\"</code> </p> <code>type_</code> <p>The tipe of value to calculate.</p> <p><code>abs_rel</code>     Both absolute and relative tresholds will be calculated.</p> <p><code>rel</code>     Only relative tresholds will be calculated.</p> <p><code>abs</code>     Only absolute tresholds will be calculated.</p> <p> TYPE: <code>str {\"abs_rel\", \"rel\", \"abs\"}</code> DEFAULT: <code>\"abs_rel\"</code> </p> <code>n_firings</code> <p>The number of firings used to calculate recruitment/derecruitment thresholds. If n_firings = 1, the threshold is the value of the reference signal at the instant in which the firing happens. If n_firings &gt; 1, the threshold is the average value of the reference signal at the instants in which the n consecutive firings happen.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>mvc</code> <p>The maximum voluntary contraction (MVC). if mvc is 0, the user is asked to input MVC; otherwise, the value passed is used.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>mus_thresholds</code> <p>A DataFrame containing the requested thresholds.</p> <p> TYPE: <code>DataFrame</code> </p> See also <ul> <li>compute_dr : calculate the discharge rate.</li> <li>basic_mus_properties : calculate basic MUs properties on a trapezoidal     contraction.</li> <li>compute_covisi : calculate the coefficient of variation of interspike     interval.</li> <li>compute_drvariability : calculate the DR variability.</li> </ul> <p>Examples:</p> <p>Load the EMG file and compute the thresholds.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; mus_thresholds = emg.compute_thresholds(\n...     emgfile=emgfile,\n...     event_=\"rt_dert\",\n... )\n&gt;&gt;&gt; mus_thresholds\n       abs_RT    abs_DERT     rel_RT   rel_DERT\n0  160.148294  137.682351  18.665302  16.046894\n1   39.138554   49.860936   4.561603   5.811298\n2   88.155160   95.133218  10.274494  11.087788\n3   37.776982   41.010716   4.402912   4.779804\n</code></pre> <p>Type of output can be adjusted, e.g., to have only absolute values at recruitment.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; mus_thresholds = emg.compute_thresholds(\n...     emgfile=emgfile,\n...     event_=\"rt\",\n...     type_=\"abs\",\n... )\n&gt;&gt;&gt; mus_thresholds\n       abs_RT\n0  160.148294\n1   39.138554\n2   88.155160\n3   37.776982\n</code></pre>"},{"location":"api_analysis/#openhdemg.library.analysis.compute_dr","title":"<code>compute_dr(emgfile, n_firings_RecDerec=4, n_firings_steady=10, start_steady=-1, end_steady=-1, event_='rec_derec_steady', idr_range=None)</code>","text":"<p>Calculate the discharge rate (DR).</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>n_firings_RecDerec</code> <p>The number of firings at recruitment and derecruitment to consider for the calculation of the DR.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> <code>n_firings_steady</code> <p>The number of firings to consider for the calculation of the DR at the start and at the end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>start_steady</code> <p>The start and end point (in samples) of the steady-state phase. If &lt; 0 (default), the user will need to manually select the start and end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <code>end_steady</code> <p>The start and end point (in samples) of the steady-state phase. If &lt; 0 (default), the user will need to manually select the start and end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <code>event_</code> <p>When to calculate the DR.</p> <p><code>rec_derec_steady</code>     DR is calculated at recruitment, derecruitment and during the     steady-state phase.</p> <p><code>rec</code>     DR is calculated at recruitment.</p> <p><code>derec</code>     DR is calculated at derecruitment.</p> <p><code>rec_derec</code>     DR is calculated at recruitment and derecruitment.</p> <p><code>steady</code>     DR is calculated during the steady-state phase.</p> <p> TYPE: <code>str {\"rec_derec_steady\", \"rec\", \"derec\", \"rec_derec\", \"steady\"}</code> DEFAULT: <code>\"rec_derec_steady\"</code> </p> <code>idr_range</code> <p>If idr_range is a list [lower_limit, upper_limit], only firings with an instantaneous discharge rate (IDR) within the limits are used for DR calculation. lower_limit and upper_limit should be in pulses per second. See examples section. If idr_range is None, all the firings are used for DR calculation.</p> <p> TYPE: <code>None or list</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>mus_dr</code> <p>A pd.DataFrame containing the requested DR.</p> <p> TYPE: <code>DataFrame</code> </p> WARNS DESCRIPTION <code>warning</code> <p>When calculation of DR at rec/derec fails due to not enough firings.</p> See also <ul> <li>compute_thresholds : calculates recruitment/derecruitment thresholds.</li> <li>basic_mus_properties : calculate basic MUs properties on a trapezoidal     contraction.</li> <li>compute_covisi : calculate the coefficient of variation of interspike     interval.</li> <li>compute_drvariability : calculate the DR variability.</li> </ul> Notes <p>DR for all the contraction is automatically calculated and returned.</p> <p>Examples:</p> <p>Load the EMG file and compute the DR.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; mus_dr = emg.compute_dr(emgfile=emgfile)\n&gt;&gt;&gt; mus_dr\n     DR_rec  DR_derec  DR_start_steady  DR_end_steady  DR_all_steady     DR_all\n0  5.701081  4.662196         7.321255       6.420720       6.907559   6.814342\n1  7.051127  6.752467        14.919066      10.245462      11.938671  11.683134\n2  6.101529  4.789000         7.948740       6.133345       7.695189   8.055731\n3  6.345692  5.333535        11.121785       9.265212      11.544140  11.109796\n</code></pre> <p>Type of output can be adjusted, e.g., to have only the DR at recruitment.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; mus_dr = emg.compute_dr(emgfile=emgfile, event_=\"rec\")\n&gt;&gt;&gt; mus_dr\n     DR_rec     DR_all\n0  5.701081   6.814342\n1  7.051127  11.683134\n2  6.101529   8.055731\n3  6.345692  11.109796\n</code></pre> <p>The manual selection of the steady state phase can be bypassed if previously calculated with an automated method.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; mus_dr = emg.compute_dr(\n...     emgfile=emgfile,\n...     start_steady=20000,\n...     end_steady=50000,\n...     event_=\"steady\",\n... )\n&gt;&gt;&gt; mus_dr\n   DR_start_steady  DR_end_steady  DR_all_steady     DR_all\n0         7.476697       6.271750       6.794170   6.814342\n1        14.440561      10.019572      11.822081  11.683134\n2         7.293547       5.846093       7.589531   8.055731\n3        13.289651       9.694317      11.613640  11.109796\n</code></pre> <p>The firings used for DR calculation can be filtered to avoid too closed firings (e.g., doublets) or intervals of inactivity.</p> <pre><code>&gt;&gt;&gt; emgfile = emg.emg_from_samplefile()\n&gt;&gt;&gt; idr = emg.compute_dr(\n...     emgfile, start_steady=15000, end_steady=51000, idr_range=[1, 50],\n... )\n&gt;&gt;&gt; idr\n     DR_rec  DR_derec ... DR_end_steady  DR_all_steady     DR_all\n0  3.341579  4.606835 ...      8.506270       7.895837   7.657269\n1  5.701081  4.662196 ...      6.271989       6.916566   6.814687\n2  5.699017  3.691367 ...      7.221309       8.183408   7.949294\n3  7.548770  5.449581 ...     10.399834      11.164994  10.693076\n4  8.344515  5.333535 ...      9.694317      10.750855  10.543011\n</code></pre>"},{"location":"api_analysis/#openhdemg.library.analysis.basic_mus_properties","title":"<code>basic_mus_properties(emgfile, n_firings_rt_dert=1, n_firings_RecDerec=4, n_firings_steady=10, start_steady=-1, end_steady=-1, idr_range=None, accuracy='default', ignore_negative_ipts=False, constrain_pulses=[True, 3], mvc=0)</code>","text":"<p>Calculate basic MUs properties on a trapezoidal contraction.</p> <p>The function is meant to be used on trapezoidal contractions and calculates: the absolute/relative recruitment/derecruitment thresholds, the discharge rate at recruitment, derecruitment, during the steady-state phase and during the entire contraction, the coefficient of variation of interspike interval, the coefficient of variation of force signal.</p> <p>Accuracy measures, MVC and steadiness are also returned.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>n_firings_rt_dert</code> <p>The number of firings used to calculate recruitment/derecruitment thresholds. If n_firings_rt_dert = 1, the threshold is the value of the reference signal at the instant in which the firing happens. If n_firings_rt_dert &gt; 1, the threshold is the average value of the reference signal at the instants in which the n consecutive firings happen.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>n_firings_RecDerec</code> <p>The number of firings at recruitment and derecruitment to consider for the calculation of the DR.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> <code>n_firings_steady</code> <p>The number of firings to consider for the calculation of the DR at the start and at the end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>start_steady</code> <p>The start and end point (in samples) of the steady-state phase. If &lt; 0 (default), the user will need to manually select the start and end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <code>end_steady</code> <p>The start and end point (in samples) of the steady-state phase. If &lt; 0 (default), the user will need to manually select the start and end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <code>idr_range</code> <p>If idr_range is a list [lower_limit, upper_limit], only firings with an instantaneous discharge rate (IDR) within the limits are used for DR and coefficient of variation of interspike interval (COVisi) calculation. lower_limit and upper_limit should be in pulses per second. See compute_dr() examples section. If idr_range is None, all the firings are used for DR calculation.</p> <p> TYPE: <code>None or list</code> DEFAULT: <code>None</code> </p> <code>accuracy</code> <p>The accuracy measure to return.</p> <p><code>default</code>     The original accuracy measure already contained in the emgfile is     returned without any computation.</p> <p><code>SIL</code>     The Silhouette score is computed.</p> <p><code>PNR</code>     The pulse to noise ratio is computed.</p> <p><code>SIL_PNR</code>     Both the Silhouette score and the pulse to noise ratio are     computed.</p> <p> TYPE: <code>str {\"default\", \"SIL\", \"PNR\", \"SIL_PNR\"}</code> DEFAULT: <code>\"default\"</code> </p> <code>ignore_negative_ipts</code> <p>This parameter determines the silhouette score estimation. If True, only positive ipts values are used during peak and noise clustering. This is particularly important for compensating sources with large negative components. This parameter is considered only when accuracy==\"SIL\" or accuracy==\"SIL_PNR\".</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>constrain_pulses</code> <p>This parameter determines the PNR estimation. If constrain_pulses[0]==True, the times of firing are considered those in mupulses +- the number of samples specified in constrain_pulses[1]. If constrain_pulses[0]==False, the times of firing are estimated via a heuristic penalty funtion (see Notes in compute_pnr()). constrain_pulses[1] must be an integer (see Notes in compute_pnr() for instructions on how to set the appropriate value).</p> <p> TYPE: <code>list</code> DEFAULT: <code>[True, 3]</code> </p> <code>mvc</code> <p>The maximum voluntary contraction (MVC). It is suggest to report MVC in Newton (N). If 0 (default), the user will be asked to imput it manually. Otherwise, the passed value will be used.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>exportable_df</code> <p>A pd.DataFrame containing the results of the analysis.</p> <p> TYPE: <code>DataFrame</code> </p> See also <ul> <li>compute_thresholds : calculates recruitment/derecruitment thresholds.</li> <li>compute_dr : calculate the discharge rate.</li> <li>compute_covisi : calculate the coefficient of variation of interspike     interval.</li> <li>compute_drvariability : calculate the DR variability.</li> </ul> <p>Examples:</p> <p>Get full summary of all the MUs properties.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; df = emg.basic_mus_properties(emgfile=emgfile)\n&gt;&gt;&gt; df\n     MVC  MU_number      abs_RT    abs_DERT     rel_RT   rel_DERT    DR_rec  DR_derec  DR_start_steady  DR_end_steady  DR_all_steady     DR_all  COVisi_steady  COVisi_all  COV_steady\n0  786.0          1  146.709276  126.128587  18.665302  16.046894  5.701081  4.662196         7.467810       6.242360       6.902616   6.814342      11.296316   16.309681    1.423286\n1    NaN          2   35.854200   45.676801   4.561603   5.811298  7.051127  6.752467        11.798908       9.977337      11.784061  11.683134      15.871254   21.233615         NaN\n2    NaN          3   80.757524   87.150011  10.274494  11.087788  6.101529  4.789000         7.940926       5.846093       7.671361   8.055731      35.755090   35.308650         NaN\n3    NaN          4   34.606886   37.569257   4.402912   4.779804  6.345692  5.333535        11.484875       9.636914      11.594712  11.109796      24.611246   29.372524         NaN\n</code></pre> <p>We can bypass manual prompting the MVC by pre-specifying it and/or bypass the manual selection of the steady state phase if previously calculated with an automated method.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; df = emg.basic_mus_properties(\n...     emgfile=emgfile,\n...     start_steady=20000,\n...     end_steady=50000,\n...     mvc=786,\n... )\n&gt;&gt;&gt; df\n     MVC  MU_number      abs_RT    abs_DERT     rel_RT   rel_DERT    DR_rec  DR_derec  DR_start_steady  DR_end_steady  DR_all_steady     DR_all  COVisi_steady  COVisi_all  COV_steady\n0  786.0          1  146.709276  126.128587  18.665302  16.046894  5.701081  4.662196         7.476697       6.271750       6.794170   6.814342      11.066966   16.309681    1.431752\n1    NaN          2   35.854200   45.676801   4.561603   5.811298  7.051127  6.752467        14.440561      10.019572      11.822081  11.683134      15.076819   21.233615         NaN\n2    NaN          3   80.757524   87.150011  10.274494  11.087788  6.101529  4.789000         7.293547       5.846093       7.589531   8.055731      36.996894   35.308650         NaN\n3    NaN          4   34.606886   37.569257   4.402912   4.779804  6.345692  5.333535        13.289651       9.694317      11.613640  11.109796      26.028689   29.372524         NaN\n</code></pre>"},{"location":"api_analysis/#openhdemg.library.analysis.compute_covisi","title":"<code>compute_covisi(emgfile, n_firings_RecDerec=4, start_steady=-1, end_steady=-1, event_='rec_derec_steady', idr_range=None, single_mu_number=-1)</code>","text":"<p>Calculate the COVisi.</p> <p>This function calculates the coefficient of variation of interspike interval (COVisi).</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>n_firings_RecDerec</code> <p>The number of firings at recruitment and derecruitment to consider for the calculation of the COVisi.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> <code>start_steady</code> <p>The start and end point (in samples) of the steady-state phase. If &lt; 0 (default), the user will need to manually select the start and end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <code>end_steady</code> <p>The start and end point (in samples) of the steady-state phase. If &lt; 0 (default), the user will need to manually select the start and end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <code>event_</code> <p>When to calculate the COVisi.</p> <p><code>rec_derec_steady</code>     covisi is calculated at recruitment, derecruitment and during     the steady-state phase.</p> <p><code>rec</code>     covisi is calculated at recruitment.</p> <p><code>derec</code>     covisi is calculated at derecruitment.</p> <p><code>rec_derec</code>     covisi is calculated at recruitment and derecruitment.</p> <p><code>steady</code>     covisi is calculated during the steady-state phase.</p> <p> TYPE: <code>str {\"rec_derec_steady\", \"rec\", \"derec\", \"rec_derec\", \"steady\"}</code> DEFAULT: <code>\"rec_derec_steady\"</code> </p> <code>idr_range</code> <p>If idr_range is a list [lower_limit, upper_limit], only firings with an instantaneous discharge rate (IDR) within the limits are used for COVisi calculation. lower_limit and upper_limit should be in pulses per second. See compute_dr() examples section. If idr_range is None, all the firings are used for DR calculation.</p> <p> TYPE: <code>None or list</code> DEFAULT: <code>None</code> </p> <code>single_mu_number</code> <p>Number of the specific MU to compute the COVisi. If single_mu_number &gt;= 0, only the COVisi of the entire contraction will be returned. If -1 (default), COVisi will be calculated for all the MUs.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> RETURNS DESCRIPTION <code>covisi</code> <p>A pd.DataFrame containing the requested COVisi.</p> <p> TYPE: <code>DataFrame</code> </p> See also <ul> <li>compute_thresholds : calculates recruitment/derecruitment thresholds.</li> <li>compute_dr : calculate the discharge rate.</li> <li>basic_mus_properties : calculate basic MUs properties on a trapezoidal     contraction.</li> <li>compute_drvariability : calculate the DR variability.</li> </ul> Notes <p>COVisi for all the contraction is automatically calculated and returned.</p> <p>Examples:</p> <p>Compute covisi during the various parts of the trapezoidal contraction.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; df = emg.compute_covisi(emgfile=emgfile)\n&gt;&gt;&gt; df\n   COVisi_rec  COVisi_derec  COVisi_steady  COVisi_all\n0    8.600651     24.007405      11.230602   16.309681\n1   46.874208     19.243432      16.657603   21.233615\n2   32.212757     18.642514      35.421124   35.308650\n3   62.995864     13.080768      24.966372   29.372524\n</code></pre> <p>If the steady-state phase has been pre-identified, the manual selection of the area can be bypassed.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; df = emg.compute_covisi(\n...     emgfile=emgfile,\n...     event_=\"rec_derec\",\n...     start_steady=20000,\n...     end_steady=50000,\n... )\n&gt;&gt;&gt; df\n   COVisi_rec  COVisi_derec  COVisi_all\n0    8.600651     24.007405   16.309681\n1   46.874208     19.243432   21.233615\n2   32.212757     18.642514   35.308650\n3   62.995864     13.080768   29.372524\n</code></pre> <p>To access the covisi of the entire contraction of a single MU.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; df = emg.compute_covisi(emgfile=emgfile, single_mu_number=2)\n&gt;&gt;&gt; df\n   COVisi_all\n0    35.30865\n</code></pre>"},{"location":"api_analysis/#openhdemg.library.analysis.compute_drvariability","title":"<code>compute_drvariability(emgfile, n_firings_RecDerec=4, start_steady=-1, end_steady=-1, event_='rec_derec_steady', idr_range=None)</code>","text":"<p>Calculate the DR variability.</p> <p>This function calculates the variability (as the coefficient of variation) of the instantaneous discharge rate (DR) at recruitment, derecruitment, during the steady-state phase and during all the contraction.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>n_firings_RecDerec</code> <p>The number of firings at recruitment and derecruitment to consider for the calculation of the DR variability.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> <code>start_steady</code> <p>The start and end point (in samples) of the steady-state phase. If &lt; 0 (default), the user will need to manually select the start and end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <code>end_steady</code> <p>The start and end point (in samples) of the steady-state phase. If &lt; 0 (default), the user will need to manually select the start and end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <code>event_</code> <p>When to calculate the DR variability.</p> <p><code>rec_derec_steady</code>     DR variability is calculated at recruitment, derecruitment and     during the steady-state phase.</p> <p><code>rec</code>     DR variability is calculated at recruitment.</p> <p><code>derec</code>     DR variability is calculated at derecruitment.</p> <p><code>rec_derec</code>     DR variability is calculated at recruitment and derecruitment.</p> <p><code>steady</code>     DR variability is calculated during the steady-state phase.</p> <p> TYPE: <code>str {\"rec_derec_steady\", \"rec\", \"derec\", \"rec_derec\", \"steady\"}</code> DEFAULT: <code>\"rec_derec_steady\"</code> </p> <code>idr_range</code> <p>If idr_range is a list [lower_limit, upper_limit], only firings with an instantaneous discharge rate (IDR) within the limits are used for DR variability calculation. lower_limit and upper_limit should be in pulses per second. See compute_dr() examples section. If idr_range is None, all the firings are used for DR calculation.</p> <p> TYPE: <code>None or list</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>drvariability</code> <p>A pd.DataFrame containing the requested DR variability.</p> <p> TYPE: <code>DataFrame</code> </p> See also <ul> <li>compute_thresholds : calculates recruitment/derecruitment thresholds.</li> <li>compute_dr : calculate the discharge rate.</li> <li>basic_mus_properties : calculate basic MUs properties on a trapezoidal     contraction.</li> <li>compute_covisi : calculate the coefficient of variation of interspike     interval.</li> </ul> Notes <p>DR variability for all the contraction is automatically calculated and returned.</p> <p>Examples:</p> <p>Compute covisi during the various parts of the trapezoidal contraction.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; df = emg.compute_covisi(emgfile=emgfile)\n&gt;&gt;&gt; df\n   DRvar_rec  DRvar_derec  DRvar_steady  DRvar_all\n0   8.560971    21.662783     11.051780  13.937779\n1  36.934213    17.714761     55.968609  52.726356\n2  28.943139    17.263000     49.375100  54.420703\n3  48.322396    12.873456     54.718482  48.019809\n</code></pre> <p>If the steady-state phase has been pre-identified, the manual selection of the area can be bypassed.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; df = emg.compute_covisi(\n...     emgfile=emgfile,\n...     event_=\"rec_derec\",\n...     start_steady=20000,\n...     end_steady=50000,\n... )\n&gt;&gt;&gt; df\n   DRvar_rec  DRvar_derec  DRvar_all\n0   8.560971    21.662783  13.937779\n1  36.934213    17.714761  52.726356\n2  28.943139    17.263000  54.420703\n3  48.322396    12.873456  48.019809\n</code></pre>"},{"location":"api_compatibility/","title":"compatibility","text":""},{"location":"api_compatibility/#description","title":"Description","text":"<p>This module contains the functions used to ensure the compatibility of file formats saved with previous versions of openhdemg with the most recent versions of the library.</p> <p></p> <p></p>"},{"location":"api_compatibility/#openhdemg.compatibility.conversions.convert_json_output","title":"<code>convert_json_output(old='', new='', old_version='0.1.0-beta.2', new_version='0.1.0-beta.3', append_name='converted', compresslevel=4, gui=True, ignore_safety_checks=False)</code>","text":"<p>Convert .json files saved from previous openhdemg versions to the desired format (target openhdemg version).</p> PARAMETER DESCRIPTION <code>old</code> <p>A path pointing to a .json file, or to a folder containing multiple .json files, saved from the openhdemg version specified in <code>old_version</code>. The path can be a simple string, the use of Path() is not necessary. If <code>old</code> points to a folder, all the .json files contained in that folder will be converted. Make sure that the folder contains only .json files from the openhdemg version specified in <code>old_version</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"\"</code> </p> <code>new</code> <p>A path pointing to the folder where the converted .json file/files will be saved. The path can be a simple string, the use of Path() is not necessary.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"\"</code> </p> <code>old_version</code> <p>The openhdemg version used to save the <code>old</code> files. Only \"0.1.0-beta.2\" is currently supported.</p> <p> TYPE: <code>str {0.1.0-beta.2}</code> DEFAULT: <code>0.1.0-beta.2</code> </p> <code>new_version</code> <p>The target openhdemg version for which you want to convert the files. Only \"0.1.0-beta.3\" is currently supported.</p> <p> TYPE: <code>str {0.1.0-beta.3}</code> DEFAULT: <code>0.1.0-beta.3</code> </p> <code>append_name</code> <p>String to append to the name of the converted file. Use append_name=\"\" to don't append any name.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"converted\"</code> </p> <code>compresslevel</code> <p>An int from 0 to 9, where 0 is no compression and nine maximum compression. Compressed files will take less space, but will require more computation. The relationship between compression level and time required for the compression is not linear. For optimised performance, we suggest values between 2 and 6, with 4 providing the best balance.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> <code>gui</code> <p>If true, the user will be able to select one or multiple .json files to convert and the output folder with a convenient graphical interface. If true, <code>old</code> and <code>new</code> can be ignored.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>ignore_safety_checks</code> <p>Safety checks are performed to avoid overwriting the original file. If <code>ignore_safety_checks=True</code>, the original file could be overwritten without asking user permission. The risk of overwriting files happens when converted files are saved in their original directory and with <code>append_name=\"\"</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <p>Convert the file/s with a practical GUI.</p> <pre><code>&gt;&gt;&gt; from openhdemg.compatibility import convert_json_output\n&gt;&gt;&gt; convert_json_output(gui=True, append_name=\"converted\")\n</code></pre> <p>Convert all the files in a folder without GUI. Save them in the same location with a different name.</p> <pre><code>&gt;&gt;&gt; from openhdemg.compatibility import convert_json_output\n&gt;&gt;&gt; old = \"C:/Users/.../test conversions/\"\n&gt;&gt;&gt; new = \"C:/Users/.../test conversions/\"\n&gt;&gt;&gt; convert_json_output(\n...     old=old,\n...     new=new,\n...     append_name=\"converted\",\n...     gui=False,\n... )\n</code></pre> <p>Convert a file in a folder without GUI and overwrite it.</p> <pre><code>&gt;&gt;&gt; from openhdemg.compatibility import convert_json_output\n&gt;&gt;&gt; old = \"C:/Users/.../test conversions/old_testfile.json\"\n&gt;&gt;&gt; new = \"C:/Users/.../test conversions/\"\n&gt;&gt;&gt; convert_json_output(\n...     old=old,\n...     new=new,\n...     append_name=\"\",\n...     gui=False,\n...     ignore_safety_checks=True,\n... )\n</code></pre>"},{"location":"api_compatibility/#openhdemg.compatibility.conversions.convert_json_output.load_0_1_0_b2","title":"<code>load_0_1_0_b2(filepath)</code>","text":""},{"location":"api_compatibility/#openhdemg.compatibility.conversions.convert_json_output.save_0_1_0_b3","title":"<code>save_0_1_0_b3(emgfile, filepath, compresslevel)</code>","text":""},{"location":"api_electrodes/","title":"electrodes","text":""},{"location":"api_electrodes/#description","title":"Description","text":"<p>This module contains informations about the electrodes commonly used for HD-EMG recordings. Functions to sort the electrode position are also included.</p>"},{"location":"api_electrodes/#notes","title":"Notes","text":"<p>The files saved from the DEMUSE software are supposed to be already sorted.</p> <p></p> <p></p>"},{"location":"api_electrodes/#openhdemg.library.electrodes.sort_rawemg","title":"<code>sort_rawemg(emgfile, code='GR08MM1305', orientation=180, dividebycolumn=True, n_rows=None, n_cols=None, custom_sorting_order=None)</code>","text":"<p>Sort RAW_SIGNAL based on matrix type and orientation.</p> <p>To date, built-in sorting functions have been implemented for the matrices:</p> <pre><code>Code                    (Orientation)\nGR08MM1305              (0, 180)\nGR04MM1305              (0, 180)\nGR10MM0808              (0, 180)\nTrigno Galileo Sensor   (na)\nCustom order            (any)\n</code></pre> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>code</code> <p>The code of the matrix used. It can be one of:</p> <p><code>GR08MM1305</code></p> <p><code>GR04MM1305</code></p> <p><code>GR10MM0808</code></p> <p><code>Trigno Galileo Sensor</code></p> <p><code>Custom order</code></p> <p><code>None</code></p> <p>If \"None\", the electodes are not sorted but n_rows and n_cols must be specified when dividebycolumn == True. If \"Custom order\", the electrodes are sorted based on custom_sorting_order.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"GR08MM1305\"</code> </p> <code>orientation</code> <p>Orientation in degree of the matrix. E.g. 180 corresponds to the matrix connection toward the researcher or the ground (depending on the limb). Ignore if using the \"Trigno Galileo Sensor\". In this case, channels will be oriented as in the Delsys Neuromap Explorer software. This Parameter is ignored if code==\"Custom order\" or code==\"None\".</p> <p> TYPE: <code>int {0, 180}</code> DEFAULT: <code>180</code> </p> <code>dividebycolumn</code> <p>Whether to return the sorted channels classified by matrix column.</p> <p> DEFAULT: <code>True</code> </p> <code>n_rows</code> <p>The number of rows of the matrix. This parameter is used to divide the channels based on the matrix shape. These are inferred by the matrix code and must be specified only if code==None.</p> <p> TYPE: <code>None or int</code> DEFAULT: <code>None</code> </p> <code>n_cols</code> <p>The number of columns of the matrix. This parameter is used to divide the channels based on the matrix shape. These are inferred by the matrix code and must be specified only if code==None.</p> <p> TYPE: <code>None or int</code> DEFAULT: <code>None</code> </p> <code>custom_sorting_order</code> <p>If code==\"Custom order\", custom_sorting_order will be used for channels sorting. In this case, custom_sorting_order must be a list of lists containing the order of the matrix channels. Specifically, the number of columns are defined by len(custom_sorting_order) while the number of rows by len(custom_sorting_order[0]). np.nan can be used to specify empty channels. Please refer to the Notes and Examples section for the structure of the custom sorting order.</p> <p> TYPE: <code>None or list</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>sorted_rawemg</code> <p>If dividebycolumn == True, a dict containing the sorted electrodes is returned. Every key of the dictionary represents a different column of the matrix. Rows are stored in the dict as a pd.DataFrame. If dividebycolumn == False a pd.DataFrame containing the sorted electrodes is returned. The matrix channels are stored in the pd.DataFrame columns.</p> <p> TYPE: <code>dict or DataFrame</code> </p> Notes <p>The returned file is called <code>sorted_rawemg</code> for convention.</p> <p>Additional info on how to create the custom sorting order is available at: https://www.giacomovalli.com/openhdemg/gui_settings/#electrodes</p> <p>Examples:</p> <p>Sort emgfile RAW_SIGNAL and divide it by columns with built-in sorting orders.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True,\n... )\n&gt;&gt;&gt; sorted_rawemg[\"col0\"]\n        0          1          2 ...        10         11         12\n0     NaN -11.189778   3.560384 ... -2.034505  -3.051758  -0.508626\n1     NaN -12.715657   4.577637 ...  2.034505  -7.120768  -0.508626\n2     NaN   0.508626  21.870932 ... 17.801920   8.646647  16.276041\n3     NaN   6.103516  26.957193 ... 26.448568  19.327799  19.836426\n4     NaN  -5.594889  13.224284 ... 10.681152   2.034505   3.560384\n...    ..        ...        ... ...       ...        ...        ...\n63483 NaN -15.767415 -22.379557 ...-12.207031 -12.207031 -15.767415\n63484 NaN  -9.155273 -19.327799 ... -7.629395  -8.138021  -8.138021\n63485 NaN  -6.103516 -12.207031 ... -6.103516  -5.086263  -3.051758\n63486 NaN  -6.103516 -15.767415 ... -3.560384  -0.508626   2.543132\n63487 NaN  -8.138021 -18.819174 ... -2.034505  -1.525879   3.560384\n</code></pre> <p>Sort emgfile RAW_SIGNAL without dividing it by columns.</p> <pre><code>&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=False,\n... )\n&gt;&gt;&gt; sorted_rawemg\n       0          1          2  ...        62         63         64\n0     NaN -11.189778   3.560384 ... -5.086263  -9.663899   2.034505\n1     NaN -12.715657   4.577637 ... -3.560384  -8.646647   1.017253\n2     NaN   0.508626  21.870932 ... 11.189778   6.612142  17.293295\n3     NaN   6.103516  26.957193 ... 22.888184  14.750163  21.362305\n4     NaN  -5.594889  13.224284 ...  9.663899   1.525879   6.612142\n...    ..        ...        ... ...       ...        ...        ...\n63483 NaN -15.767415 -22.379557 ... -8.646647 -20.345053 -15.258789\n63484 NaN  -9.155273 -19.327799 ... -7.120768 -19.327799 -13.732910\n63485 NaN  -6.103516 -12.207031 ... -3.051758 -10.681152  -6.103516\n63486 NaN  -6.103516 -15.767415 ...  2.543132  -7.120768  -4.069010\n63487 NaN  -8.138021 -18.819174 ...  2.034505  -3.051758  -0.508626\n</code></pre> <p>Avoid RAW_SIGNAL sorting but divide it by columns.</p> <pre><code>&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"CUSTOM\")\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile, code=\"None\", n_cols=5, n_rows=13,\n...     )\n&gt;&gt;&gt; sorted_rawemg[\"col0\"]\n             0         1         2  ...       10        11  12\n0      0.008138  0.001017  0.002035 ... 0.005595  0.008647 NaN\n1     -0.005595 -0.011190 -0.014750 ... 0.000000  0.005086 NaN\n2     -0.017293 -0.020854 -0.021871 ... 0.009664 -0.004578 NaN\n3     -0.003560 -0.012716 -0.009155 ... 0.004578  0.007121 NaN\n4      0.001526 -0.005595 -0.005595 ... 0.007121  0.010173 NaN\n...         ...       ...       ... ...      ...       ...  ..\n62459  0.011698  0.015259  0.004069 ... 0.000000  0.031026 NaN\n62460  0.007629  0.011698  0.002543 ... 0.002035  0.026449 NaN\n62461  0.001526  0.009664  0.000000 ... 0.001526  0.025940 NaN\n62462  0.033061  0.037130  0.027974 ... 0.022380  0.049845 NaN\n62463  0.020854  0.028992  0.017802 ... 0.013733  0.037638 NaN\n</code></pre> <p>Sort RAW_SIGNAL based on a custom order and divide it by columns. The custom_sorting_order refers to a grid of 13 rows and 5 columns with the empty channel in last position.</p> <p>Additional info on how to create the custom sorting order is available at: https://www.giacomovalli.com/openhdemg/gui_settings/#electrodes</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; custom_sorting_order = [\n...     [63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52,     51,],\n...     [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,     50,],\n...     [37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26,     25,],\n...     [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,     24,],\n...     [11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0, np.nan,],\n... ]  # 13 rows and 5 columns\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"Custom order\",\n...     dividebycolumn=True,\n...     custom_sorting_order=custom_sorting_order,\n... )\n&gt;&gt;&gt; sorted_rawemg[\"col0\"]\n              0          1          2  ...         10         11         12\n0       2.034505  -9.663899  -5.086263 ... -26.957193  -8.138021  -2.034505\n1       1.017253  -8.646647  -3.560384 ... -26.957193  -8.138021  -9.663899\n2      17.293295   6.612142  11.189778 ... -13.224284   9.663899   6.612142\n3      21.362305  14.750163  22.888184 ...  -9.155273  17.293295  12.715657\n...          ...        ...        ... ...        ...        ...        ...\n63483 -15.258789 -20.345053  -8.646647 ... -20.853678 -15.767415 -10.681152\n63484 -13.732910 -19.327799  -7.120768 ... -21.362305 -17.801920 -14.241536\n</code></pre>"},{"location":"api_info/","title":"info","text":""},{"location":"api_info/#description","title":"Description","text":"<p>This module contains all the information regarding:</p> <ul> <li>Data<ul> <li>Structures of data</li> <li>How to access data</li> </ul> </li> <li>Abbreviations</li> <li>AboutUs</li> <li>Contacts</li> <li>Links</li> <li>CiteUs</li> </ul> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"api_info/#openhdemg.library.info.data","title":"<code>data(emgfile)</code>","text":"<p>Print a description of the emgfile data structure.</p> <p>Print a detailed description of the emgfile data structure and of how to access the contained elements.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"DEMUSE\")\n&gt;&gt;&gt; emg.info().data(emgfile)\nemgfile type is:\n&lt;class 'dict'&gt;\nemgfile keys are:\ndict_keys(['SOURCE', 'FILENAME', 'RAW_SIGNAL', 'REF_SIGNAL', 'ACCURACY', 'IPTS', 'MUPULSES', 'FSAMP', 'IED', 'EMG_LENGTH', 'NUMBER_OF_MUS', 'BINARY_MUS_FIRING', 'EXTRAS'])\nAny key can be acced as emgfile[key].\nemgfile['SOURCE'] is a &lt;class 'str'&gt; of value:\nDEMUSE\n.\n.\n.\n</code></pre>"},{"location":"api_info/#openhdemg.library.info.abbreviations","title":"<code>abbreviations()</code>","text":"<p>Print common abbreviations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emg.info().abbreviations()\n\"COV\": \"Coefficient of variation\",\n\"DERT\": \"DERecruitment threshold\",\n\"DD\": \"Double differential\",\n\"DR\": \"Discharge rate\",\n\"FSAMP\": \"Sampling frequency\",\n\"IDR\": \"Instantaneous discharge rate\",\n\"IED\": \"Inter electrode distance\",\n\"IPTS\": \"Impulse train (decomposed source)\",\n\"MU\": \"Motor units\",\n\"MUAP\": \"MUs action potential\",\n\"PNR\": \"Pulse to noise ratio\",\n\"RT\": \"Recruitment threshold\",\n\"SD\": \"Single differential\",\n\"SIL\": \"Silhouette score\",\n\"STA\": \"Spike-triggered average\",\n\"XCC\": \"Cross-correlation coefficient\"\n</code></pre>"},{"location":"api_info/#openhdemg.library.info.aboutus","title":"<code>aboutus()</code>","text":"<p>Print informations about the library and the authors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emg.info().aboutus()\nThe openhdemg project was born in 2022 with the aim to provide a\nfree and open-source framework to analyse HIGH-DENSITY EMG\nrecordings...\n</code></pre>"},{"location":"api_info/#openhdemg.library.info.contacts","title":"<code>contacts()</code>","text":"<p>Print the contacts.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emg.info().contacts()\n\"Primary contact\": \"openhdemg@gmail.com\",\n\"Twitter\": \"@openhdemg\",\n\"Maintainer\": \"Giacomo Valli\",\n\"Maintainer Email\": \"giacomo.valli@unibs.it\",\n</code></pre>"},{"location":"api_info/#openhdemg.library.info.links","title":"<code>links()</code>","text":"<p>Print a collection of useful links.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emg.info().links()\n</code></pre>"},{"location":"api_info/#openhdemg.library.info.citeus","title":"<code>citeus()</code>","text":"<p>Print how to cite the project.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emg.info().citeus()\n</code></pre>"},{"location":"api_mathtools/","title":"mathtools","text":""},{"location":"api_mathtools/#description","title":"Description","text":"<p>This module contains all the mathematical functions that are necessary for the library.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"api_mathtools/#openhdemg.library.mathtools.min_max_scaling","title":"<code>min_max_scaling(series_or_df)</code>","text":"<p>Min-max scaling of pd.series or pd.dataframes.</p> <p>Min-max feature scaling is often simply referred to as normalisation, which rescales the dataset feature to a range of 0 - 1. It's calculated by subtracting the feature's minimum value from the value and then dividing it by the difference between the maximum and minimum value.</p> <p>The formula looks like this: xnorm = x - xmin / xmax - xmin.</p> PARAMETER DESCRIPTION <code>series_or_df</code> <p>The min-max scaling is performed for the entire series, or for single columns in a pd.DataFrame.</p> <p> TYPE: <code>Series or DataFrame</code> </p> RETURNS DESCRIPTION <code>object</code> <p>The normalised pd.Series or pd.DataFrame (normalised by column).</p> <p> TYPE: <code>Series or DataFrame</code> </p>"},{"location":"api_mathtools/#openhdemg.library.mathtools.norm_xcorr","title":"<code>norm_xcorr(sig1, sig2, out='both')</code>","text":"<p>Normalized cross-correlation of 2 signals.</p> PARAMETER DESCRIPTION <code>sig1</code> <p>The two signals to correlate. These signals must be 1-dimensional and of same length.</p> <p> TYPE: <code>Series or ndarray</code> </p> <code>sig2</code> <p>The two signals to correlate. These signals must be 1-dimensional and of same length.</p> <p> TYPE: <code>Series or ndarray</code> </p> <code>out</code> <p>A string indicating the output value:</p> <p><code>both</code>    The output is the greatest positive or negative cross-correlation    value.</p> <p><code>max</code>    The output is the maximum cross-correlation value.</p> <p> TYPE: <code>str {\"both\", \"max\"}</code> DEFAULT: <code>\"both\"</code> </p> RETURNS DESCRIPTION <code>xcc</code> <p>The cross-correlation value depending on \"out\".</p> <p> TYPE: <code>float</code> </p> See also <ul> <li>norm_twod_xcorr : Normalised 2-dimensional cross-correlation of STAs of     two MUS.</li> </ul>"},{"location":"api_mathtools/#openhdemg.library.mathtools.norm_twod_xcorr","title":"<code>norm_twod_xcorr(df1, df2, mode='full')</code>","text":"<p>Normalised 2-dimensional cross-correlation of 2.</p> <p>The two inputs must have same shape. When this function is used to cross-correlate MUAPs obtained via STA, df1 and df2 should contain the unpacked STA of the first and second MU, respectively, without np.nan columns.</p> PARAMETER DESCRIPTION <code>df1</code> <p>A pd.DataFrame containing the first 2-dimensional signal.</p> <p> TYPE: <code>DataFrame</code> </p> <code>df2</code> <p>A pd.DataFrame containing the second 2-dimensional signal.</p> <p> TYPE: <code>DataFrame</code> </p> <code>mode</code> <p>A string indicating the size of the output:</p> <p><code>full</code>    The output is the full discrete linear cross-correlation    of the inputs. (Default)</p> <p><code>valid</code>    The output consists only of those elements that do not    rely on the zero-padding. In 'valid' mode, either <code>sta_mu1</code> or    <code>sta_mu2</code> must be at least as large as the other in every dimension.</p> <p><code>same</code>    The output is the same size as <code>in1</code>, centered    with respect to the 'full' output.</p> <p> TYPE: <code>str {\"full\", \"valid\", \"same\"}</code> DEFAULT: <code>\"full\"</code> </p> RETURNS DESCRIPTION <code>normxcorr_df</code> <p>The results of the normalised 2d cross-correlation.</p> <p> TYPE: <code>DataFrame</code> </p> <code>normxcorr_max</code> <p>The maximum value of the 2d cross-correlation.</p> <p> TYPE: <code>float</code> </p> See also <ul> <li>align_by_xcorr : to align the two STAs before calling norm_twod_xcorr.</li> <li>unpack_sta : for unpacking the sta dict in a pd.DataFrame     before passing it to norm_twod_xcorr.</li> <li>pack_sta : for packing the sta pd.DataFrame in a dict where     each matrix column corresponds to a dict key.</li> </ul> <p>Examples:</p> <p>Full steps to pass two dataframes to norm_twod_xcorr from the same EMG file.</p> <ol> <li>Load the EMG file and band-pass filter the raw EMG signal</li> <li>Sort the matrix channels and compute the spike-triggered average</li> <li>Extract the STA of the MUs of interest from all the STAs</li> <li>Unpack the STAs of single MUs and remove np.nan to pass them to     norm_twod_xcorr</li> <li>Compute 2dxcorr to identify a common lag/delay</li> </ol> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emgfile = emg.filter_rawemg(emgfile, order=2, lowcut=20, highcut=500)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     )\n&gt;&gt;&gt; sta = emg.sta(emgfile, sorted_rawemg, firings=[0, 50], timewindow=100)\n&gt;&gt;&gt; mu0 = 0\n&gt;&gt;&gt; mu1 = 1\n&gt;&gt;&gt; sta_mu1 = sta[mu0]\n&gt;&gt;&gt; sta_mu2 = sta[mu1]\n&gt;&gt;&gt; df1 = emg.unpack_sta(sta_mu1)\n&gt;&gt;&gt; no_nan_sta1 = df1.dropna(axis=1)\n&gt;&gt;&gt; df2 = emg.unpack_sta(sta_mu2)\n&gt;&gt;&gt; no_nan_sta2 = df2.dropna(axis=1)\n&gt;&gt;&gt; normxcorr_df, normxcorr_max = emg.norm_twod_xcorr(\n...     no_nan_sta1,\n...     no_nan_sta2,\n...     )\n&gt;&gt;&gt; normxcorr_max\n0.7241553627564273\n&gt;&gt;&gt; normxcorr_df\n            0             1             2               125       126\n0   -0.000002 -1.467778e-05 -3.013564e-05 ... -1.052780e-06  0.000001\n1   -0.000004 -2.818055e-05 -6.024427e-05 ... -4.452469e-06  0.000001\n2   -0.000007 -4.192479e-05 -9.223725e-05 ... -1.549197e-05 -0.000002\n3   -0.000009 -5.071660e-05 -1.174545e-04 ... -3.078518e-05 -0.000007\n4   -0.000007 -4.841255e-05 -1.239106e-04 ... -4.232094e-05 -0.000012\n..        ...           ...           ... ...           ...       ...\n402  0.000005  1.641773e-05  3.994943e-05 ...  8.170792e-07 -0.000006\n403 -0.000001  4.535878e-06  1.858700e-05 ...  2.087135e-06 -0.000003\n404 -0.000004 -1.241530e-06  5.704194e-06 ...  1.027966e-05  0.000002\n405 -0.000004 -1.693078e-06  1.054646e-06 ...  1.811828e-05  0.000007\n406 -0.000002 -2.473282e-07  6.006046e-07 ...  1.605406e-05  0.000007\n</code></pre>"},{"location":"api_mathtools/#openhdemg.library.mathtools.compute_sil","title":"<code>compute_sil(ipts, mupulses, ignore_negative_ipts=False)</code>","text":"<p>Calculate the Silhouette score for a single MU.</p> <p>The SIL is defined as the difference between the within-cluster sums of point-to-centroid distances and the same measure calculated between clusters. The output measure is normalised in a range between 0 and 1.</p> PARAMETER DESCRIPTION <code>ipts</code> <p>The  decomposed source (or pulse train, IPTS[mu]) of the MU of interest.</p> <p> TYPE: <code>Series</code> </p> <code>mupulses</code> <p>The time of firing (MUPULSES[mu]) of the MU of interest.</p> <p> TYPE: <code>ndarray</code> </p> <code>ignore_negative_ipts</code> <p>If True, only use positive ipts during peak and noise clustering. This is particularly important for sources with large negative components.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>sil</code> <p>The SIL score.</p> <p> TYPE: <code>float</code> </p> See also <ul> <li>compute_pnr : to calculate the Pulse to Noise ratio of a single MU.</li> </ul> <p>Examples:</p> <p>Calculate the SIL score for the third MU (MU number 2) ignoring the negative component of the decomposed source.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.emg_from_samplefile()\n&gt;&gt;&gt; mu_of_interest = 2\n&gt;&gt;&gt; sil_value = emg.compute_sil(\n...     ipts=emgfile[\"IPTS\"][mu_of_interest],\n...     mupulses=emgfile[\"MUPULSES\"][mu_of_interest],\n...     ignore_negative_ipts=True,\n... )\n</code></pre>"},{"location":"api_mathtools/#openhdemg.library.mathtools.compute_pnr","title":"<code>compute_pnr(ipts, mupulses, fsamp, constrain_pulses=[True, 3], separate_paired_firings=True)</code>","text":"<p>Calculate the pulse to noise ratio for a single MU.</p> PARAMETER DESCRIPTION <code>ipts</code> <p>The decomposed source (or pulse train, IPTS[mu]) of the MU of interest.</p> <p> TYPE: <code>Series</code> </p> <code>mupulses</code> <p>The time of firing (MUPULSES[mu]) of the MU of interest.</p> <p> TYPE: <code>ndarray</code> </p> <code>constrain_pulses</code> <p>If constrain_pulses[0] == True, the times of firing are considered those in mupulses +- the number of samples specified in constrain_pulses[1]. If constrain_pulses[0] == False, the times of firing are estimated via a heuristic penalty funtion (see Notes). constrain_pulses[1] must be an integer (see Notes for instructions on how to set the appropriate value).</p> <p> TYPE: <code>list</code> DEFAULT: <code>[True, 3]</code> </p> <code>separate_paired_firings</code> <p>Whether to treat differently paired and non-paired firings during the estimation of the signal/noise threshold (heuristic penalty funtion, see Notes). This is relevant only if constrain_pulses[0] == False. Otherwise, this argument is ignored.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>pnr</code> <p>The PNR in decibels.</p> <p> TYPE: <code>float</code> </p> See also <ul> <li>compute_sil : to calculate the Silhouette score for a single MU.</li> </ul> Notes <p>The behaviour of the compute_pnr() function is determined by the argument constrain_pulses.</p> <p>If constrain_pulses[0] == True, the times of firing are considered those in mupulses +- a number of samples specified in constrain_pulses[1]. The inclusion of the samples around the mupulses values allows to capture the full ipts corresponding to the time of firing (e.g., including also the raising and falling wedges). The appropriate value of constrain_pulses[1] must be determined by the user and depends on the sampling frequency. It is suggested to use 3 when the sampling frequency is 2000 or 2048 Hz and increase it if the sampling frequency is higher (e.g. use 6 at 4000 or 4096 Hz). With this approach, the PNR estimation is not related to the variability of the firings.</p> <p>If constrain_pulses[0] == False, the ipts values are classified as firings or noise based on a threshold value (named \"Pi\" or \"r\") estimated from the euristic penalty funtion described in Holobar 2012, as proposed in Holobar 2014. If the variability of the firings is relevant, this apoproach should be preferred. Specifically: Pi = D \u00b7 \u03c73,50 + CoVIDI + CoVpIDI Where: D is the median of the low-pass filtered instantaneous motor unit discharge rate (first-order Butterworth filter, cut-off frequency 3 Hz). \u03c73,50 stands for an indicator function that penalizes motor units with filtered discharge rate D below 3 pulses per second (pps) or above 50 pps: \u03c73,50 = 0 if D is between 3 and 50 or D if D is not between 3 and 50. Two separate coefficients of variation for inter-discharge interval (IDI) calculated as standard deviation (SD) of IDI divided by the mean IDI, are used. CoVIDI is the coefficient of variation for IDI of non-paired MUs discharges only, whereas CoVpIDI is the coefficient of variation for IDI of paired MUs discharges. Holobar 2012 considered MUs discharges paired whenever the second discharge was within 50 ms of the first. Paired discharges are typical in pathological tremor and the use of both CoVIDI and CoVpIDI accounts for this condition. However, this heuristic penalty function penalizes MUs firing during specific types of contractions like explosive contractions (MUs discharge up to 200 pps). Therefore, in this implementation of the PNR, we did <code>not</code> include the penalty based on MUs discharge. Additionally, the user can decide whether to adopt the two coefficients of variations to estimate Pi or not. If both are used, Pi would be calculated as: Pi = CoVIDI + CoVpIDI Otherwise, Pi would be calculated as: Pi = CoV_all_IDI</p> <p>Examples:</p> <p>Calculate the PNR value for the third MU (MU number 2) forcing the selction of the times of firing.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.emg_from_samplefile()\n&gt;&gt;&gt; mu_of_interest = 2\n&gt;&gt;&gt; pnr_value = emg.compute_pnr(\n...     ipts=emgfile[\"IPTS\"][mu_of_interest],\n...     mupulses=emgfile[\"MUPULSES\"][mu_of_interest],\n...     fsamp=emgfile[\"FSAMP\"],\n...     constrain_pulses=[True, 3],\n... )\n</code></pre> <p>Calculate the PNR value for the third MU (MU number 2) selecting the times of firing based on the euristic penalty funtion described in Holobar 2012 and considering, separately, the paired and the non-paired firings.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.emg_from_samplefile()\n&gt;&gt;&gt; mu_of_interest = 2\n&gt;&gt;&gt; pnr_value = emg.compute_pnr(\n...     ipts=emgfile[\"IPTS\"][mu_of_interest],\n...     mupulses=emgfile[\"MUPULSES\"][mu_of_interest],\n...     fsamp=emgfile[\"FSAMP\"],\n...     constrain_pulses=[False],\n...     separate_paired_firings=True,\n... )\n</code></pre>"},{"location":"api_muap/","title":"muap","text":""},{"location":"api_muap/#description","title":"Description","text":"<p>This module contains functions to produce and analyse MUs anction potentials (MUAPs).</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"api_muap/#openhdemg.library.muap.diff","title":"<code>diff(sorted_rawemg)</code>","text":"<p>Calculate single differential (SD) of RAW_SIGNAL on matrix rows.</p> PARAMETER DESCRIPTION <code>sorted_rawemg</code> <p>A dict containing the sorted electrodes. Every key of the dictionary represents a different column of the matrix. Rows are stored in the dict as a pd.DataFrame. Electrodes can be sorted with the function emg.sort_rawemg.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>sd</code> <p>A dict containing the double differential signal. Every key of the dictionary represents a different column of the matrix. Rows are stored in the dict as a pd.DataFrame.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>double_diff : calculate double differential of RAW_SIGNAL on matrix rows.</li> </ul> Notes <p>The returned sd will contain one less matrix row.</p> <p>Examples:</p> <p>Calculate single differential of a DEMUSE file with the channels already sorted.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"DEMUSE\")\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n&gt;&gt;&gt;     emgfile,\n...     code=\"None\",\n...     orientation=180,\n...     dividebycolumn=True,\n...     n_rows=13,\n...     n_cols=5,\n... )\n&gt;&gt;&gt; sd = emg.diff(sorted_rawemg)\n&gt;&gt;&gt; sd[\"col0\"]\n             1         2         3  ...        10        11  12\n0     -0.003052  0.005086 -0.009155 ...  0.001526  0.016785 NaN\n1     -0.008647  0.008138 -0.010173 ... -0.001017 -0.015259 NaN\n2     -0.005595  0.005595 -0.013733 ...  0.003560  0.007629 NaN\n3     -0.010681  0.007121 -0.009664 ... -0.001526 -0.015259 NaN\n4     -0.005595  0.005086 -0.011190 ...  0.001017  0.017293 NaN\n...         ...       ...       ... ...       ...       ...  ..\n63483 -0.000509  0.007121 -0.007629 ... -0.006612  0.022380 NaN\n63484 -0.005086  0.005595 -0.004578 ... -0.005595 -0.045776 NaN\n63485 -0.004069  0.001017 -0.003560 ... -0.005086 -0.005086 NaN\n63486 -0.002035  0.006104 -0.010681 ... -0.007121  0.020345 NaN\n63487 -0.008647  0.000000 -0.010681 ... -0.011190 -0.027466 NaN\n</code></pre> <p>Calculate single differential of an OTB file where the channels need to be sorted.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n... )\n&gt;&gt;&gt; sd = emg.diff(sorted_rawemg)\n</code></pre>"},{"location":"api_muap/#openhdemg.library.muap.double_diff","title":"<code>double_diff(sorted_rawemg)</code>","text":"<p>Calculate double differential (DD) of RAW_SIGNAL on matrix rows.</p> PARAMETER DESCRIPTION <code>sorted_rawemg</code> <p>A dict containing the sorted electrodes. Every key of the dictionary represents a different column of the matrix. Rows are stored in the dict as a pd.DataFrame. Electrodes can be sorted with the function emg.sort_rawemg.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>dd</code> <p>A dict containing the double differential signal. Every key of the dictionary represents a different column of the matrix. Rows are stored in the dict as a pd.DataFrame.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>diff : Calculate single differential of RAW_SIGNAL on matrix rows.</li> </ul> Notes <p>The returned dd will contain two less matrix rows.</p> <p>Examples:</p> <p>Calculate double differential of a DEMUSE file with the channels already sorted.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"DEMUSE\")\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n&gt;&gt;&gt;     emgfile,\n...     code=\"None\",\n...     orientation=180,\n...     dividebycolumn=True,\n...     n_rows=13,\n...     n_cols=5,\n... )\n&gt;&gt;&gt; dd = emg.double_diff(sorted_rawemg)\n&gt;&gt;&gt; dd[\"col0\"]\n             2         3         4  ...            10        11  12\n0      0.008138 -0.014242  0.012716 ...  4.577637e-03  0.015259 NaN\n1      0.016785 -0.018311  0.022380 ...  8.138018e-03 -0.014242 NaN\n2      0.011190 -0.019328  0.021362 ...  1.780192e-02  0.004069 NaN\n3      0.017802 -0.016785  0.014750 ...  1.118978e-02 -0.013733 NaN\n4      0.010681 -0.016276  0.017802 ...  4.577637e-03  0.016276 NaN\n...         ...       ...       ... ...           ...       ...  ..\n63483  0.007629 -0.014750  0.011698 ... -4.656613e-10  0.028992 NaN\n63484  0.010681 -0.010173  0.011698 ... -2.543131e-03 -0.040181 NaN\n63485  0.005086 -0.004578  0.004069 ... -6.612142e-03  0.000000 NaN\n63486  0.008138 -0.016785  0.013733 ... -1.068115e-02  0.027466 NaN\n63487  0.008647 -0.010681  0.019836 ... -1.068115e-02 -0.016276 NaN\n</code></pre> <p>Calculate single differential of an OTB file where the channels need to be sorted.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True,\n... )\n&gt;&gt;&gt; dd = emg.double_diff(sorted_rawemg)\n</code></pre>"},{"location":"api_muap/#openhdemg.library.muap.extract_delsys_muaps","title":"<code>extract_delsys_muaps(emgfile)</code>","text":"<p>Extract MUAPs obtained from Delsys decomposition.</p> <p>The extracted MUAPs will be stored in the same structure of the MUAPs obtained with the <code>sta</code> funtion.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>muaps_dict</code> <p>dict containing a dict of MUAPs (pd.DataFrame) for every MUs.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>sta : Computes the spike-triggered average (STA) of every MUs.</li> </ul> Notes <p>The returned file can be used wherever MUAPs from spike triggered averaging are required.</p> <p>Examples:</p> <p>Visualise the MUAPs of the first MU.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"DELSYS\")\n&gt;&gt;&gt; muaps = emg.extract_delsys_muaps(emgfile)\n&gt;&gt;&gt; emg.plot_muaps(muaps[0])\n</code></pre> <p>Visualise the MUAPs of the first 3 MUs.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"DELSYS\")\n&gt;&gt;&gt; muaps = emg.extract_delsys_muaps(emgfile)\n&gt;&gt;&gt; emg.plot_muaps([muaps[0], muaps[1], muaps[2]])\n</code></pre>"},{"location":"api_muap/#openhdemg.library.muap.sta","title":"<code>sta(emgfile, sorted_rawemg, firings=[0, 50], timewindow=50)</code>","text":"<p>Computes the spike-triggered average (STA) of every MUs.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>sorted_rawemg</code> <p>A dict containing the sorted electrodes. Every key of the dictionary represents a different column of the matrix. Rows are stored in the dict as a pd.DataFrame.</p> <p> TYPE: <code>dict</code> </p> <code>firings</code> <p>The range of firings to be used for the STA. If a MU has less firings than the range, the upper limit is adjusted accordingly.</p> <p><code>all</code>     The STA is calculated over all the firings.</p> <p> TYPE: <code>list or str {\"all\"}</code> DEFAULT: <code>[0, 50]</code> </p> <code>timewindow</code> <p>Timewindow to compute STA in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>sta_dict</code> <p>dict containing a dict of STA (pd.DataFrame) for every MUs.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>unpack_sta : build a common pd.DataFrame from the sta dict containing     all the channels.</li> <li>pack_sta : pack the pd.DataFrame containing STA to a dict.</li> <li>st_muap : generate spike triggered MUs action potentials     over the entire spike train of every MUs.</li> </ul> Notes <p>The returned file is called <code>sta_dict</code> for convention.</p> <p>Examples:</p> <p>Calculate STA of all the MUs in the emgfile on the first 25 firings and in a 50 ms time-window. Access the STA of the column 0 of the first MU (number 0).</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n... )\n&gt;&gt;&gt; sta = emg.sta(\n...     emgfile=emgfile,\n...     sorted_rawemg=sorted_rawemg,\n...     firings=[0,25],\n...     timewindow=50,\n... )\n&gt;&gt;&gt; sta[0][\"col0\"]\n     0          1          2  ...        10         11         12\n0   NaN  -7.527668  -7.141111 ... -1.464846 -21.606445 -14.180500\n1   NaN -16.662600 -14.038087 ...  2.868650 -19.246420 -15.218098\n2   NaN -21.443687 -15.116375 ...  5.615236 -16.052244 -13.854978\n3   NaN -17.822264  -9.989420 ...  6.876628 -12.451175 -12.268069\n4   NaN -14.567060  -8.748373 ... -1.403812 -14.241538 -16.703283\n..   ..        ...        ... ...       ...        ...        ...\n97  NaN  19.388836  25.166826 ... 39.591473  23.681641  19.653318\n98  NaN   8.870444  16.337074 ... 28.706865  20.548504   8.422853\n99  NaN  -1.037601   7.446290 ... 18.086752  16.276041   0.040688\n100 NaN  -2.766926   5.371094 ... 11.006674  14.261881  -0.712078\n101 NaN   3.214517   9.562176 ...  4.475910  10.742184  -0.284828\n</code></pre> <p>Calculate STA of the differential signal on all the firings.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n... )\n&gt;&gt;&gt; sd = emg.diff(sorted_rawemg=sorted_rawemg)\n&gt;&gt;&gt; sta = emg.sta(\n...     emgfile=emgfile,\n...     sorted_rawemg=sd,\n...     firings=\"all\",\n...     timewindow=50,\n... )\n&gt;&gt;&gt; sta[0][\"col0\"]\n     1         2          3  ...         10         11         12\n0   NaN -0.769545  11.807394 ...   3.388641  14.423187   1.420190\n1   NaN -1.496154  11.146843 ...   4.637086  12.312718   3.408456\n2   NaN -3.263135   9.660598 ...   6.258748   9.478946   5.974706\n3   NaN -4.125159   9.257659 ...   6.532877   5.558562   7.708665\n4   NaN -4.234151   9.379863 ...   6.034157   1.506064   8.722610\n..   ..       ...        ... ...        ...        ...        ...\n97  NaN -6.126635   1.225329 ... -10.050324   1.522576  -9.568117\n98  NaN -6.565903   0.571378 ...  -8.669765   4.643692 -10.714180\n99  NaN -6.153056  -0.105689 ...  -6.836730   7.272696 -12.623180\n100 NaN -5.452869  -0.587892 ...  -7.411412   8.504627 -14.727043\n101 NaN -4.587545  -0.855417 ... -10.549041   9.802613 -15.820260\n</code></pre>"},{"location":"api_muap/#openhdemg.library.muap.st_muap","title":"<code>st_muap(emgfile, sorted_rawemg, timewindow=50)</code>","text":"<p>Generate spike triggered MUAPs of every MUs.</p> <p>Generate single spike triggered (ST) MUs action potentials (MUAPs) over the entire spike train of every MUs.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>sorted_rawemg</code> <p>A dict containing the sorted electrodes. Every key of the dictionary represents a different column of the matrix. Rows are stored in the dict as a pd.DataFrame.</p> <p> TYPE: <code>dict</code> </p> <code>timewindow</code> <p>Timewindow to compute ST MUAPs in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>stmuap</code> <p>dict containing a dict of ST MUAPs (pd.DataFrame) for every MUs. The pd.DataFrames containing the ST MUAPs are organised based on matrix rows (dict) and matrix channels. For example, the ST MUAPs of the first MU (0), in the second electrode of the first matrix column can be accessed as stmuap0[1].</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>sta : computes the STA of every MUs.</li> </ul> Notes <p>The returned file is called <code>stmuap</code> for convention.</p> <p>Examples:</p> <p>Calculate the MUAPs of the differential signal. Access the MUAPs of the first MU (number 0), channel 15 that is contained in the second matrix column (\"col1\").</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n... )\n&gt;&gt;&gt; sd = emg.diff(sorted_rawemg=sorted_rawemg)\n&gt;&gt;&gt; stmuap = emg.st_muap(emgfile=emgfile, sorted_rawemg=sd, timewindow=50)\n&gt;&gt;&gt; stmuap[0][\"col1\"][15]\n           0          1          2   ...        151         152         153\n0   -14.750162 -26.957193   6.103516 ...  23.905434    4.069008  150.553375\n1    -9.155273 -22.379557  12.715660 ...   8.138023    0.000000  133.260086\n2    -4.069010 -12.207031  17.293289 ...  -6.612144    6.612141   74.768066\n3     1.525879  -6.612143  22.379562 ... -25.939949   21.362305  -14.750168\n4     3.051758  -4.577637  24.414062 ... -35.603844   34.586590  -83.923347\n..         ...        ...        ... ...        ...         ...         ...\n97    9.155273 -24.922688  43.233238 ... -92.569984 -107.320145  -40.181477\n98   -2.543133 -14.241535  28.483074 ...-102.233887  -68.155922  -19.836430\n99  -23.905437 -13.732906  15.767414 ... -89.518234  -42.215984  -10.681152\n100 -52.388512 -20.853680  14.241537 ... -71.716309  -26.448566    0.000000\n101 -61.543785 -16.784668  21.362305 ... -52.388504   -3.560385    6.103516\n</code></pre>"},{"location":"api_muap/#openhdemg.library.muap.unpack_sta","title":"<code>unpack_sta(sta_mu)</code>","text":"<p>Build a common pd.DataFrame from the sta_dict containing all the channels.</p> PARAMETER DESCRIPTION <code>sta_mu</code> <p>A dict containing the STA of a single MU.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>df1</code> <p>A pd.DataFrame containing the STA of the MU (including the empty channel).</p> <p> TYPE: <code>DataFrame</code> </p> <code>keys</code> <p>The matrix columns (dict keys) of the unpacked sta.</p> <p> TYPE: <code>list</code> </p> See also <ul> <li>sta : computes the STA of every MUs.</li> <li>pack_sta : pack the pd.DataFrame containing STA to a dict.</li> </ul>"},{"location":"api_muap/#openhdemg.library.muap.pack_sta","title":"<code>pack_sta(df_sta, keys)</code>","text":"<p>Pack the pd.DataFrame containing STA to a dict.</p> PARAMETER DESCRIPTION <code>df_sta</code> <p>(including the empty channel).</p> <p> TYPE: <code>A pd.DataFrame containing the STA of a single MU</code> </p> <code>keys</code> <p>The matrix columns (dict keys) by which to pack the sta.</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>packed_sta</code> <p>dict containing STA of the input pd.DataFrame divided by matrix column. Dict columns are \"col0\", col1\", \"col2\", \"col3\", \"col4\".</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>sta : computes the STA of every MUs.</li> <li>unpack_sta : build a common pd.DataFrame from the sta dict containing     all the channels.</li> </ul>"},{"location":"api_muap/#openhdemg.library.muap.align_by_xcorr","title":"<code>align_by_xcorr(sta_mu1, sta_mu2, finalduration=0.5)</code>","text":"<p>Align the STA of 2 MUs by cross-correlation.</p> <p>Any pre-processing of the RAW_SIGNAL (i.e., normal, differential or double differential) can be passed as long as the two inputs have same shape. Since the returned STA is cut based on finalduration, the input STA should account for this.</p> PARAMETER DESCRIPTION <code>sta_mu1</code> <p>A dictionary containing the STA of the first MU.</p> <p> TYPE: <code>dict</code> </p> <code>sta_mu2</code> <p>A dictionary containing the STA of the second MU.</p> <p> TYPE: <code>dict</code> </p> <code>finalduration</code> <p>Duration of the aligned STA compared to the original in percent. (e.g., 0.5 corresponds to 50%).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> RETURNS DESCRIPTION <code>aligned_sta1</code> <p>A dictionary containing the aligned STA of the first MU with the final expected timewindow (duration of sta_mu * finalduration).</p> <p> TYPE: <code>dict</code> </p> <code>aligned_sta2</code> <p>A dictionary containing the aligned STA of the second MU with the final expected timewindow (duration of sta_mu * finalduration).</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>sta : computes the STA of every MUs.</li> <li>norm_twod_xcorr : normalised 2-dimensional cross-correlation of STAs of     two MUs.</li> </ul> Notes <p>STAs are aligned by a common lag/delay for the entire matrix and not channel by channel because this might lead to misleading results.</p> <p>Examples:</p> <p>Align two MUs with a final duration of 50% the original one.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n... )\n&gt;&gt;&gt; sta = emg.sta(\n...     emgfile=emgfile,\n...     sorted_rawemg=sorted_rawemg,\n...     timewindow=100,\n... )\n&gt;&gt;&gt; aligned_sta1, aligned_sta2 = emg.align_by_xcorr(\n...     sta_mu1=sta[0], sta_mu2=sta[1], finalduration=0.5,\n... )\n&gt;&gt;&gt; aligned_sta1[\"col0\"]\n     0          1          2  ...        10         11         12\n0   NaN -10.711670  -7.008868 ... 21.809900 -33.447262 -21.545408\n1   NaN  -5.584714  -2.380372 ... 22.664387 -33.081059 -18.931072\n2   NaN  -4.262290  -1.139323 ... 23.244226 -33.020020 -17.456057\n3   NaN  -4.638671  -1.078290 ... 23.111980 -34.118645 -18.147787\n4   NaN  -7.405599  -4.018145 ... 22.888189 -35.797115 -22.247314\n..   ..        ...        ... ...       ...        ...        ...\n97  NaN   6.764731  13.081865 ... 30.954998  39.672852  42.429604\n98  NaN   4.455567  10.467529 ... 31.311037  41.280106  44.403072\n99  NaN   0.356039   6.856283 ... 30.436195  43.701172  46.142574\n100 NaN  -2.960206   4.872639 ... 30.008953  44.342041  46.366371\n101 NaN  -7.008870   1.708984 ... 25.634764  40.100101  43.009445\n</code></pre>"},{"location":"api_muap/#openhdemg.library.muap.tracking","title":"<code>tracking(emgfile1, emgfile2, firings='all', derivation='sd', timewindow=50, threshold=0.8, matrixcode='GR08MM1305', orientation=180, n_rows=None, n_cols=None, custom_sorting_order=None, custom_muaps=None, exclude_belowthreshold=True, filter=True, multiprocessing=True, show=False, gui=True, gui_addrefsig=True, gui_csv_separator='\\t')</code>","text":"<p>Track MUs across two files comparing the MUAPs' shape and distribution.</p> <p>It is also possible to use a convenient GUI for the inspection of the obtained MU pairs.</p> PARAMETER DESCRIPTION <code>emgfile1</code> <p>The dictionary containing the first emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>emgfile2</code> <p>The dictionary containing the second emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>firings</code> <p>The range of firings to be used for the STA. If a MU has less firings than the range, the upper limit is adjusted accordingly.</p> <p><code>all</code>     The STA is calculated over all the firings.</p> <p>A list can be passed as [start, stop] e.g., [0, 25] to compute the STA on the first 25 firings.</p> <p> TYPE: <code>list or str {\"all\"}</code> DEFAULT: <code>\"all\"</code> </p> <code>derivation</code> <p>Whether to compute the sta on the monopolar signal, or on the single or double differential derivation.</p> <p> TYPE: <code>str {mono, sd, dd}</code> DEFAULT: <code>sd</code> </p> <code>timewindow</code> <p>Timewindow to compute STA in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> <code>threshold</code> <p>The 2-dimensional cross-correlation minimum value to consider two MUs to be the same. Ranges 0-1.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.8</code> </p> <code>matrixcode</code> <p>The code of the matrix used. It can be one of:</p> <p><code>GR08MM1305</code></p> <p><code>GR04MM1305</code></p> <p><code>GR10MM0808</code></p> <p><code>Custom order</code></p> <p><code>None</code></p> <p>This is necessary to sort the channels in the correct order. If matrixcode=\"None\", the electrodes are not sorted. In this case, n_rows and n_cols must be specified. If \"Custom order\", the electrodes are sorted based on custom_sorting_order.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"GR08MM1305\"</code> </p> <code>orientation</code> <p>Orientation in degree of the matrix (same as in OTBiolab). E.g. 180 corresponds to the matrix connection toward the user. This Parameter is ignored if code==\"Custom order\" or code==\"None\".</p> <p> TYPE: <code>int {0, 180}</code> DEFAULT: <code>180</code> </p> <code>n_rows</code> <p>The number of rows of the matrix. This parameter is used to divide the channels based on the matrix shape. These are normally inferred by the matrix code and must be specified only if code == None.</p> <p> TYPE: <code>None or int</code> DEFAULT: <code>None</code> </p> <code>n_cols</code> <p>The number of columns of the matrix. This parameter is used to divide the channels based on the matrix shape. These are normally inferred by the matrix code and must be specified only if code == None.</p> <p> TYPE: <code>None or int</code> DEFAULT: <code>None</code> </p> <code>custom_sorting_order</code> <p>If code==\"Custom order\", custom_sorting_order will be used for channels sorting. In this case, custom_sorting_order must be a list of lists containing the order of the matrix channels. Specifically, the number of columns are defined by len(custom_sorting_order) while the number of rows by len(custom_sorting_order[0]). np.nan can be used to specify empty channels. Please refer to the Examples section for the structure of the custom sorting order.</p> <p> TYPE: <code>None or list</code> DEFAULT: <code>None</code> </p> <code>custom_muaps</code> <p>With this parameter, it is possible to perform MUs tracking on MUAPs computed with custom techniques. If this parameter is None (default), MUs tracking is performed on the MUAPs computed via spike triggered averaging. Otherwise, it is possible to pass a list of 2 dictionaries containing the MUAPs of the MUs from 2 different files. These dictionaries should be structured as the output of the <code>sta</code> function. If custom MUAPs are passed, all the previous parameters (except for <code>emgfile1</code> and <code>emgfile2</code> can be ignored). If custom MUAPs are provided, these are not aligned by the algorithm, contrary to what is done for MUAPs obtained via spike triggered averaging.</p> <p> TYPE: <code>None or list</code> DEFAULT: <code>None</code> </p> <code>exclude_belowthreshold</code> <p>Whether to exclude results with XCC below threshold.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>filter</code> <p>If true, when the same MU has a match of XCC &gt; threshold with multiple MUs, only the match with the highest XCC is returned.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>multiprocessing</code> <p>If True (default) parallel processing will be used to reduce execution time.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>show</code> <p>Whether to plot the STA of pairs of MUs with XCC above threshold. Set to False (default) when gui=True to avoid postponing the GUI execution. If show=True and gui=True, the GUI will be executed after closing all the figures.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>gui</code> <p>If True (default) a GUI for the visual inspection and manual selection of the tracking results will be called.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>gui_addrefsig</code> <p>If True, the REF_SIGNAL is plotted in front of the IDR with a separated y-axes. This is used only when gui=True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>gui_csv_separator</code> <p>The field delimiter used by the GUI to create the .csv copied to the clipboard. This is used only when gui=True.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"  \"</code> </p> RETURNS DESCRIPTION <code>tracking_res</code> <p>The results of the tracking including the MU from file 1, MU from file 2 and the normalised cross-correlation value (XCC). If gui=True, an additional column indicating the inclusion/exclusion of the MUs pairs will also be present in tracking_res.</p> <p> TYPE: <code>DataFrame</code> </p> WARNS DESCRIPTION <code>UserWarning</code> <p>If the number of plots to show exceeds that of available cores.</p> See also <ul> <li>sta : computes the STA of every MUs.</li> <li>norm_twod_xcorr : normalised 2-dimensional cross-correlation of STAs of     two MUs.</li> <li>Tracking_gui : GUI for the visual inspection and manual selection of the tracking results (directly callable from the tracking function).</li> <li>remove_duplicates_between : remove duplicated MUs across two different     files based on STA.</li> </ul> Notes <p>Parallel processing can significantly improve performances compared to serial processing. In this function, parallel processing has been implemented for the tasks involving 2-dimensional cross-correlation.</p> <p>Examples:</p> <p>Track MUs between two OPENHDEMG (.json) files and inspect the results with a convenient GUI.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile1 = emg.askopenfile(filesource=\"OPENHDEMG\")\n&gt;&gt;&gt; emgfile2 = emg.askopenfile(filesource=\"OPENHDEMG\")\n&gt;&gt;&gt; tracking_res = emg.tracking(\n...     emgfile1=emgfile1,\n...     emgfile2=emgfile2,\n...     firings=\"all\",\n...     derivation=\"sd\",\n...     timewindow=50,\n...     threshold=0.8,\n...     matrixcode=\"GR08MM1305\",\n...     orientation=180,\n...     filter=True,\n...     show=False,\n...     gui=True,\n&gt;&gt;&gt; )\n</code></pre> <p>Track MUs between two OTB files and show the filtered results.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile1 = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emgfile2 = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; tracking_res = emg.tracking(\n...     emgfile1=emgfile1,\n...     emgfile2=emgfile2,\n...     firings=\"all\",\n...     derivation=\"sd\",\n...     timewindow=50,\n...     threshold=0.8,\n...     matrixcode=\"GR08MM1305\",\n...     orientation=180,\n...     n_rows=None,\n...     n_cols=None,\n...     exclude_belowthreshold=True,\n...     filter=True,\n...     show=False,\n...     gui=False,\n... )\n    MU_file1  MU_file2       XCC\n0          0         3  0.820068\n1          2         4  0.860272\n2          4         8  0.857346\n3          5         0  0.878373\n4          6         9  0.877321\n5          7         1  0.823371\n6          9        13  0.873388\n7         11         5  0.862537\n8         19        10  0.802635\n9         21        14  0.896419\n10        22        16  0.836356\n</code></pre> <p>Track MUs between two files where channels are sorted with a custom order.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile1 = emg.askopenfile(filesource=\"CUSTOMCSV\")\n&gt;&gt;&gt; emgfile2 = emg.askopenfile(filesource=\"CUSTOMCSV\")\n&gt;&gt;&gt; custom_sorting_order = [\n...     [63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52,     51,],\n...     [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,     50,],\n...     [37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26,     25,],\n...     [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,     24,],\n...     [11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0, np.nan,],\n... ]  # 13 rows and 5 columns\n&gt;&gt;&gt; tracking_res = emg.tracking(\n...     emgfile1=emgfile1,\n...     emgfile2=emgfile2,\n...     firings=\"all\",\n...     derivation=\"sd\",\n...     timewindow=50,\n...     threshold=0.8,\n...     matrixcode=\"Custom order\",\n...     orientation=180,\n...     n_rows=None,\n...     n_cols=None,\n...     custom_sorting_order=custom_sorting_order,\n...     exclude_belowthreshold=True,\n...     filter=True,\n...     show=False,\n...     gui=False,\n... )\n</code></pre>"},{"location":"api_muap/#openhdemg.library.muap.Tracking_gui","title":"<code>Tracking_gui</code>","text":"<p>GUI for the visual inspection and manual selection of the tracking results.</p> PARAMETER DESCRIPTION <code>emgfile1</code> <p>The dictionary containing the first emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>emgfile2</code> <p>The dictionary containing the second emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>tracking_res</code> <p>The results of the tracking including the MU from file 1, MU from file 2 and the normalised cross-correlation value (XCC). This is obtained with the function <code>tracking()</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>sta_emgfile1</code> <p>dict containing a dict of STA (pd.DataFrame) for every MUs from emgfile1. This is obtained with the function <code>sta()</code>.</p> <p> TYPE: <code>dict</code> </p> <code>sta_emgfile2</code> <p>dict containing a dict of STA (pd.DataFrame) for every MUs from emgfile2. This is obtained with the function <code>sta()</code>.</p> <p> TYPE: <code>dict</code> </p> <code>align_muaps</code> <p>Whether to align the MUAPs before plotting. If true, the visualised MUAPs time window will be \u00bd of the original (because the maximum allowed shift during MUAPs alignment is 50%).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addrefsig</code> <p>If True, the REF_SIGNAL is plotted in front of the IDR with a separated y-axes.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>csv_separator</code> <p>The field delimiter used to create the .csv copied to the clipboard.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"      \"</code> </p> METHOD DESCRIPTION <code>get_results</code> <p>Returns the results of the tracking including the MU from file 1, MU from file 2, the normalised cross-correlation value (XCC) and the inclusion or exclusion of the MUs pair. after the GUI is closed.</p> See also <ul> <li>tracking : Track MUs across two files comparing the MUAPs' shape and distribution.</li> </ul> <p>Examples:</p> <p>Track MUs between two files.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile_1 = emg.askopenfile(filesource=\"OPENHDEMG\")\n&gt;&gt;&gt; emgfile_2 = emg.askopenfile(filesource=\"OPENHDEMG\")\n&gt;&gt;&gt; tracking_res = emg.tracking(emgfile_1, emgfile_2, timewindow=50)\n</code></pre> <p>Obtained required variables for Tracking_gui(). Pay attention to use the same derivation specified during tracking and to use an appropriate MUAPs timewindow, according to the align_muaps option in Tracking_gui().</p> <pre><code>&gt;&gt;&gt; sorted_rawemg_1 = emg.sort_rawemg(emgfile_1)\n&gt;&gt;&gt; sorted_rawemg_1 = emg.diff(sorted_rawemg_1)\n&gt;&gt;&gt; sta_dict_1 = emg.sta(emgfile_1, sorted_rawemg_1, timewindow=100)\n&gt;&gt;&gt; sorted_rawemg_2 = emg.sort_rawemg(emgfile_2)\n&gt;&gt;&gt; sorted_rawemg_2 = emg.diff(sorted_rawemg_2)\n&gt;&gt;&gt; sta_dict_2 = emg.sta(emgfile_2, sorted_rawemg_2, timewindow=100)\n</code></pre> <p>Inspect the tracking results with a convenient GUI.</p> <pre><code>&gt;&gt;&gt; tracking = emg.Tracking_gui(\n...     emgfile1=emgfile_1,\n...     emgfile2=emgfile_2,\n...     tracking_res=tracking_res,\n...     sta_emgfile1=sta_dict_1,\n...     sta_emgfile2=sta_dict_2,\n...     align_muaps=True,\n...     addrefsig=True,\n... )\n</code></pre> <p>Return the updated results for further use in the code.</p> <pre><code>&gt;&gt;&gt; updated_results = tracking.get_results()\n    MU_file1  MU_file2       XCC Inclusion\n0          0         2  0.897364  Excluded\n1          1         0  0.947486  Included\n2          2         1  0.923901  Included\n3          4         8  0.893922  Included\n</code></pre>"},{"location":"api_muap/#openhdemg.library.muap.remove_duplicates_between","title":"<code>remove_duplicates_between(emgfile1, emgfile2, firings='all', derivation='sd', timewindow=50, threshold=0.9, matrixcode='GR08MM1305', orientation=180, n_rows=None, n_cols=None, custom_sorting_order=None, custom_muaps=None, filter=True, multiprocessing=True, show=False, gui=True, gui_addrefsig=True, gui_csv_separator='\\t', which='munumber')</code>","text":"<p>Remove duplicated MUs across two different files based on STA.</p> PARAMETER DESCRIPTION <code>emgfile1</code> <p>The dictionary containing the first emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>emgfile2</code> <p>The dictionary containing the second emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>firings</code> <p>The range of firings to be used for the STA. If a MU has less firings than the range, the upper limit is adjusted accordingly.</p> <p><code>all</code>     The STA is calculated over all the firings.</p> <p>A list can be passed as [start, stop] e.g., [0, 25] to compute the STA on the first 25 firings.</p> <p> TYPE: <code>list or str {\"all\"}</code> DEFAULT: <code>\"all\"</code> </p> <code>derivation</code> <p>Whether to compute the sta on the monopolar signal, or on the single or double differential derivation.</p> <p> TYPE: <code>str {mono, sd, dd}</code> DEFAULT: <code>sd</code> </p> <code>timewindow</code> <p>Timewindow to compute STA in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> <code>threshold</code> <p>The 2-dimensional cross-correlation minimum value to consider two MUs to be the same. Ranges 0-1.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.9</code> </p> <code>matrixcode</code> <p>The code of the matrix used. It can be one of:</p> <p><code>GR08MM1305</code></p> <p><code>GR04MM1305</code></p> <p><code>GR10MM0808</code></p> <p><code>Custom order</code></p> <p><code>None</code></p> <p>This is necessary to sort the channels in the correct order. If matrixcode=\"None\", the electrodes are not sorted. In this case, n_rows and n_cols must be specified. If \"Custom order\", the electrodes are sorted based on custom_sorting_order.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"GR08MM1305\"</code> </p> <code>orientation</code> <p>Orientation in degree of the matrix (same as in OTBiolab). E.g. 180 corresponds to the matrix connection toward the user. This Parameter is ignored if code==\"Custom order\" or code==\"None\".</p> <p> TYPE: <code>int {0, 180}</code> DEFAULT: <code>180</code> </p> <code>n_rows</code> <p>The number of rows of the matrix. This parameter is used to divide the channels based on the matrix shape. These are normally inferred by the matrix code and must be specified only if code == None.</p> <p> TYPE: <code>None or int</code> DEFAULT: <code>None</code> </p> <code>n_cols</code> <p>The number of columns of the matrix. This parameter is used to divide the channels based on the matrix shape. These are normally inferred by the matrix code and must be specified only if code == None.</p> <p> TYPE: <code>None or int</code> DEFAULT: <code>None</code> </p> <code>custom_sorting_order</code> <p>If code==\"Custom order\", custom_sorting_order will be used for channels sorting. In this case, custom_sorting_order must be a list of lists containing the order of the matrix channels. Specifically, the number of columns are defined by len(custom_sorting_order) while the number of rows by len(custom_sorting_order[0]). np.nan can be used to specify empty channels. Please refer to the Examples section for the structure of the custom sorting order.</p> <p> TYPE: <code>None or list</code> DEFAULT: <code>None</code> </p> <code>custom_muaps</code> <p>With this parameter, it is possible to perform MUs tracking on MUAPs computed with custom techniques. If this parameter is None (default), MUs tracking is performed on the MUAPs computed via spike triggered averaging. Otherwise, it is possible to pass a list of 2 dictionaries containing the MUAPs of the MUs from 2 different files. These dictionaries should be structured as the output of the <code>sta</code> function. If custom MUAPs are passed, all the previous parameters (except for <code>emgfile1</code> and <code>emgfile2</code> can be ignored). If custom MUAPs are provided, these are not aligned by the algorithm, contrary to what is done for MUAPs obtained via spike triggered averaging.</p> <p> TYPE: <code>None or list</code> DEFAULT: <code>None</code> </p> <code>filter</code> <p>If true, when the same MU has a match of XCC &gt; threshold with multiple MUs, only the match with the highest XCC is returned.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>multiprocessing</code> <p>If True (default) parallel processing will be used to reduce execution time.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>show</code> <p>Whether to plot the STA of pairs of MUs with XCC above threshold.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>gui</code> <p>If True (default) a GUI for the visual inspection and manual selection of the tracking results will be called.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>gui_addrefsig</code> <p>If True, the REF_SIGNAL is plotted in front of the IDR with a separated y-axes. This is used only when gui=True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>gui_csv_separator</code> <p>The field delimiter used by the GUI to create the .csv copied to the clipboard. This is used only when gui=True.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"  \"</code> </p> <code>which</code> <p>How to remove the duplicated MUs.</p> <p><code>munumber</code>     Duplicated MUs are removed from the file with more MUs.</p> <p><code>accuracy</code>     The MU with the lowest accuracy is removed.</p> <p> TYPE: <code>str {\"munumber\", \"accuracy\"}</code> DEFAULT: <code>\"munumber\"</code> </p> RETURNS DESCRIPTION <code>emgfile1, emgfile2 : dict</code> <p>The original emgfiles without the duplicated MUs.</p> <code>tracking_res</code> <p>The results of the tracking including the MU from file 1, MU from file 2 and the normalised cross-correlation value (XCC). If gui=True, an additional column indicating the inclusion/exclusion of the MUs pairs will also be present in tracking_res.</p> <p> TYPE: <code>DataFrame</code> </p> See also <ul> <li>sta : computes the STA of every MUs.</li> <li>norm_twod_xcorr : normalised 2-dimensional cross-correlation of STAs of     two MUs.</li> <li>tracking : track MUs across two different files.</li> </ul> <p>Examples:</p> <p>Remove duplicated MUs between two OPENHDEMG files and inspect the tracking outcome via a convenient GUI. Then Save the emgfiles without duplicates. Of the 2 duplicated MUs, the one with the lowest accuracy is removed.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile1 = emg.askopenfile(filesource=\"OPENHDEMG\")\n&gt;&gt;&gt; emgfile2 = emg.askopenfile(filesource=\"OPENHDEMG\")\n&gt;&gt;&gt; emgfile1, emgfile2, tracking_res = emg.remove_duplicates_between(\n...     emgfile1,\n...     emgfile2,\n...     firings=\"all\",\n...     derivation=\"mono\",\n...     timewindow=50,\n...     threshold=0.9,\n...     matrixcode=\"GR08MM1305\",\n...     orientation=180,\n...     gui=True,\n...     which=\"accuracy\",\n... )\n&gt;&gt;&gt; emg.asksavefile(emgfile1)\n&gt;&gt;&gt; emg.asksavefile(emgfile2)\n</code></pre> <p>Remove duplicated MUs between two OTB files and directly save the emgfiles without duplicates. The duplicates are removed from the file with more MUs.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile1 = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emgfile2 = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emgfile1, emgfile2, tracking_res = emg.remove_duplicates_between(\n...     emgfile1,\n...     emgfile2,\n...     firings=\"all\",\n...     derivation=\"mono\",\n...     timewindow=50,\n...     threshold=0.9,\n...     matrixcode=\"GR08MM1305\",\n...     orientation=180,\n...     n_rows=None,\n...     n_cols=None,\n...     filter=True,\n...     show=False,\n...     gui=False,\n...     which=\"munumber\",\n... )\n&gt;&gt;&gt; emg.asksavefile(emgfile1)\n&gt;&gt;&gt; emg.asksavefile(emgfile2)\n</code></pre> <p>Remove duplicated MUs between two files where channels are sorted with a custom order and directly save the emgfiles without duplicates. Of the 2 duplicated MUs, the one with the lowest accuracy is removed.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; emgfile1 = emg.askopenfile(filesource=\"CUSTOMCSV\")\n&gt;&gt;&gt; emgfile2 = emg.askopenfile(filesource=\"CUSTOMCSV\")\n&gt;&gt;&gt; custom_sorting_order = [\n...     [63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52,     51,],\n...     [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,     50,],\n...     [37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26,     25,],\n...     [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,     24,],\n...     [11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0, np.nan,],\n... ]  # 13 rows and 5 columns\n&gt;&gt;&gt; emgfile1, emgfile2, tracking_res = emg.remove_duplicates_between(\n...     emgfile1,\n...     emgfile2,\n...     firings=\"all\",\n...     derivation=\"sd\",\n...     timewindow=50,\n...     threshold=0.9,\n...     matrixcode=\"Custom order\",\n...     orientation=180,\n...     n_rows=None,\n...     n_cols=None,\n...     custom_sorting_order=custom_sorting_order,\n...     filter=True,\n...     show=False,\n...     gui=False,\n...     which=\"accuracy\",\n... )\n&gt;&gt;&gt; emg.asksavefile(emgfile1)\n&gt;&gt;&gt; emg.asksavefile(emgfile2)\n</code></pre>"},{"location":"api_muap/#openhdemg.library.muap.xcc_sta","title":"<code>xcc_sta(sta)</code>","text":"<p>Cross-correlation between the STA of adjacent channels.</p> <p>Calculate the normalised cross-correlation coefficient (XCC) between the MUs action potential shapes on adjacent channels. The XCC will be calculated for all the MUs and all the pairs of electrodes.</p> PARAMETER DESCRIPTION <code>sta</code> <p>The dict containing the spike-triggered average (STA) of all the MUs computed with the function sta().</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>xcc_sta</code> <p>A dict containing the XCC for all the pairs of channels and all the MUs. This dict is organised as the sta dict.</p> <p> TYPE: <code>dict</code> </p> <p>Examples:</p> <p>Calculate the XCC of adjacent channels of the double differential derivation as done to calculate MUs conduction velocity.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True\n... )\n&gt;&gt;&gt; dd = emg.double_diff(sorted_rawemg)\n&gt;&gt;&gt; sta = emg.sta(\n...     emgfile=emgfile,\n...     sorted_rawemg=dd,\n...     firings=[0, 50],\n...     timewindow=50,\n... )\n&gt;&gt;&gt; xcc_sta = emg.xcc_sta(sta)\n</code></pre>"},{"location":"api_muap/#openhdemg.library.muap.estimate_cv_via_mle","title":"<code>estimate_cv_via_mle(emgfile, signal)</code>","text":"<p>Estimate signal conduction velocity via maximum likelihood estimation.</p> <p>This function can be used for the estimation of conduction velocity for 2 or more signals. These can be either MUAPs or global EMG signals.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile from whic \"signal\" has been extracted. This is used to know IED and FSAMP.</p> <p> TYPE: <code>dict</code> </p> <code>signal</code> <p>A dataframe containing the signals on which to estimate CV. The signals should be organised in colums.</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <code>cv</code> <p>The conduction velocity value in M/s.</p> <p> TYPE: <code>float</code> </p> See also <ul> <li>MUcv_gui : Graphical user interface for the estimation of MUs conduction     velocity.</li> </ul> <p>Examples:</p> <p>Calculate the CV for the first MU (number 0) on the channels 31, 32, 34, 34 that are contained in the second column (\"col2\") of the double differential representation of the MUAPs. First, obtain the spike- triggered average of the double differential derivation.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emgfile = emg.filter_rawemg(emgfile)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True\n... )\n&gt;&gt;&gt; dd = emg.double_diff(sorted_rawemg=sorted_rawemg)\n&gt;&gt;&gt; sta = emg.sta(\n...     emgfile=emgfile,\n...     sorted_rawemg=sorted_rawemg,\n...     firings=[0,50],\n...     timewindow=50,\n... )\n</code></pre> <p>Second, extract the channels of interest and estimate CV.</p> <pre><code>&gt;&gt;&gt; signal = sta[0][\"col2\"].loc[:, 31:34]\n&gt;&gt;&gt; cv = estimate_cv_via_mle(emgfile=emgfile, signal=signal)\n</code></pre>"},{"location":"api_muap/#openhdemg.library.muap.MUcv_gui","title":"<code>MUcv_gui(emgfile, sorted_rawemg, n_firings=[0, 50], muaps_timewindow=50, figsize=[25, 20], csv_separator='\\t')</code>","text":"<p>Graphical user interface for the estimation of MUs conduction velocity.</p> <p>GUI for the estimation of MUs conduction velocity (CV) and amplitude of the action potentials (root mean square - RMS).</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>sorted_rawemg</code> <p>A dict containing the sorted electrodes. Every key of the dictionary represents a different column of the matrix. Rows are stored in the dict as a pd.DataFrame.</p> <p> TYPE: <code>dict</code> </p> <code>n_firings</code> <p>The range of firings to be used for the STA. If a MU has less firings than the range, the upper limit is adjusted accordingly.</p> <p><code>all</code>     The STA is calculated over all the firings.</p> <p> TYPE: <code>list or str {\"all\"}</code> DEFAULT: <code>[0, 50]</code> </p> <code>muaps_timewindow</code> <p>Timewindow to compute ST MUAPs in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> <code>figsize</code> <p>Size of the initial MUAPs figure in centimeters [width, height].</p> <p> TYPE: <code>list</code> DEFAULT: <code>[20, 15]</code> </p> <code>csv_separator</code> <p>The field delimiter used to create the .csv copied to the clipboard.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"      \"</code> </p> See also <ul> <li>estimate_cv_via_mle : Estimate signal conduction velocity via maximum     likelihood estimation.</li> </ul> <p>Examples:</p> <p>Call the GUI.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emgfile = emg.filter_rawemg(emgfile)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True\n... )\n&gt;&gt;&gt; gui = emg.MUcv_gui(\n...     emgfile=emgfile,\n...     sorted_rawemg=sorted_rawemg,\n...     n_firings=[0,50],\n...     muaps_timewindow=50\n... )\n</code></pre>"},{"location":"api_openfiles/","title":"openfiles","text":""},{"location":"api_openfiles/#description","title":"Description","text":"<p>This module contains all the functions that are necessary to open or save MATLAB (.mat), text (.txt), JSON (.json) or custom (.csv) files. MATLAB files are used to store data from the DEMUSE, OTBiolab+ and Delsys software while JSON files are used to save and load files from this library. The choice of saving files in the open standard JSON file format was preferred over the MATLAB file format since it has a better integration with Python and has a very high cross-platform compatibility.</p>"},{"location":"api_openfiles/#functions-scope","title":"Function's scope","text":"<ul> <li>emg_from_samplefile:     Used to load the sample file provided with the library.</li> <li>emg_from_otb and emg_from_demuse:     Used to load .mat files coming from the DEMUSE or the OTBiolab+ software. Demuse has a fixed file structure while the OTB file, in order to be compatible with this library should be exported with a strict structure as described in the function emg_from_otb. In both cases, the input file is a .mat file.</li> <li>emg_from_delsys:     Used to load a combination of .mat and .txt files exported by the Delsys Neuromap and Neuromap explorer software containing the raw EMG signal and the decomposition outcome.</li> <li>emg_from_customcsv:     Used to load custom file formats contained in .csv files.</li> <li>refsig_from_otb, refsig_from_delsys and refsig_from_customcsv:     Used to load files from the OTBiolab+ (.mat) and the Delsys Neuromap software (.mat) or from a custom .csv file that contain only the reference signal.</li> <li>save_json_emgfile, emg_from_json:     Used to save the working file to a .json file or to load the .json file.</li> <li>askopenfile, asksavefile:     A quick GUI implementation that allows users to select the file to open or save.</li> </ul>"},{"location":"api_openfiles/#notes","title":"Notes","text":"<p>Once opened, the file is returned as a dictionary with key-value pairs:</p> <p>\"SOURCE\" : source of the file (i.e., \"CUSTOMCSV\", \"DEMUSE\", \"OTB\", \"DELSYS\") \"FILENAME\" : the name of the opened file \"RAW_SIGNAL\" : the raw EMG signal \"REF_SIGNAL\" : the reference signal \"ACCURACY\" : accuracy score (depending on source file type) \"IPTS\" : pulse train (decomposed source, depending on source file type) \"MUPULSES\" : instants of firing \"FSAMP\" : sampling frequency \"IED\" : interelectrode distance \"EMG_LENGTH\" : length of the emg file (in samples) \"NUMBER_OF_MUS\" : total number of MUs \"BINARY_MUS_FIRING\" : binary representation of MUs firings \"EXTRAS\" : additional custom values</p> <p>The only exception is when files are loaded with just the reference signal:</p> <p>\"SOURCE\" : source of the file (i.e., \"CUSTOMCSV_REFSIG\", \"OTB_REFSIG\", \"DELSYS_REFSIG\") \"FILENAME\" : the name of the opened file \"FSAMP\" : sampling frequency \"REF_SIGNAL\" : the reference signal \"EXTRAS\" : additional custom values</p> <p>Additional informations can be found in the info module and in the function's description.</p> <p>Furthermore, all the users are encouraged to read the dedicated tutorial Structure of the emgfile.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"api_openfiles/#openhdemg.library.openfiles.emg_from_samplefile","title":"<code>emg_from_samplefile()</code>","text":"<p>Load the sample file. This file has been decomposed with the OTBiolab+ software and contains some reference MUs together with the force/reference signal.</p> <p>This file contains only few MUs for storage reasons.</p> RETURNS DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p>"},{"location":"api_openfiles/#openhdemg.library.openfiles.emg_from_otb","title":"<code>emg_from_otb(filepath, ext_factor=8, refsig=[True, 'fullsampled'], version='1.5.9.3', extras=None, ignore_negative_ipts=False)</code>","text":"<p>Import the .mat file exportable from OTBiolab+.</p> <p>This function is used to import the .mat file exportable by the OTBiolab+ software as a dictionary of Python objects (mainly pandas dataframes).</p> PARAMETER DESCRIPTION <code>filepath</code> <p>The directory and the name of the file to load (including file extension .mat). This can be a simple string, the use of Path is not necessary.</p> <p> TYPE: <code>str or Path</code> </p> <code>ext_factor</code> <p>The extension factor used for the decomposition in OTbiolab+.</p> <p> TYPE: <code>int</code> DEFAULT: <code>8</code> </p> <code>refsig</code> <p>Whether to seacrh also for the REF_SIGNAL and whether to load the full or sub-sampled one. The list is composed as [bool, str]. str can be \"fullsampled\" or \"subsampled\". Please read notes section.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[True, \"fullsampled\"]</code> </p> <code>version</code> <p>Version of the OTBiolab+ software used (4 points). Tested versions are:     \"1.5.3.0\",     \"1.5.4.0\",     \"1.5.5.0\",     \"1.5.6.0\",     \"1.5.7.2\",     \"1.5.7.3\",     \"1.5.8.0\",     \"1.5.9.3\", If your specific version is not available in the tested versions, trying with the closer one usually works.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"1.5.9.3\"</code> </p> <code>extras</code> <p>Extras is used to store additional custom values. These information will be stored in a pd.DataFrame with columns named as in the .mat file. If not None, pass a regex pattern unequivocally identifying the variable in the .mat file to load as extras.</p> <p> TYPE: <code>None or str</code> DEFAULT: <code>None</code> </p> <code>ignore_negative_ipts</code> <p>This parameter determines the silhouette score estimation. If True, only positive ipts values are used during peak and noise clustering. This is particularly important for compensating sources with large negative components.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>emgfile</code> <p>A dictionary containing all the useful variables.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>refsig_from_otb : import REF_SIGNAL in the .mat file exportable from     OTBiolab+.</li> <li>emg_from_demuse : import the .mat file used in DEMUSE.</li> <li>emg_from_customcsv : Import custom data from a .csv file.</li> <li>askopenfile : Select and open files with a GUI.</li> </ul> RAISES DESCRIPTION <code>ValueError</code> <p>When a wrong value is passed to version=.</p> Notes <p>The returned file is called <code>emgfile</code> for convention.</p> <p>The input .mat file exported from the OTBiolab+ software must have a specific content:</p> <ul> <li>The reference signal is optional but, if present, there should be the     fullsampled or the subsampled version (in OTBioLab+ the \"performed     path\" refers to the subsampled signal, the \"acquired data\" to the     fullsampled signal), REF_SIGNAL is expected to be expressed as % of     the MVC (but not compulsory).</li> <li>Both the IPTS ('Source for decomposition...' in OTBioLab+) and the     BINARY_MUS_FIRING ('Decomposition of...' in OTBioLab+) must be     present.</li> <li>The raw EMG signal must be present (it has no specific name in     OTBioLab+) with all the channels. Don't exclude unwanted channels     before exporting the .mat file.</li> <li>NO OTHER ELEMENTS SHOULD BE PRESENT, unless an appropriate regex pattern is passed to 'extras='!</li> </ul> <p>Structure of the returned emgfile:</p> <pre><code>emgfile = {\n    \"SOURCE\": SOURCE,\n    \"FILENAME\": FILENAME,\n    \"RAW_SIGNAL\": RAW_SIGNAL,\n    \"REF_SIGNAL\": REF_SIGNAL,\n    \"ACCURACY\": SIL,\n    \"IPTS\": IPTS,\n    \"MUPULSES\": MUPULSES,\n    \"FSAMP\": FSAMP,\n    \"IED\": IED,\n    \"EMG_LENGTH\": EMG_LENGTH,\n    \"NUMBER_OF_MUS\": NUMBER_OF_MUS,\n    \"BINARY_MUS_FIRING\": BINARY_MUS_FIRING,\n    \"EXTRAS\": EXTRAS,\n}\n</code></pre> <p>For OTBiolab+ files, the accuracy is estimated with the silhouette (SIL) score.</p> <p>Examples:</p> <p>For an extended explanation of the imported emgfile use:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.emg_from_otb(filepath=\"path/filename.mat\")\n&gt;&gt;&gt; info = emg.info()\n&gt;&gt;&gt; info.data(emgfile)\n</code></pre>"},{"location":"api_openfiles/#openhdemg.library.openfiles.emg_from_demuse","title":"<code>emg_from_demuse(filepath, ignore_negative_ipts=False)</code>","text":"<p>Import the .mat file decomposed in DEMUSE.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>The directory and the name of the file to load (including file extension .mat). This can be a simple string, the use of Path is not necessary.</p> <p> TYPE: <code>str or Path</code> </p> <code>ignore_negative_ipts</code> <p>This parameter determines the silhouette score estimation. If True, only positive ipts values are used during peak and noise clustering. This is particularly important for compensating sources with large negative components.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>emgfile</code> <p>A dictionary containing all the useful variables.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>emg_from_otb : import the decomposed .mat file exportable by OTBiolab+.</li> <li>refsig_from_otb : import REF_SIGNAL in the .mat file exportable by     OTBiolab+.</li> <li>emg_from_customcsv : Import custom data from a .csv file.</li> <li>askopenfile : Select and open files with a GUI.</li> </ul> Notes <p>The returned file is called <code>emgfile</code> for convention.</p> <p>The demuse file contains 65 raw EMG channels (1 empty) instead of 64 (as for OTB matrix standards) in the case of a 64 electrodes matrix.</p> <p>Structure of the emgfile:</p> <pre><code>emgfile = {\n    \"SOURCE\": SOURCE,\n    \"FILENAME\": FILENAME,\n    \"RAW_SIGNAL\": RAW_SIGNAL,\n    \"REF_SIGNAL\": REF_SIGNAL,\n    \"ACCURACY\": SIL\n    \"IPTS\": IPTS,\n    \"MUPULSES\": MUPULSES,\n    \"FSAMP\": FSAMP,\n    \"IED\": IED,\n    \"EMG_LENGTH\": EMG_LENGTH,\n    \"NUMBER_OF_MUS\": NUMBER_OF_MUS,\n    \"BINARY_MUS_FIRING\": BINARY_MUS_FIRING,\n    \"EXTRAS\": EXTRAS,\n}\n</code></pre> <p>For DEMUSE files, the accuracy is estimated with the silhouette (SIL) score.</p> <p>Examples:</p> <p>For an extended explanation of the imported emgfile:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.emg_from_demuse(filepath=\"path/filename.mat\")\n&gt;&gt;&gt; info = emg.info()\n&gt;&gt;&gt; info.data(emgfile)\n</code></pre>"},{"location":"api_openfiles/#openhdemg.library.openfiles.emg_from_delsys","title":"<code>emg_from_delsys(rawemg_filepath, mus_directory, emg_sensor_name='Galileo sensor', refsig_sensor_name='Trigno Load Cell', filename_from='mus_directory')</code>","text":"<p>Import the .mat and .txt files exportable from Delsys softwares.</p> <p>This function is used to load .mat files from the Delsys Neuromap software (containing the RAW EMG signal and the reference signal) and .txt files from the Delsys Neuromap Explorer software (containing the decomposition outcome, accuracy measure and MUAPs).</p> <p>We currenlty support only recordings performed with the \"Galileo sensor\" (4-pin). Support for the 5-pin sensor will be provided in the next releases.</p> PARAMETER DESCRIPTION <code>rawemg_filepath</code> <p>The directory and the name of the file containing the raw EMG data to load (including file extension .mat). This can be a simple string, the use of Path is not necessary.</p> <p> TYPE: <code>str or Path</code> </p> <code>mus_directory</code> <p>The directory (path to the folder) containing .txt files with firing times, MUAPs, and accuracy data. This can be a simple string, the use of Path is not necessary. The .txt files should all be contained in the same folder and should follow the standard Deslys naming convention (e.g., the file containing accuracy data will have the string \"Stats\" in its name).</p> <p> TYPE: <code>str or Path</code> </p> <code>emg_sensor_name</code> <p>The name of the EMG sensor used to collect the data. We currently support only the \"Galileo sensor\" (4-pin).</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"Galileo sensor\"</code> </p> <code>refsig_sensor_name</code> <p>The name of the sensor used to record the reference signal. This is by default \"Trigno Load Cell\". However, since this can have any name (and can also be renamed by the user), here you should pass the effective name (or regex pattern) by which you identify the sensor. Ignore if no reference signal was recorded.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"Trigno Load Cell\"</code> </p> <code>filename_from</code> <p>The source by which the imported file will be named. This can either be the same name of the file containing the raw EMG signal or of the folder containing the decomposition outcome.</p> <p> TYPE: <code>str {\"rawemg_file\", \"mus_directory\"}</code> DEFAULT: <code>\"mus_directory\"</code> </p> RETURNS DESCRIPTION <code>emgfile</code> <p>A dictionary containing all the useful variables.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>refsig_from_delsys : Import the reference signal exportable from Delsys.</li> <li>askopenfile : Select and open files with a GUI.</li> </ul> Notes <p>The returned file is called <code>emgfile</code> for convention.</p> <p>Structure of the returned emgfile:</p> <pre><code>emgfile = {\n    \"SOURCE\": SOURCE,\n    \"FILENAME\": FILENAME,\n    \"RAW_SIGNAL\": RAW_SIGNAL,\n    \"REF_SIGNAL\": REF_SIGNAL,\n    \"ACCURACY\": PROPRIETARY ACCURACY MEASURE,\n    \"IPTS\": IPTS,\n    \"MUPULSES\": MUPULSES,\n    \"FSAMP\": FSAMP,\n    \"IED\": IED,\n    \"EMG_LENGTH\": EMG_LENGTH,\n    \"NUMBER_OF_MUS\": NUMBER_OF_MUS,\n    \"BINARY_MUS_FIRING\": BINARY_MUS_FIRING,\n    \"EXTRAS\": EXTRAS,\n}\n</code></pre> <p>For Delsys files, the accuracy is the one provided after the decomposition and it is not computed internally, being this a proprietary measure.</p> <p>We collect the raw EMG and the reference signal from the .mat file because the .csv doesn't contain the information about sampling frequency. Similarly, we collect the firing times, MUAPs and accuracy from the .txt files because in the .mat file, the accuracy is contained in a table, which is not compatible with Python.</p> <p>Examples:</p> <p>For an extended explanation of the imported emgfile use:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.emg_from_delsys(\n...     rawemg_filepath=\"path/filename.mat\",\n...     mus_directory=\"/directory\",\n... )\n&gt;&gt;&gt; info = emg.info()\n&gt;&gt;&gt; info.data(emgfile)\n</code></pre>"},{"location":"api_openfiles/#openhdemg.library.openfiles.emg_from_customcsv","title":"<code>emg_from_customcsv(filepath, ref_signal='REF_SIGNAL', raw_signal='RAW_SIGNAL', ipts='IPTS', mupulses='MUPULSES', binary_mus_firing='BINARY_MUS_FIRING', accuracy='ACCURACY', extras='EXTRAS', fsamp=2048, ied=8)</code>","text":"<p>Import the emgfile from a custom .csv file.</p> <p>The variables of interest should be contained in columns. The name of the columns containing each variable can be specified by the user if different from the default values.</p> <p>This function detects the content of the .csv by parsing the .csv columns. For parsing, column labels should be provided. A label is a term common to all the columns containing the same information. For example, if the raw signal is contained in the columns 'RAW_SIGNAL_1', 'RAW_SIGNAL_2', ... , 'RAW_SIGNAL_n', the label of the columns should be 'RAW_SIGNAL'. If the parameters in input are not present in the .csv file, the user should leave the original inputs.</p> <p>The .csv file must contain at least the raw_signal and one of 'mupulses' or 'binary_mus_firing'. If 'mupulses' is absent, it will be calculated from 'binary_mus_firing' and viceversa.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>The directory and the name of the file to load (including file extension .mat). This can be a simple string, the use of Path is not necessary.</p> <p> TYPE: <code>str or Path</code> </p> <code>ref_signal</code> <p>Label of the column containing the reference signal.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'REF_SIGNAL'</code> </p> <code>raw_signal</code> <p>Label of the column(s) containing the raw emg signal.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'RAW_SIGNAL'</code> </p> <code>ipts</code> <p>Label of the column(s) containing the pulse train (decomposed source).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'IPTS'</code> </p> <code>mupulses</code> <p>Label of the column(s) containing the times of firing.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'MUPULSES'</code> </p> <code>binary_mus_firing</code> <p>Label of the column(s) containing the binary representation of the MUs firings.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'BINARY_MUS_FIRING'</code> </p> <code>accuracy</code> <p>Label of the column(s) containing the accuracy score of the MUs firings.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'ACCURACY'</code> </p> <code>extras</code> <p>Label of the column(s) containing custom values. This information will be stored in a pd.DataFrame with columns named as in the .csv file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'EXTRAS'</code> </p> <code>fsamp</code> <p>Tha sampling frequency.</p> <p> TYPE: <code>int or float</code> DEFAULT: <code>2048</code> </p> <code>ied</code> <p>The inter-electrode distance in mm.</p> <p> TYPE: <code>int or float</code> DEFAULT: <code>8</code> </p> RETURNS DESCRIPTION <code>emgfile</code> <p>A dictionary containing all the useful variables.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>emg_from_demuse : import the .mat file used in DEMUSE.</li> <li>emg_from_otb : import the .mat file exportable by OTBiolab+.</li> <li>refsig_from_otb : import reference signal in the .mat file exportable by     OTBiolab+.</li> <li>refsig_from_customcsv : Import the reference signal from a custom .csv.</li> <li>askopenfile : Select and open files with a GUI.</li> </ul> Notes <p>The returned file is called <code>emgfile</code> for convention.</p> <p>Structure of the emgfile:</p> <pre><code>emgfile = {\n    \"SOURCE\": SOURCE,\n    \"FILENAME\": FILENAME,\n    \"RAW_SIGNAL\": RAW_SIGNAL,\n    \"REF_SIGNAL\": REF_SIGNAL,\n    \"ACCURACY\": ACCURACY,\n    \"IPTS\": IPTS,\n    \"MUPULSES\": MUPULSES,\n    \"FSAMP\": FSAMP,\n    \"IED\": IED,\n    \"EMG_LENGTH\": EMG_LENGTH,\n    \"NUMBER_OF_MUS\": NUMBER_OF_MUS,\n    \"BINARY_MUS_FIRING\": BINARY_MUS_FIRING,\n    \"EXTRAS\": EXTRAS,\n}\n</code></pre> <p>Examples:</p> <p>An example of the .csv file to load:</p> <pre><code>&gt;&gt;&gt;\nREF_SIGNAL  RAW_SIGNAL (1)  RAW_SIGNAL (2)  RAW_SIGNAL (3)  RAW_SIGNAL (4)  ...  MUPULSES (2)  BINARY_MUS_FIRING (1)  BINARY_MUS_FIRING (2)  ACCURACY (1)  ACCURACY (2)\n         1        0.100000        0.100000        0.100000        0.100000  ...           1.0                      0                      0          0.89          0.95\n         2        2.000000        2.000000        2.000000        2.000000  ...           2.0                      0                      0                                  \n         3        0.500000        0.500000        0.500000        0.500000  ...           9.0                      0                      0                                  \n         4        0.150000        0.150000        0.150000        0.150000  ...          15.0                      0                      1                                  \n         5        0.350000        0.350000        0.350000        0.350000  ...          18.0                      1                      1                                  \n         6        0.215000        0.215000        0.215000        0.215000  ...          22.0                      1                      0                            \n</code></pre> <p>For an extended explanation of the imported emgfile use:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg_from_customcsv(filepath = \"mypath/file.csv\")\n&gt;&gt;&gt; info = emg.info()\n&gt;&gt;&gt; info.data(emgfile)\n</code></pre>"},{"location":"api_openfiles/#openhdemg.library.openfiles.refsig_from_otb","title":"<code>refsig_from_otb(filepath, refsig='fullsampled', version='1.5.9.3', extras=None)</code>","text":"<p>Import the reference signal in the .mat file exportable by OTBiolab+.</p> <p>This function is used to import the .mat file exportable by the OTBiolab+ software as a dictionary of Python objects (mainly pandas dataframes). Compared to the function emg_from_otb, this function only imports the REF_SIGNAL and, therefore, it can be used for special cases where only the REF_SIGNAL is necessary. This will allow for a faster execution of the script and to avoid exceptions for missing data.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>The directory and the name of the file to load (including file extension .mat). This can be a simple string, the use of Path is not necessary.</p> <p> TYPE: <code>str or Path</code> </p> <code>refsig</code> <p>Whether to load the full or sub-sampled one. Please read notes section.</p> <p> TYPE: <code>str {\"fullsampled\", \"subsampled\"}</code> DEFAULT: <code>\"fullsampled\"</code> </p> <code>version</code> <p>Version of the OTBiolab+ software used (4 points). Tested versions are:     \"1.5.3.0\",     \"1.5.4.0\",     \"1.5.5.0\",     \"1.5.6.0\",     \"1.5.7.2\",     \"1.5.7.3\",     \"1.5.8.0\",     \"1.5.9.3\", If your specific version is not available in the tested versions, trying with the closer one usually works, but please double check the results.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"1.5.9.3\"</code> </p> <code>extras</code> <p>Extras is used to store additional custom values. These information will be stored in a pd.DataFrame with columns named as in the .mat file. If not None, pass a regex pattern unequivocally identifying the variable in the .mat file to load as extras.</p> <p> TYPE: <code>None or str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>emg_refsig</code> <p>A dictionary containing all the useful variables.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>emg_from_otb : import the .mat file exportable by OTBiolab+.</li> <li>emg_from_demuse : import the .mat file used in DEMUSE.</li> <li>emg_from_customcsv : Import custom data from a .csv file.</li> <li>refsig_from_customcsv : Import the reference signal from a custom .csv.</li> <li>askopenfile : Select and open files with a GUI.</li> </ul> Notes <p>The returned file is called <code>emg_refsig</code> for convention.</p> <p>The input .mat file exported from the OTBiolab+ software must contain:</p> <ul> <li>Reference signal: there must be the fullsampled or the subsampled     version (in OTBioLab+ the \"performed path\" refers to the subsampled     signal, the \"acquired data\" to the fullsampled signal), REF_SIGNAL is     expected to be expressed as % of the MVC (but not compulsory).</li> <li>NO OTHER ELEMENTS SHOULD BE PRESENT, unless an appropriate regex pattern is passed to 'extras='!</li> </ul> <p>Structure of the returned emg_refsig:</p> <pre><code>emg_refsig = {\n    \"SOURCE\": SOURCE,\n    \"FILENAME\": FILENAME,\n    \"FSAMP\": FSAMP,\n    \"REF_SIGNAL\": REF_SIGNAL,\n    \"EXTRAS\": EXTRAS,\n}\n</code></pre> <p>Examples:</p> <p>For an extended explanation of the imported emgfile use:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.refsig_from_otb(filepath=\"path/filename.mat\")\n&gt;&gt;&gt; info = emg.info()\n&gt;&gt;&gt; info.data(emgfile)\n</code></pre>"},{"location":"api_openfiles/#openhdemg.library.openfiles.refsig_from_delsys","title":"<code>refsig_from_delsys(filepath, refsig_sensor_name='Trigno Load Cell')</code>","text":"<p>Import the reference signal in the .mat file exportable by Delsys Neuromap.</p> <p>This function is used to import the .mat file exportable by the Delsys Neuromap software as a dictionary of Python objects (mainly pandas dataframes). Compared to the function emg_from_delsys, this function only imports the REF_SIGNAL and, therefore, it can be used for special cases where only the REF_SIGNAL is necessary. This will allow for a faster execution of the script and to avoid exceptions for missing data.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>The directory and the name of the file to load (including file extension .mat). This can be a simple string, the use of Path is not necessary.</p> <p> TYPE: <code>str or Path</code> </p> <code>refsig_sensor_name</code> <p>The name of the sensor used to record the reference signal. This is by default \"Trigno Load Cell\". However, since this can have any name (and can also be renamed by the user), here you should pass the effective name (or regex pattern) by which you identify the sensor.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"Trigno Load Cell\"</code> </p> RETURNS DESCRIPTION <code>emg_refsig</code> <p>A dictionary containing all the useful variables.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>emg_from_delsys : Import the Delsys decomposition outcome.</li> <li>askopenfile : Select and open files with a GUI.</li> </ul> Notes <p>The returned file is called <code>emg_refsig</code> for convention.</p> <p>Structure of the returned emg_refsig:</p> <pre><code>emg_refsig = {\n    \"SOURCE\": SOURCE,\n    \"FILENAME\": FILENAME,\n    \"FSAMP\": FSAMP,\n    \"REF_SIGNAL\": REF_SIGNAL,\n    \"EXTRAS\": EXTRAS,\n}\n</code></pre> <p>Examples:</p> <p>For an extended explanation of the imported emgfile use:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.refsig_from_delsys(filepath=\"path/filename.mat\")\n&gt;&gt;&gt; info = emg.info()\n&gt;&gt;&gt; info.data(emgfile)\n</code></pre>"},{"location":"api_openfiles/#openhdemg.library.openfiles.refsig_from_customcsv","title":"<code>refsig_from_customcsv(filepath, ref_signal='REF_SIGNAL', extras='EXTRAS', fsamp=2048)</code>","text":"<p>Import the reference signal from a custom .csv file.</p> <p>Compared to the function emg_from_customcsv, this function only imports the REF_SIGNAL and, therefore, it can be used for special cases where only the REF_SIGNAL is necessary. This will allow for a faster execution of the script and to avoid exceptions for missing data.</p> <p>This function detects the content of the .csv by parsing the .csv columns. For parsing, column labels should be provided. A label is a term common to all the columns containing the same information. For example, if the ref signal is contained in the column 'REF_SIGNAL', the label of the columns should be 'REF_SIGNAL' or a part of it (e.g., 'REF'). If the parameters in input are not present in the .csv file (e.g., 'EXTRAS'), the user should leave the original inputs.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>The directory and the name of the file to load (including file extension .mat). This can be a simple string, the use of Path is not necessary.</p> <p> TYPE: <code>str or Path</code> </p> <code>ref_signal</code> <p>Label of the column containing the reference signal.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'REF_SIGNAL'</code> </p> <code>extras</code> <p>Label of the column(s) containing custom values. These information will be stored in a pd.DataFrame with columns named as in the .csv file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'EXTRAS'</code> </p> <code>fsamp</code> <p>Tha sampling frequency.</p> <p> TYPE: <code>int or float</code> DEFAULT: <code>2048</code> </p> RETURNS DESCRIPTION <code>emg_refsig</code> <p>A dictionary containing all the useful variables.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>emg_from_customcsv : Import the emgfile from a custom .csv file.</li> <li>askopenfile : Select and open files with a GUI.</li> </ul> Notes <p>The returned file is called <code>emg_refsig</code> for convention.</p> <p>Structure of the returned emg_refsig:</p> <pre><code>emg_refsig = {\n    \"SOURCE\": SOURCE,\n    \"FILENAME\": FILENAME,\n    \"FSAMP\": FSAMP,\n    \"REF_SIGNAL\": REF_SIGNAL,\n    \"EXTRAS\": EXTRAS,\n}\n</code></pre> <p>Examples:</p> <p>An example of the .csv file to load:</p> <pre><code>&gt;&gt;&gt;\nREF_SIGNAL  EXTRAS (1)  EXTRAS (2)\n         1         0.1           0\n         2         0.2           0\n         3         0.3           0\n         4         0.4           0\n         5         0.5           1\n         6         0.6           1\n</code></pre> <p>For an extended explanation of the imported emgfile use:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = refsig_from_customcsv(filepath = \"mypath/file.csv\")\n&gt;&gt;&gt; info = emg.info()\n&gt;&gt;&gt; info.data(emgfile)\n</code></pre>"},{"location":"api_openfiles/#openhdemg.library.openfiles.save_json_emgfile","title":"<code>save_json_emgfile(emgfile, filepath, compresslevel=4)</code>","text":"<p>Save the emgfile or emg_refsig as a JSON file.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>filepath</code> <p>The directory and the name of the file to save (including file extension .json). This can be a simple string; The use of Path is not necessary.</p> <p> TYPE: <code>str or Path</code> </p> <code>compresslevel</code> <p>An int from 0 to 9, where 0 is no compression and nine maximum compression. Compressed files will take less space, but will require more computation. The relationship between compression level and time required for the compression is not linear. For optimised performance, we suggest values between 2 and 6, with 4 providing the best balance.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p>"},{"location":"api_openfiles/#openhdemg.library.openfiles.emg_from_json","title":"<code>emg_from_json(filepath)</code>","text":"<p>Load the emgfile or emg_refsig stored in json format.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>The directory and the name of the file to load (including file extension .json). This can be a simple string, the use of Path is not necessary.</p> <p> TYPE: <code>str or Path</code> </p> RETURNS DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>save_json_emgfile : Save the emgfile or emg_refsig as a JSON file.</li> <li>askopenfile : Select and open files with a GUI.</li> </ul> Notes <p>The returned file is called <code>emgfile</code> for convention (or <code>emg_refsig</code> if SOURCE in [\"OTB_REFSIG\", \"CUSTOMCSV_REFSIG\", \"DELSYS_REFSIG\"]).</p> <p>Examples:</p> <p>For an extended explanation of the imported emgfile use:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.emg_from_json(filepath=\"path/filename.json\")\n&gt;&gt;&gt; info = emg.info()\n&gt;&gt;&gt; info.data(emgfile)\n</code></pre>"},{"location":"api_openfiles/#openhdemg.library.openfiles.askopenfile","title":"<code>askopenfile(initialdir='/', filesource='OPENHDEMG', **kwargs)</code>","text":"<p>Select and open files with a GUI.</p> PARAMETER DESCRIPTION <code>initialdir</code> <p>The directory of the file to load (excluding file name). This can be a simple string, the use of Path is not necessary.</p> <p> TYPE: <code>str or Path</code> DEFAULT: <code>\"/\"</code> </p> <code>filesource</code> <p>The source of the file. See notes for how files should be exported from other softwares or platforms.</p> <p><code>OPENHDEMG</code>     File saved from openhdemg (.json).</p> <p><code>DEMUSE</code>     File saved from DEMUSE (.mat).</p> <p><code>OTB</code>     File exported from OTB with decomposition and EMG signal.     (.mat).</p> <p><code>DELSYS</code>     Files exported from Delsys Neuromap and Neuromap explorer with     decomposition and EMG signal (.mat + .txt).</p> <p><code>CUSTOMCSV</code>     Custom file format (.csv) with decomposition and EMG signal.</p> <p><code>OTB_REFSIG</code>     File exported from OTB with only the reference signal (.mat).</p> <p><code>DELSYS_REFSIG</code>     File exported from DELSYS Neuromap with the reference signal     (.mat).</p> <p><code>CUSTOMCSV_REFSIG</code>     Custom file format (.csv) containing only the reference signal.</p> <p> TYPE: <code>str {\"OPENHDEMG\", \"DEMUSE\", \"OTB\", \"DELSYS\", \"CUSTOMCSV\", \"OTB_REFSIG\", \"DELSYS_REFSIG\", CUSTOMCSV_REFSIG}</code> DEFAULT: <code>\"OPENHDEMG\"</code> </p> <code>ignore_negative_ipts</code> <p>This parameter determines the silhouette score estimation. If True, only positive ipts values are used during peak and noise clustering. This is particularly important for compensating sources with large negative components. Currently, this parameter is used when loading files decomposed in DEMUSE or OTB.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>otb_ext_factor</code> <p>The extension factor used for the decomposition in the OTbiolab+ software. Ignore if loading other files.</p> <p> TYPE: <code>int</code> DEFAULT: <code>8</code> </p> <code>otb_refsig_type</code> <p>Whether to seacrh also for the REF_SIGNAL and whether to load the full or sub-sampled one. The list is composed as [bool, str]. str can be \"fullsampled\" or \"subsampled\". Ignore if loading other files.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[True, \"fullsampled\"]</code> </p> <code>otb_version</code> <p>Version of the OTBiolab+ software used (4 points). Tested versions are:     \"1.5.3.0\",     \"1.5.4.0\",     \"1.5.5.0\",     \"1.5.6.0\",     \"1.5.7.2\",     \"1.5.7.3\",     \"1.5.8.0\",     \"1.5.9.3\", If your specific version is not available in the tested versions, trying with the closer one usually works, but please double check the results. Ignore if loading other files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"1.5.9.3\"</code> </p> <code>otb_extras</code> <p>Extras is used to store additional custom values. These information will be stored in a pd.DataFrame with columns named as in the .mat file. If not None, pass a regex pattern unequivocally identifying the variable in the .mat file to load as extras.</p> <p> TYPE: <code>None or str</code> DEFAULT: <code>None</code> </p> <code>delsys_emg_sensor_name</code> <p>The name of the EMG sensor used to collect the data. We currently support only the \"Galileo sensor\". Ignore if loading other files or only the reference signal.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"Galileo sensor\"</code> </p> <code>delsys_refsig_sensor_name</code> <p>The name of the sensor used to record the reference signal. This is by default \"Trigno Load Cell\". However, since this can have any name (and can also be renamed by the user), here you should pass the effective name (or regex pattern) by which you identify the sensor. Ignore if loading other files or if no reference signal was recorded.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"Trigno Load Cell\"</code> </p> <code>delsys_filename_from</code> <p>The source by which the imported file will be named. This can either be the same name of the file containing the raw EMG signal or of the folder containing the decomposition outcome. Ignore if loading other files or only the reference signal.</p> <p> TYPE: <code>str {\"rawemg_file\", \"mus_directory\"}</code> DEFAULT: <code>\"mus_directory\"</code> </p> <code>custom_ref_signal</code> <p>Label of the column(s) containing the reference signal of the custom file. This and the following arguments are needed only for custom files. Ignore if loading other files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'REF_SIGNAL'</code> </p> <code>custom_raw_signal</code> <p>Label of the column(s) containing the raw emg signal of the custom file. Ignore if loading other files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'RAW_SIGNAL'</code> </p> <code>custom_ipts</code> <p>Label of the column(s) containing the pulse train of the custom file. Ignore if loading other files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'IPTS'</code> </p> <code>custom_mupulses</code> <p>Label of the column(s) containing the times of firing of the custom file. Ignore if loading other files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'MUPULSES'</code> </p> <code>custom_binary_mus_firing</code> <p>Label of the column(s) containing the binary representation of the MUs firings of the custom file. Ignore if loading other files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'BINARY_MUS_FIRING'</code> </p> <code>custom_accuracy</code> <p>Label of the column(s) containing the accuracy score of the decomposed MUs in the custom file. Ignore if loading other files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'ACCURACY'</code> </p> <code>custom_extras</code> <p>Label of the column(s) containing custom values in the custom file. This information will be stored in a pd.DataFrame with columns named as in the .csv file. Ignore if loading other files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'EXTRAS'</code> </p> <code>custom_fsamp</code> <p>Tha sampling frequency of the custom file. Ignore if loading other files.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2048</code> </p> <code>custom_ied</code> <p>The inter-electrode distance in mm of the custom file. Ignore if loading other files.</p> <p> TYPE: <code>int</code> DEFAULT: <code>8</code> </p> RETURNS DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>asksavefile : select where to save files with a GUI.</li> </ul> Notes <p>The returned file is called <code>emgfile</code> for convention (or <code>emg_refsig</code> if SOURCE in [\"OTB_REFSIG\", \"CUSTOMCSV_REFSIG\", \"DELSYS_REFSIG\"]).</p> <p>The input .mat file exported from the OTBiolab+ software should have a specific content:</p> <ul> <li>refsig signal is optional but, if present, there should be both the     fullsampled and the subsampled version (in OTBioLab+ the \"performed     path\" refers to the subsampled signal, the \"acquired data\" to the     fullsampled signal), REF_SIGNAL is expected to be expressed as % of     the MViF (but not compulsory).</li> <li>Both the IPTS ('Source for decomposition...' in OTBioLab+) and the     BINARY_MUS_FIRING ('Decomposition of...' in OTBioLab+) should be     present.</li> <li>The raw EMG signal should be present (it has no specific name in     OTBioLab+) with all the channels. Don't exclude unwanted channels     before exporting the .mat file.</li> <li>NO OTHER ELEMENTS SHOULD BE PRESENT! unless an appropriate regex pattern is passed to 'extras='!</li> </ul> <p>For Delsys files: We collect the raw EMG and the reference signal from the .mat file exported from the Delsys Neuromap software because the .csv doesn't contain the information about sampling frequency. Similarly, we collect the firing times, MUAPs and accuracy from the .txt files exported from the Delsys Neuromap Explorer software because in the .mat file, the accuracy is contained in a table, which is not compatible with Python.</p> <p>For custom .csv files: The variables of interest should be contained in columns. The name of the columns containing each variable can be specified by the user if different from the default values. This function detects the content of the .csv by parsing the .csv columns. For parsing, column labels should be provided. A label is a term common to all the columns containing the same information. For example, if the raw signal is contained in the columns 'RAW_SIGNAL_1', 'RAW_SIGNAL_2', ... , 'RAW_SIGNAL_n', the label of the columns should be 'RAW_SIGNAL'. If the parameters in input are not present in the .csv file, the user can simply leave the original inputs. Please see the documentation of the function emg_from_customcsv for additional informations. The .csv file must contain all the variables. The only admitted exceptions are 'ref_signal' and 'ipts'.</p> <p>Structure of the returned emgfile:</p> <pre><code>emgfile = {\n    \"SOURCE\": SOURCE,\n    \"FILENAME\": FILENAME,\n    \"RAW_SIGNAL\": RAW_SIGNAL,\n    \"REF_SIGNAL\": REF_SIGNAL,\n    \"ACCURACY\": accuracy score (depending on source file type),\n    \"IPTS\": IPTS (depending on source file type),\n    \"MUPULSES\": MUPULSES,\n    \"FSAMP\": FSAMP,\n    \"IED\": IED,\n    \"EMG_LENGTH\": EMG_LENGTH,\n    \"NUMBER_OF_MUS\": NUMBER_OF_MUS,\n    \"BINARY_MUS_FIRING\": BINARY_MUS_FIRING,\n    \"EXTRAS\": EXTRAS,\n}\n</code></pre> <p>Structure of the returned emg_refsig:</p> <pre><code>emg_refsig = {\n    \"SOURCE\": SOURCE,\n    \"FILENAME\": FILENAME,\n    \"FSAMP\": FSAMP,\n    \"REF_SIGNAL\": REF_SIGNAL,\n    \"EXTRAS\": EXTRAS,\n}\n</code></pre> <p>Examples:</p> <p>For an extended explanation of the imported emgfile use:</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OPENHDEMG\")\n&gt;&gt;&gt; info = emg.info()\n&gt;&gt;&gt; info.data(emgfile)\n</code></pre>"},{"location":"api_openfiles/#openhdemg.library.openfiles.asksavefile","title":"<code>asksavefile(emgfile, compresslevel=4)</code>","text":"<p>Select where to save files with a GUI.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile to save.</p> <p> TYPE: <code>dict</code> </p> <code>compresslevel</code> <p>An int from 0 to 9, where 0 is no compression and nine maximum compression. Compressed files will take less space, but will require more computation. The relationship between compression level and time required for the compression is not linear. For optimised performance, we suggest values between 2 and 6, with 4 providing the best balance.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> See also <ul> <li>askopenfile : select and open files with a GUI.</li> </ul>"},{"location":"api_pic/","title":"pic","text":""},{"location":"api_pic/#description","title":"Description","text":"<p>This module contains all the functions used to quantify and analyze MU persistent inward currents.</p> <p>Currently includes delta F.</p> <p></p> <p></p>"},{"location":"api_pic/#openhdemg.library.pic.compute_deltaf","title":"<code>compute_deltaf(emgfile, smoothfits, average_method='test_unit_average', normalisation='False', recruitment_difference_cutoff=1.0, corr_cutoff=0.7, controlunitmodulation_cutoff=0.5, clean=True)</code>","text":"<p>Quantify delta F via paired motor unit analysis.</p> <p>Conducts a paired motor unit analysis, quantifying delta F between the supplied collection of motor units. Origional framework for deltaF provided in Gorassini et. al., 2002: https://journals.physiology.org/doi/full/10.1152/jn.00024.2001</p> <p>Author: James (Drew) Beauchamp</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>smoothfits</code> <p>Smoothed discharge rate estimates. Each array: motor unit discharge rate x samples aligned in time; instances of non-firing = NaN Your choice of smoothing. See compute_svr gen_svr for example.</p> <p> TYPE: <code>list of arrays</code> </p> <code>average_method</code> <p>The method for test MU deltaF value. More to be added.</p> <p><code>test_unit_average</code>     The average across all possible control units.</p> <p><code>all</code>     This returns all possible MU pairs</p> <p> TYPE: <code>str {\"test_unit_average\", \"all\"}</code> DEFAULT: <code>\"test_unit_average\"</code> </p> <code>normalisation</code> <p>The method for deltaF nomalization.</p> <p><code>ctrl_max_desc</code>     Whether to normalise deltaF values to control unit descending     range during test unit firing. See Skarabot et. al., 2023:     https://www.biorxiv.org/content/10.1101/2023.10.16.562612v1</p> <p> TYPE: <code>str {\"False\", \"ctrl_max_desc\"}</code> DEFAULT: <code>\"False\"</code> </p> <code>recruitment_difference_cutoff</code> <p>An exlusion criteria corresponding to the necessary difference between control and test MU recruitement in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>corr_cutoff</code> <p>An exclusion criteria corresponding to the correlation between control and test unit discharge rate.</p> <p> TYPE: <code>float (0 to 1)</code> DEFAULT: <code>0.7</code> </p> <code>controlunitmodulation_cutoff</code> <p>An exclusion criteria corresponding to the necessary modulation of control unit discharge rate during test unit firing in Hz.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>clean</code> <p>To remove values that do not meet exclusion criteria</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>delta_f</code> <p>A pd.DataFrame containing deltaF values and corresponding MU number. The resulting df will be different depending on average_method. In particular, if average_method=\"all\", delta_fMU will contain a tuple representing the indices of the two motor units for each given pair (reporter, test) and their corresponding  deltaF value.</p> <p> TYPE: <code>DataFrame</code> </p> See also <ul> <li>compute_svr : fit MU discharge rates with Support Vector Regression,     nonlinear regression.</li> </ul> <p>Examples:</p> <p>Quantify delta F using svr fits.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.emg_from_samplefile()\n&gt;&gt;&gt; emgfile = emg.sort_mus(emgfile=emgfile)\n&gt;&gt;&gt; svrfits = emg.compute_svr(emgfile)\n&gt;&gt;&gt; delta_f = emg.compute_deltaf(\n...     emgfile=emgfile, smoothfits=svrfits[\"gensvr\"],\n... )\ndelta_f\n   MU        dF\n0   0       NaN\n1   1       NaN\n2   2       NaN\n3   3  1.838382\n4   4  2.709522\n</code></pre> <p>For all possible combinations, not test unit average, MU in this case is pairs (reporter, test).</p> <pre><code>&gt;&gt;&gt; delta_f_2 = emg.compute_deltaf(\n...     emgfile=emgfile, smoothfits=svrfits[\"gensvr\"], average_method='all',\n... )\ndelta_f_2\n       MU        dF\n0  (0, 1)       NaN\n1  (0, 2)       NaN\n2  (0, 3)  2.127461\n3  (0, 4)       NaN\n4  (1, 2)       NaN\n5  (1, 3)  1.549303\n6  (1, 4)       NaN\n7  (2, 3)       NaN\n8  (2, 4)       NaN\n9  (3, 4)  2.709522\n</code></pre>"},{"location":"api_plotemg/","title":"plotemg","text":""},{"location":"api_plotemg/#description","title":"Description","text":"<p>This module contains all the functions used to visualise the content of the imported EMG file, the MUs properties or to save figures.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"api_plotemg/#openhdemg.library.plotemg.showgoodlayout","title":"<code>showgoodlayout(tight_layout=True, despined=False)</code>","text":"<p>Despine and show plots with a good layout.</p> <p>This function is called by the various plot functions contained in the library but can also be used by the user to quickly adjust the layout of custom plots.</p> PARAMETER DESCRIPTION <code>tight_layout</code> <p>If true (default), plt.tight_layout() is applied to the figure.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>despined</code> <p>False: left and bottom is not despined (standard plotting).</p> <p>True: all the sides are despined.</p> <p><code>2yaxes</code>     Only the top is despined.     This is used to show y axes both on the right and left side at the     same time.</p> <p> TYPE: <code>bool or str {\"2yaxes\"}</code> DEFAULT: <code>False</code> </p>"},{"location":"api_plotemg/#openhdemg.library.plotemg.plot_emgsig","title":"<code>plot_emgsig(emgfile, channels, addrefsig=False, timeinseconds=True, figsize=[20, 15], showimmediately=True, tight_layout=True)</code>","text":"<p>Plot the RAW_SIGNAL. Single or multiple channels.</p> <p>Up to 12 channels (a common matrix row) can be easily observed togheter, but more can be plotted.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>channels</code> <p>The channel (int) or channels (list of int) to plot. The list can be passed as a manually-written list or with: channels=[*range(0, 13)]. We need the \" * \" operator to unpack the results of range into a list. channels is expected to be with base 0 (i.e., the first channel in the file is the number 0).</p> <p> TYPE: <code>int or list</code> </p> <code>addrefsig</code> <p>If True, the REF_SIGNAL is plotted in front of the signal with a separated y-axes.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>timeinseconds</code> <p>Whether to show the time on the x-axes in seconds (True) or in samples (False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>figsize</code> <p>Size of the figure in centimeters [width, height].</p> <p> TYPE: <code>list</code> DEFAULT: <code>[20, 15]</code> </p> <code>showimmediately</code> <p>If True (default), plt.show() is called and the figure showed to the user. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tight_layout</code> <p>If True (default), the plt.tight_layout() is called and the figure's layout is improved. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>fig</code> <p> TYPE: <code>pyplot `~.figure.Figure`</code> </p> See also <ul> <li>plot_differentials : plot the differential derivation of the RAW_SIGNAL     by matrix column.</li> </ul> <p>Examples:</p> <p>Plot channels 0 to 12 and overlay the reference signal.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emg.plot_emgsig(\n...     emgfile=emgfile,\n...     channels=[*range(0,13)],\n...     addrefsig=True,\n...     timeinseconds=True,\n...     figsize=[20, 15],\n... )\n</code></pre>"},{"location":"api_plotemg/#openhdemg.library.plotemg.plot_differentials","title":"<code>plot_differentials(emgfile, differential, column='col0', addrefsig=False, timeinseconds=True, figsize=[20, 15], showimmediately=True, tight_layout=True)</code>","text":"<p>Plot the differential derivation of the RAW_SIGNAL by matrix column.</p> <p>Both the single and the double differencials can be plotted. This function is used to plot also the sorted RAW_SIGNAL.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the original emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>differential</code> <p>The dictionary containing the differential derivation of the RAW_SIGNAL.</p> <p> TYPE: <code>dict</code> </p> <code>column</code> <p>The matrix column to plot. Options are usyally \"col0\", \"col1\", \"col2\", \"col3\", \"col4\". but might change based on the size of the matrix used.</p> <p> TYPE: <code>str {\"col0\", \"col1\", \"col2\", \"col3\", \"col4\", ...}</code> DEFAULT: <code>\"col0\"</code> </p> <code>addrefsig</code> <p>If True, the REF_SIGNAL is plotted in front of the signal with a separated y-axes.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>timeinseconds</code> <p>Whether to show the time on the x-axes in seconds (True) or in samples (False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>figsize</code> <p>Size of the figure in centimeters [width, height].</p> <p> TYPE: <code>list</code> DEFAULT: <code>[20, 15]</code> </p> <code>showimmediately</code> <p>If True (default), plt.show() is called and the figure showed to the user. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tight_layout</code> <p>If True (default), the plt.tight_layout() is called and the figure's layout is improved. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>fig</code> <p> TYPE: <code>pyplot `~.figure.Figure`</code> </p> See also <ul> <li>diff : calculate single differential of RAW_SIGNAL on matrix rows.</li> <li>double_diff : calculate double differential of RAW_SIGNAL on matrix rows.</li> <li>plot_emgsig : pot the RAW_SIGNAL. Single or multiple channels.</li> </ul> <p>Examples:</p> <p>Plot the differential derivation of the first matrix column (col0).</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n&gt;&gt;&gt;     emgfile=emgfile,\n&gt;&gt;&gt;     code=\"GR08MM1305\",\n&gt;&gt;&gt;     orientation=180,\n&gt;&gt;&gt; )\n&gt;&gt;&gt; sd=emg.diff(sorted_rawemg=sorted_rawemg)\n&gt;&gt;&gt; emg.plot_differentials(\n...     emgfile=emgfile,\n...     differential=sd,\n...     column=\"col0\",\n...     addrefsig=False,\n...     timeinseconds=True,\n...     figsize=[20, 15],\n...     showimmediately=True,\n... )\n</code></pre>"},{"location":"api_plotemg/#openhdemg.library.plotemg.plot_refsig","title":"<code>plot_refsig(emgfile, ylabel='MVC', timeinseconds=True, figsize=[20, 15], showimmediately=True, tight_layout=True)</code>","text":"<p>Plot the REF_SIGNAL.</p> <p>The REF_SIGNAL is usually expressed as % MVC for submaximal contractions or as Kilograms (Kg) or Newtons (N) for maximal contractions, but any value can be plotted.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>ylabel</code> <p>The unit of measure to show on the Y axis.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"MVC\"</code> </p> <code>timeinseconds</code> <p>Whether to show the time on the x-axes in seconds (True) or in samples (False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>figsize</code> <p>Size of the figure in centimeters [width, height].</p> <p> TYPE: <code>list</code> DEFAULT: <code>[20, 15]</code> </p> <code>showimmediately</code> <p>If True (default), plt.show() is called and the figure showed to the user. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tight_layout</code> <p>If True (default), the plt.tight_layout() is called and the figure's layout is improved. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>fig</code> <p> TYPE: <code>pyplot `~.figure.Figure`</code> </p> <p>Examples:</p> <p>Plot the reference signal.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emg.plot_refsig(emgfile=emgfile)\n</code></pre> <p>Change Y axis label and show time in samples.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emg.plot_refsig(\n&gt;&gt;&gt;     emgfile=emgfile,\n&gt;&gt;&gt;     ylabel=\"Custom unit e.g., N or kg\",\n&gt;&gt;&gt;     timeinseconds=False,\n&gt;&gt;&gt; )\n</code></pre>"},{"location":"api_plotemg/#openhdemg.library.plotemg.plot_mupulses","title":"<code>plot_mupulses(emgfile, munumber='all', linewidths=0.5, addrefsig=True, timeinseconds=True, figsize=[20, 15], showimmediately=True, tight_layout=True)</code>","text":"<p>Plot all the MUPULSES (binary representation of the firings time).</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>munumber</code> <p><code>all</code>     IPTS of all the MUs is plotted.</p> <p>Otherwise, a single MU (int) or multiple MUs (list of int) can be specified. The list can be passed as a manually-written list or with: munumber=[*range(0, 12)]. We need the \" * \" operator to unpack the results of range into a list. munumber is expected to be with base 0 (i.e., the first MU in the file is the number 0).</p> <p> TYPE: <code>(str, int or list)</code> DEFAULT: <code>\"all\"</code> </p> <code>linewidths</code> <p>The width of the vertical lines representing the MU firing.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>addrefsig</code> <p>If True, the REF_SIGNAL is plotted in front of the MUs pulses with a separated y-axes.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>timeinseconds</code> <p>Whether to show the time on the x-axes in seconds (True) or in samples (False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>figsize</code> <p>Size of the figure in centimeters [width, height].</p> <p> TYPE: <code>list</code> DEFAULT: <code>[20, 15]</code> </p> <code>showimmediately</code> <p>If True (default), plt.show() is called and the figure showed to the user. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tight_layout</code> <p>If True (default), the plt.tight_layout() is called and the figure's layout is improved. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>fig</code> <p> TYPE: <code>pyplot `~.figure.Figure`</code> </p> See also <ul> <li>plot_ipts : plot the MUs impulse train per second (IPTS).</li> <li>plot_idr : plot the instantaneous discharge rate.</li> </ul> <p>Examples:</p> <p>Plot MUs pulses based on recruitment order and overlay the reference signal.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emg.plot_mupulses(\n...     emgfile=emgfile,\n...     linewidths=0.5,\n...     order=True,\n...     addrefsig=True,\n...     timeinseconds=True,\n...     figsize=[20, 15],\n...     showimmediately=True,\n... )\n</code></pre>"},{"location":"api_plotemg/#openhdemg.library.plotemg.plot_ipts","title":"<code>plot_ipts(emgfile, munumber='all', addrefsig=False, timeinseconds=True, figsize=[20, 15], showimmediately=True, tight_layout=True)</code>","text":"<p>Plot the IPTS (decomposed source).</p> <p>IPTS is the non-binary representation of the MUs firing times.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>munumber</code> <p><code>all</code>     IPTS of all the MUs is plotted.</p> <p>Otherwise, a single MU (int) or multiple MUs (list of int) can be specified. The list can be passed as a manually-written list or with: munumber=[*range(0, 12)]. We need the \" * \" operator to unpack the results of range into a list. munumber is expected to be with base 0 (i.e., the first MU in the file is the number 0).</p> <p> TYPE: <code>(str, int or list)</code> DEFAULT: <code>\"all\"</code> </p> <code>timeinseconds</code> <p>Whether to show the time on the x-axes in seconds (True) or in samples (False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>figsize</code> <p>Size of the figure in centimeters [width, height].</p> <p> TYPE: <code>list</code> DEFAULT: <code>[20, 15]</code> </p> <code>showimmediately</code> <p>If True (default), plt.show() is called and the figure showed to the user. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tight_layout</code> <p>If True (default), the plt.tight_layout() is called and the figure's layout is improved. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>fig</code> <p> TYPE: <code>pyplot `~.figure.Figure`</code> </p> See also <ul> <li>plot_mupulses : plot the binary representation of the firings.</li> <li>plot_idr : plot the instantaneous discharge rate.</li> </ul> Notes <p>munumber = \"all\" corresponds to: munumber = [*range(0, emgfile[\"NUMBER_OF_MUS\"])]</p> <p>Examples:</p> <p>Plot IPTS of all the MUs and overlay the reference signal.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emg.plot_ipts(\n...     emgfile=emgfile,\n...     munumber=\"all\",\n...     addrefsig=True,\n...     timeinseconds=True,\n...     figsize=[20, 15],\n...     showimmediately=True,\n... )\n</code></pre> <p>Plot IPTS of two MUs.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emg.plot_ipts(\n...     emgfile=emgfile,\n...     munumber=[1, 3],\n...     addrefsig=False,\n...     timeinseconds=True,\n...     figsize=[20, 15],\n...     showimmediately=True,\n... )\n</code></pre>"},{"location":"api_plotemg/#openhdemg.library.plotemg.plot_idr","title":"<code>plot_idr(emgfile, munumber='all', addrefsig=True, timeinseconds=True, figsize=[20, 15], showimmediately=True, tight_layout=True)</code>","text":"<p>Plot the instantaneous discharge rate (IDR).</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>munumber</code> <p><code>all</code>     IDR of all the MUs is plotted.</p> <p>Otherwise, a single MU (int) or multiple MUs (list of int) can be specified. The list can be passed as a manually-written list or with: munumber=[*range(0, 12)]. We need the \" * \" operator to unpack the results of range into a list. munumber is expected to be with base 0 (i.e., the first MU in the file is the number 0).</p> <p> TYPE: <code>(str, int or list)</code> DEFAULT: <code>\"all\"</code> </p> <code>addrefsig</code> <p>If True, the REF_SIGNAL is plotted in front of the MUs IDR with a separated y-axes.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>timeinseconds</code> <p>Whether to show the time on the x-axes in seconds (True) or in samples (False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>figsize</code> <p>Size of the figure in centimeters [width, height].</p> <p> TYPE: <code>list</code> DEFAULT: <code>[20, 15]</code> </p> <code>showimmediately</code> <p>If True (default), plt.show() is called and the figure showed to the user. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tight_layout</code> <p>If True (default), the plt.tight_layout() is called and the figure's layout is improved. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>fig</code> <p> TYPE: <code>pyplot `~.figure.Figure`</code> </p> See also <ul> <li>plot_mupulses : plot the binary representation of the firings.</li> <li>plot_ipts : plot the impulse train per second (IPTS).</li> </ul> Notes <p>munumber = \"all\" corresponds to munumber = [*range(0, emgfile[\"NUMBER_OF_MUS\"])]</p> <p>Examples:</p> <p>Plot IDR of all the MUs and overlay the reference signal.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emg.plot_idr(\n...     emgfile=emgfile,\n...     munumber=\"all\",\n...     addrefsig=True,\n...     timeinseconds=True,\n...     figsize=[20, 15],\n...     showimmediately=True,\n... )\n</code></pre> <p>Plot IDR of two MUs.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emg.plot_idr(\n...     emgfile=emgfile,\n...     munumber=[1, 3],\n...     addrefsig=False,\n...     timeinseconds=True,\n...     figsize=[20, 15],\n...     showimmediately=True,\n... )\n</code></pre>"},{"location":"api_plotemg/#openhdemg.library.plotemg.plot_smoothed_dr","title":"<code>plot_smoothed_dr(emgfile, smoothfits, munumber='all', addidr=True, stack=True, addrefsig=True, timeinseconds=True, figsize=[20, 15], showimmediately=True, tight_layout=True)</code>","text":"<p>Plot the smoothed discharge rate.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>smoothfits</code> <p>Smoothed discharge rate estimates aligned in time. Columns should contain the smoothed discharge rate for each MU.</p> <p> TYPE: <code>DataFrame</code> </p> <code>munumber</code> <p><code>all</code>     IDR of all the MUs is plotted.</p> <p>Otherwise, a single MU (int) or multiple MUs (list of int) can be specified. The list can be passed as a manually-written list or with: munumber=[*range(0, 12)]. We need the \" * \" operator to unpack the results of range into a list. munumber is expected to be with base 0 (i.e., the first MU in the file is the number 0).</p> <p> TYPE: <code>(str, int or list)</code> DEFAULT: <code>\"all\"</code> </p> <code>addidr</code> <p>Whether to show also the IDR behind the smoothed DR line.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>stack</code> <p>Whether to stack multiple MUs. If False, all the MUs smoothed DR will be plotted on the same line.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addrefsig</code> <p>If True, the REF_SIGNAL is plotted in front of the MUs IDR with a separated y-axes.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>timeinseconds</code> <p>Whether to show the time on the x-axes in seconds (True) or in samples (False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>figsize</code> <p>Size of the figure in centimeters [width, height].</p> <p> TYPE: <code>list</code> DEFAULT: <code>[20, 15]</code> </p> <code>showimmediately</code> <p>If True (default), plt.show() is called and the figure showed to the user. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tight_layout</code> <p>If True (default), the plt.tight_layout() is called and the figure's layout is improved. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>fig</code> <p> TYPE: <code>pyplot `~.figure.Figure`</code> </p> See also <ul> <li>compute_svr : Fit MU discharge rates with Support Vector Regression,     nonlinear regression.</li> </ul> Notes <p>munumber = \"all\" corresponds to: munumber = [*range(0, emgfile[\"NUMBER_OF_MUS\"])]</p> <p>Examples:</p> <p>Smooth MUs DR using Support Vector Regression.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; emgfile = emg.emg_from_samplefile()\n&gt;&gt;&gt; emgfile = emg.sort_mus(emgfile=emgfile)\n&gt;&gt;&gt; svrfits = emg.compute_svr(emgfile)\n</code></pre> <p>Plot the stacked smoothed DR of all the MUs and overlay the IDR and the reference signal.</p> <pre><code>&gt;&gt;&gt; smoothfits = pd.DataFrame(svrfits[\"gensvr\"]).transpose()\n&gt;&gt;&gt; emg.plot_smoothed_dr(\n&gt;&gt;&gt;     emgfile,\n&gt;&gt;&gt;     smoothfits=smoothfits,\n&gt;&gt;&gt;     munumber=\"all\",\n&gt;&gt;&gt;     addidr=True,\n&gt;&gt;&gt;     stack=True,\n&gt;&gt;&gt;     addrefsig=True,\n&gt;&gt;&gt; )\n</code></pre>"},{"location":"api_plotemg/#openhdemg.library.plotemg.plot_muaps","title":"<code>plot_muaps(sta_dict, title='MUAPs from STA', figsize=[20, 15], showimmediately=True, tight_layout=False)</code>","text":"<p>Plot MUAPs obtained from STA from one or multiple MUs.</p> PARAMETER DESCRIPTION <code>sta_dict</code> <p>dict containing STA of the specified MU or a list of dicts containing STA of specified MUs. If a list is passed, different MUs are overlayed. This is useful for visualisation of MUAPs during tracking or duplicates removal.</p> <p> TYPE: <code>dict or list</code> </p> <code>title</code> <p>Title of the plot.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"MUAPs from STA\"</code> </p> <code>figsize</code> <p>Size of the figure in centimeters [width, height].</p> <p> TYPE: <code>list</code> DEFAULT: <code>[20, 15]</code> </p> <code>showimmediately</code> <p>If True (default), plt.show() is called and the figure showed to the user. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tight_layout</code> <p>If True (default), the plt.tight_layout() is called and the figure's layout is improved. It is useful to set it to False when calling the function from the GUI or if the final layout is not correct.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>fig</code> <p> TYPE: <code>pyplot `~.figure.Figure`</code> </p> See also <ul> <li>sta : computes the spike-triggered average (STA) of every MUs.</li> <li>plot_muap : for overplotting all the STAs and the average STA of a MU.</li> <li>align_by_xcorr : for alignin the STAs of two different MUs.</li> </ul> Notes <p>There is no limit to the number of MUs and STA files that can be overplotted.</p> <p><code>Remember: the different STAs should be matched</code> with same number of     electrode, processing (i.e., differential) and computed on the same     timewindow.</p> <p>Examples:</p> <p>Plot MUAPs of a single MU.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True,\n... )\n&gt;&gt;&gt; sta = emg.sta(\n...     emgfile=emgfile,\n...     sorted_rawemg=sorted_rawemg,\n...     firings=\"all\",\n...     timewindow=50,\n... )\n&gt;&gt;&gt; emg.plot_muaps(sta_dict=sta[1])\n</code></pre> <p>Plot single differential derivation MUAPs of a single MU.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True,\n... )\n&gt;&gt;&gt; sorted_rawemg = emg.diff(sorted_rawemg=sorted_rawemg)\n&gt;&gt;&gt; sta = emg.sta(\n...     emgfile=emgfile,\n...     sorted_rawemg=sorted_rawemg,\n...     firings=\"all\",\n...     timewindow=50,\n... )\n&gt;&gt;&gt; emg.plot_muaps(sta_dict=sta[1])\n</code></pre> <p>Plot single differential derivation MUAPs of two MUs from the same file.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True,\n... )\n&gt;&gt;&gt; sorted_rawemg = emg.diff(sorted_rawemg=sorted_rawemg)\n&gt;&gt;&gt; sta = emg.sta(\n...     emgfile=emgfile,\n...     sorted_rawemg=sorted_rawemg,\n...     firings=\"all\",\n...     timewindow=50,\n... )\n&gt;&gt;&gt; emg.plot_muaps(sta_dict=[sta[1], sta[2]])\n</code></pre>"},{"location":"api_plotemg/#openhdemg.library.plotemg.plot_muap","title":"<code>plot_muap(emgfile, stmuap, munumber, column, channel, channelprog=False, average=True, timeinseconds=True, figsize=[20, 15], showimmediately=True, tight_layout=True)</code>","text":"<p>Plot the MUAPs of a specific matrix channel.</p> <p>Plot the MUs action potential (MUAPs) shapes with or without average.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>stmuap</code> <p>dict containing a dict of ST MUAPs (pd.DataFrame) for every MUs.</p> <p> TYPE: <code>dict</code> </p> <code>munumber</code> <p>The number of the MU to plot.</p> <p> TYPE: <code>int</code> </p> <code>column</code> <p>The matrix columns. Options are usyally \"col0\", \"col1\", \"col2\", ..., last column.</p> <p> TYPE: <code>str</code> </p> <code>channel</code> <p>The channel of the matrix to plot. This can be the real channel number if channelprog=False (default), or a progressive number (from 0 to the length of the matrix column) if channelprog=True.</p> <p> TYPE: <code>int</code> </p> <code>channelprog</code> <p>Whether to use the real channel number or a progressive number (see channel).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>average</code> <p>Whether to plot also the MUAPs average obtained by spike triggered average.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>timeinseconds</code> <p>Whether to show the time on the x-axes in seconds (True) or in samples (False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>figsize</code> <p>Size of the figure in centimeters [width, height].</p> <p> TYPE: <code>list</code> DEFAULT: <code>[20, 15]</code> </p> <code>showimmediately</code> <p>If True (default), plt.show() is called and the figure showed to the user. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tight_layout</code> <p>If True (default), the plt.tight_layout() is called and the figure's layout is improved. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>fig</code> <p> TYPE: <code>pyplot `~.figure.Figure`</code> </p> See also <ul> <li>plot_muaps : Plot MUAPs obtained from STA from one or multiple MUs.</li> <li>st_muap : Generate spike triggered MUAPs of every MUs     (as input to this function).</li> </ul> <p>Examples:</p> <p>Plot all the consecutive MUAPs of a single MU. In this case we are plotting the matrix channel 45 which is placed in column 4 (\"col3\" as Python numbering is base 0).</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True,\n... )\n&gt;&gt;&gt; stmuap = emg.st_muap(\n...     emgfile=emgfile,\n...     sorted_rawemg=sorted_rawemg,\n...     timewindow=50,\n... )\n&gt;&gt;&gt; emg.plot_muap(\n...     emgfile=emgfile,\n...     stmuap=stmuap,\n...     munumber=1,\n...     column=\"col3\",\n...     channel=45,\n...     channelprog=False,\n...     average=False,\n...     timeinseconds=True,\n...     figsize=[20, 15],\n...     showimmediately=True,\n... )\n</code></pre> <p>To avoid the problem of remebering which channel number is present in which matrix column, we can set channelprog=True and locate the channel with a value ranging from 0 to the length of each column.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True,\n... )\n&gt;&gt;&gt; stmuap = emg.st_muap(\n...     emgfile=emgfile,\n...     sorted_rawemg=sorted_rawemg,\n...     timewindow=50,\n... )\n&gt;&gt;&gt; emg.plot_muap(\n...     emgfile=emgfile,\n...     stmuap=stmuap,\n...     munumber=1,\n...     column=\"col3\",\n...     channel=5,\n...     channelprog=True,\n...     average=False,\n...     timeinseconds=True,\n...     figsize=[20, 15],\n...     showimmediately=True,\n... )\n</code></pre> <p>It is also possible to visualise the spike triggered average of the MU with average=True. In this example the single differential derivation is used.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile=emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True,\n... )\n&gt;&gt;&gt; sorted_rawemg = emg.diff(sorted_rawemg=sorted_rawemg)\n&gt;&gt;&gt; stmuap = emg.st_muap(\n...     emgfile=emgfile,\n...     sorted_rawemg=sorted_rawemg,\n...     timewindow=50,\n... )\n&gt;&gt;&gt; emg.plot_muap(\n...     emgfile=emgfile,\n...     stmuap=stmuap,\n...     munumber=1,\n...     column=\"col2\",\n...     channel=6,\n...     channelprog=True,\n...     average=True,\n...     timeinseconds=True,\n...     figsize=[20, 15],\n...     showimmediately=True,\n... )\n</code></pre>"},{"location":"api_plotemg/#openhdemg.library.plotemg.plot_muaps_for_cv","title":"<code>plot_muaps_for_cv(sta_dict, xcc_sta_dict, title='MUAPs for CV', figsize=[20, 15], showimmediately=True, tight_layout=False)</code>","text":"<p>Visualise MUAPs on which to calculate MUs CV.</p> <p>Plot MUAPs obtained from the STA of the double differential signal and their paired cross-correlation value.</p> PARAMETER DESCRIPTION <code>sta_dict</code> <p>dict containing the STA of the double-differential derivation of a specific MU.</p> <p> TYPE: <code>dict</code> </p> <code>xcc_sta_dict</code> <p>dict containing the normalised cross-correlation coefficient of the double-differential derivation of a specific MU.</p> <p> TYPE: <code>dict</code> </p> <code>title</code> <p>Title of the plot.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"MUAPs from STA\"</code> </p> <code>figsize</code> <p>Size of the figure in centimeters [width, height].</p> <p> TYPE: <code>list</code> DEFAULT: <code>[20, 15]</code> </p> <code>showimmediately</code> <p>If True (default), plt.show() is called and the figure showed to the user. It is useful to set it to False when calling the function from the GUI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tight_layout</code> <p>If True (default), the plt.tight_layout() is called and the figure's layout is improved. It is useful to set it to False when calling the function from the GUI or if the final layout is not correct.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>fig</code> <p> TYPE: <code>pyplot `~.figure.Figure`</code> </p> <p>Examples:</p> <p>Plot the double differential derivation and the XCC of adjacent channels for the first MU (0).</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; sorted_rawemg = emg.sort_rawemg(\n...     emgfile,\n...     code=\"GR08MM1305\",\n...     orientation=180,\n...     dividebycolumn=True\n... )\n&gt;&gt;&gt; dd = emg.double_diff(sorted_rawemg)\n&gt;&gt;&gt; sta = emg.sta(\n...     emgfile=emgfile,\n...     sorted_rawemg=dd,\n...     firings=[0, 50],\n...     timewindow=50,\n... )\n&gt;&gt;&gt; xcc_sta = emg.xcc_sta(sta)\n&gt;&gt;&gt; fig = emg.plot_muaps_for_cv(\n...     sta_dict=sta[0],\n...     xcc_sta_dict=xcc_sta[0],\n...     showimmediately=True,\n... )\n</code></pre>"},{"location":"api_tools/","title":"tools","text":""},{"location":"api_tools/#description","title":"Description","text":"<p>This module contains the functions that don't properly apply to the plot or analysis category but that are necessary for the usability of the library. The functions contained in this module can be considered as \"tools\" or shortcuts necessary to operate with the HD-EMG recordings.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"api_tools/#openhdemg.library.tools.showselect","title":"<code>showselect(emgfile, how='ref_signal', title='', titlesize=12, nclic=2)</code>","text":"<p>Visually select a part of the recording.</p> <p>The area can be selected based on the reference signal or based on the mean EMG signal. The selection can be performed with any letter or number in the keyboard, wrong points can be removed by pressing the right mouse button. Once finished, press enter to continue.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>how</code> <p>What to display in the figure used to visually select the area to resize.</p> <p><code>ref_signal</code>     Visualise the reference signal to select the area to resize.</p> <p><code>mean_emg</code>     Visualise the mean EMG signal to select the area to resize.</p> <p> TYPE: <code>str {\"ref_signal\", \"mean_emg\"}</code> DEFAULT: <code>\"ref_signal\"</code> </p> <code>title</code> <p>The title of the plot. It is optional but strongly recommended. It should describe the task to do.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>titlesize</code> <p>The font size of the title.</p> <p> TYPE: <code>int</code> DEFAULT: <code>12</code> </p> <code>nclic</code> <p>The number of clics to be collected. If nclic &lt; 1, all the clicks are collected.</p> <p> DEFAULT: <code>2</code> </p> RETURNS DESCRIPTION <code>points</code> <p>A list containing the selected points sorted in ascending order.</p> <p> TYPE: <code>list</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>When the user clicked a wrong number of inputs in the GUI.</p> <p>Examples:</p> <p>Load the EMG file and select the points based on the reference signal.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB_REFSIG\")\n&gt;&gt;&gt; points = emg.showselect(\n...     emgfile,\n...     how=\"ref_signal\",\n...     title=\"Select 2 points\",\n...     nclic=2,\n... )\n&gt;&gt;&gt; points\n[16115, 40473]\n</code></pre> <p>Load the EMG file and select the points based on the mean EMG signal.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OPENHDEMG\")\n&gt;&gt;&gt; points = emg.showselect(\n...     emgfile,\n...     how=\"mean_emg\",\n...     title=\"Select 2 points\",\n...     nclic=2,\n... )\n&gt;&gt;&gt; points\n[135, 26598]\n</code></pre>"},{"location":"api_tools/#openhdemg.library.tools.create_binary_firings","title":"<code>create_binary_firings(emg_length, number_of_mus, mupulses)</code>","text":"<p>Create a binary representation of the MU firing.</p> <p>Create a binary representation of the MU firing over time based on the times of firing of each MU.</p> PARAMETER DESCRIPTION <code>emg_length</code> <p>Number of samples (length) in the emg file.</p> <p> TYPE: <code>int</code> </p> <code>number_of_mus</code> <p>Number of MUs in the emg file.</p> <p> TYPE: <code>int</code> </p> <code>mupulses</code> <p>Each ndarray should contain the times of firing (in samples) of each MU.</p> <p> TYPE: <code>list of ndarrays</code> </p> RETURNS DESCRIPTION <code>binary_MUs_firing</code> <p>A pd.DataFrame containing the binary representation of MUs firing.</p> <p> TYPE: <code>DataFrame</code> </p>"},{"location":"api_tools/#openhdemg.library.tools.mupulses_from_binary","title":"<code>mupulses_from_binary(binarymusfiring)</code>","text":"<p>Extract the MUPULSES from the binary MUs firings.</p> PARAMETER DESCRIPTION <code>binarymusfiring</code> <p>A pd.DataFrame containing the binary representation of MUs firings.</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <code>MUPULSES</code> <p>A list of ndarrays containing the firing time (in samples) of each MU.</p> <p> TYPE: <code>list</code> </p>"},{"location":"api_tools/#openhdemg.library.tools.resize_emgfile","title":"<code>resize_emgfile(emgfile, area=None, how='ref_signal', accuracy='recalculate', ignore_negative_ipts=False)</code>","text":"<p>Resize all the components in the emgfile.</p> <p>This function can be useful to compute the various parameters only in the area of interest.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile to resize.</p> <p> TYPE: <code>dict</code> </p> <code>area</code> <p>The resizing area. If already known, it can be passed in samples, as a list (e.g., [120,2560]). If None, the user can select the area of interest manually.</p> <p> TYPE: <code>None or list</code> DEFAULT: <code>None</code> </p> <code>how</code> <p>If area==None, allow the user to visually select the area to resize based on how.</p> <p><code>ref_signal</code>     Visualise the reference signal to select the area to resize.</p> <p><code>mean_emg</code>     Visualise the mean EMG signal to select the area to resize.</p> <p> TYPE: <code>str {\"ref_signal\", \"mean_emg\"}</code> DEFAULT: <code>\"ref_signal\"</code> </p> <code>accuracy</code> <p><code>recalculate</code>     The Silhouette score is computed in the new resized file. This can     be done only if IPTS is present.</p> <p><code>maintain</code>     The original accuracy measure already contained in the emgfile is     returned without any computation.</p> <p> TYPE: <code>str {\"recalculate\", \"maintain\"}</code> DEFAULT: <code>\"recalculate\"</code> </p> <code>ignore_negative_ipts</code> <p>This parameter determines the silhouette score estimation. If True, only positive ipts values are used during peak and noise clustering. This is particularly important for compensating sources with large negative components. This parameter is considered only if accuracy==\"recalculate\".</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>rs_emgfile</code> <p>the new (resized) emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>start_, end_ : int</code> <p>the start and end of the selection (can be used for code automation).</p> Notes <p>Suggested names for the returned objects: rs_emgfile, start_, end_.</p> <p>Examples:</p> <p>Manually select the area to resize the emgfile based on mean EMG signal and recalculate the silhouette score in the new portion of the signal.</p> <pre><code>&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"DEMUSE\", ignore_negative_ipts=True)\n&gt;&gt;&gt; rs_emgfile, start_, end_ = emg.resize_emgfile(\n...     emgfile,\n...     how=\"mean_emg\",\n...     accuracy=\"recalculate\",\n... )\n</code></pre> <p>Automatically resize the emgfile in the pre-specified area. Do not recalculate the silhouette score in the new portion of the signal.</p> <pre><code>&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"CUSTOMCSV\")\n&gt;&gt;&gt; rs_emgfile, start_, end_ = emg.resize_emgfile(\n...     emgfile,\n...     area=[120, 25680],\n...     accuracy=\"maintain\",\n... )\n</code></pre>"},{"location":"api_tools/#openhdemg.library.tools.compute_idr","title":"<code>compute_idr(emgfile)</code>","text":"<p>Compute the IDR.</p> <p>This function computes the instantaneous discharge rate (IDR) from the MUPULSES. The IDR is very useful for plotting and visualisation of the MUs behaviour.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>idr</code> <p>A dict containing a pd.DataFrame for each MU (keys are integers). Accessing the key, we have a pd.DataFrame containing:</p> <ul> <li>mupulses: firing sample.</li> <li>diff_mupulses: delta between consecutive firing samples.</li> <li>timesec: delta between consecutive firing samples in seconds.</li> <li>idr: instantaneous discharge rate.</li> </ul> <p> TYPE: <code>dict</code> </p> <p>Examples:</p> <p>Load the EMG file, compute IDR and access the results for the first MU.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; idr = emg.compute_idr(emgfile=emgfile)\n&gt;&gt;&gt; munumber = 0\n&gt;&gt;&gt; idr[munumber]\n    mupulses  diff_mupulses    timesec       idr\n0        9221            NaN   4.502441       NaN\n1        9580          359.0   4.677734  5.704735\n2        9973          393.0   4.869629  5.211196\n3       10304          331.0   5.031250  6.187311\n4       10617          313.0   5.184082  6.543131\n..        ...            ...        ...       ...\n149     54521          395.0  26.621582  5.184810\n150     54838          317.0  26.776367  6.460568\n151     55417          579.0  27.059082  3.537133\n152     55830          413.0  27.260742  4.958838\n153     56203          373.0  27.442871  5.490617\n</code></pre>"},{"location":"api_tools/#openhdemg.library.tools.delete_mus","title":"<code>delete_mus(emgfile, munumber, if_single_mu='ignore', delete_delsys_muaps=True)</code>","text":"<p>Delete unwanted MUs.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>munumber</code> <p>The MUs to remove. If a single MU has to be removed, this should be an int (number of the MU). If multiple MUs have to be removed, a list of int should be passed. An unpacked (*) range can also be passed as munumber=[*range(0, 5)]. munumber is expected to be with base 0 (i.e., the first MU in the file is the number 0).</p> <p> TYPE: <code>int, list of int</code> </p> <code>if_single_mu</code> <p>A string indicating how to behave in case of a file with a single MU.</p> <p><code>ignore</code> Ignore the process and return the original emgfile. (Default)</p> <p><code>remove</code> Remove the MU and return the emgfile without the MU. (Default) This should allow full compatibility with the use of this file in following processing (i.e., save/load and analyse).</p> <p> TYPE: <code>str {\"ignore\", \"remove\"}</code> DEFAULT: <code>\"ignore\"</code> </p> <code>delete_delsys_muaps</code> <p>If true, deletes also the associated MUAPs computed by the Delsys software stored in emgfile[\"EXTRAS\"].</p> <p> TYPE: <code>Bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile without the unwanted MUs.</p> <p> TYPE: <code>dict</code> </p> <p>Examples:</p> <p>Delete MUs 1,4,5 from the emgfile.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; emgfile = emg.delete_mus(emgfile=emgfile, munumber=[1,4,5])\n</code></pre>"},{"location":"api_tools/#openhdemg.library.tools.delete_empty_mus","title":"<code>delete_empty_mus(emgfile)</code>","text":"<p>Delete all the MUs without firings.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile without the empty MUs.</p> <p> TYPE: <code>dict</code> </p>"},{"location":"api_tools/#openhdemg.library.tools.sort_mus","title":"<code>sort_mus(emgfile)</code>","text":"<p>Sort the MUs in order of recruitment.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>sorted_emgfile</code> <p>The dictionary containing the sorted emgfile.</p> <p> TYPE: <code>dict</code> </p>"},{"location":"api_tools/#openhdemg.library.tools.compute_covsteady","title":"<code>compute_covsteady(emgfile, start_steady=-1, end_steady=-1)</code>","text":"<p>Calculates the covsteady.</p> <p>This function calculates the coefficient of variation of the steady-state phase (covsteady of the REF_SIGNAL).</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>start_steady</code> <p>The start and end point (in samples) of the steady-state phase. If &lt; 0 (default), the user will need to manually select the start and end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <code>end_steady</code> <p>The start and end point (in samples) of the steady-state phase. If &lt; 0 (default), the user will need to manually select the start and end of the steady-state phase.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> RETURNS DESCRIPTION <code>covsteady</code> <p>The coefficient of variation of the steady-state phase in %.</p> <p> TYPE: <code>float</code> </p> See also <ul> <li>compute_idr : computes the instantaneous discharge rate.</li> </ul> <p>Examples:</p> <p>Load the EMG file, compute covsteady and access the result from GUI.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; covsteady = emg.compute_covsteady(emgfile=emgfile)\n&gt;&gt;&gt; covsteady\n1.452806\n</code></pre> <p>The process can be automated by bypassing the GUI.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emgfile = emg.askopenfile(filesource=\"OTB\", otb_ext_factor=8)\n&gt;&gt;&gt; covsteady = emg.compute_covsteady(\n...     emgfile=emgfile,\n...     start_steady=3580,\n...     end_steady=15820,\n... )\n&gt;&gt;&gt; covsteady\n35.611263\n</code></pre>"},{"location":"api_tools/#openhdemg.library.tools.filter_rawemg","title":"<code>filter_rawemg(emgfile, order=2, lowcut=20, highcut=500)</code>","text":"<p>Band-pass filter the RAW_SIGNAL.</p> <p>The filter is a Zero-lag band-pass Butterworth.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>order</code> <p>The filter order.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>lowcut</code> <p>The lower cut-off frequency in Hz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>20</code> </p> <code>highcut</code> <p>The higher cut-off frequency in Hz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>500</code> </p> RETURNS DESCRIPTION <code>filteredrawsig</code> <p>The dictionary containing the emgfile with a filtered RAW_SIGNAL. Currently, the returned filteredrawsig cannot be accurately compressed when using the functions <code>save_json_emgfile()</code> and <code>asksavefile()</code>. We therefore suggest you to save the unfiltered emgfile if you want to obtain maximum compression.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>filter_refsig : low-pass filter the REF_SIGNAL.</li> </ul>"},{"location":"api_tools/#openhdemg.library.tools.filter_refsig","title":"<code>filter_refsig(emgfile, order=4, cutoff=15)</code>","text":"<p>Low-pass filter the REF_SIGNAL.</p> <p>This function is used to low-pass filter the REF_SIGNAL and remove noise. The filter is a Zero-lag low-pass Butterworth.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>order</code> <p>The filter order.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> <code>cutoff</code> <p>The cut-off frequency in Hz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>15</code> </p> RETURNS DESCRIPTION <code>filteredrefsig</code> <p>The dictionary containing the emgfile with a filtered REF_SIGNAL.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>remove_offset : remove the offset from the REF_SIGNAL.</li> <li>filter_rawemg : band-pass filter the RAW_SIGNAL.</li> </ul>"},{"location":"api_tools/#openhdemg.library.tools.remove_offset","title":"<code>remove_offset(emgfile, offsetval=0, auto=0)</code>","text":"<p>Remove the offset from the REF_SIGNAL.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>offsetval</code> <p>Value of the offset. If offsetval is 0 (default), the user will be asked to manually select an aerea to compute the offset value. Otherwise, the value passed to offsetval will be used. Negative offsetval can be passed.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>auto</code> <p>If auto &gt; 0, the script automatically removes the offset based on the number of samples passed in input.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>offs_emgfile</code> <p>The dictionary containing the emgfile with a corrected offset of the REF_SIGNAL.</p> <p> TYPE: <code>dict</code> </p> See also <ul> <li>filter_refsig : low-pass filter REF_SIGNAL.</li> </ul>"},{"location":"api_tools/#openhdemg.library.tools.get_mvc","title":"<code>get_mvc(emgfile, how='showselect', conversion_val=0)</code>","text":"<p>Measure the maximum voluntary contraction (MVC).</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile with the reference signal.</p> <p> TYPE: <code>dict</code> </p> <code>how</code> <p><code>showselect</code>     Ask the user to select the area where to calculate the MVC     with a GUI.</p> <p><code>all</code>     Calculate the MVC on the entire file.</p> <p> TYPE: <code>str {\"showselect\", \"all\"}</code> DEFAULT: <code>\"showselect\"</code> </p> <code>conversion_val</code> <p>The conversion value to multiply the original reference signal. I.e., if the original reference signal is in kilogram (kg) and conversion_val=9.81, the output will be in Newton (N). If conversion_val=0 (default), the results will simply be in the original measure unit. conversion_val can be any custom int or float.</p> <p> TYPE: <code>float or int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>mvc</code> <p>The MVC value in the original (or converted) unit of measurement.</p> <p> TYPE: <code>float</code> </p> See also <ul> <li>compute_rfd : calculate the RFD.</li> <li>remove_offset : remove the offset from the REF_SIGNAL.</li> <li>filter_refsig : low-pass filter REF_SIGNAL.</li> </ul> <p>Examples:</p> <p>Load the EMG file, remove reference signal offset and get MVC value.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emg_refsig = emg.askopenfile(filesource=\"OTB_REFSIG\")\n&gt;&gt;&gt; offs_refsig = emg.remove_offset(emgfile=emg_refsig)\n&gt;&gt;&gt; mvc = emg.get_mvc(emgfile=offs_refsig )\n&gt;&gt;&gt; mvc\n50.72\n</code></pre> <p>The process can be automated by bypassing the GUI and calculating the MVC of the entire file.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emg_refsig = emg.askopenfile(filesource=\"OTB_REFSIG\")\n&gt;&gt;&gt; mvc = emg.get_mvc(emgfile=emg_refsig, how=\"all\")\n&gt;&gt;&gt; print(mvc)\n50.86\n</code></pre>"},{"location":"api_tools/#openhdemg.library.tools.compute_rfd","title":"<code>compute_rfd(emgfile, ms=[50, 100, 150, 200], startpoint=None, conversion_val=0)</code>","text":"<p>Calculate the RFD.</p> <p>Rate of force development (RFD) is reported as X/Sec where \"X\" is the unit of measurement based on conversion_val.</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile with the reference signal.</p> <p> TYPE: <code>dict</code> </p> <code>ms</code> <p>Milliseconds (ms). A list containing the ranges in ms to calculate the RFD.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[50, 100, 150, 200]</code> </p> <code>startpoint</code> <p>The starting point to calculate the RFD in samples, If None, the user will be requested to manually select the starting point.</p> <p> TYPE: <code>None or int</code> DEFAULT: <code>None</code> </p> <code>conversion_val</code> <p>The conversion value to multiply the original reference signal. I.e., if the original reference signal is in kilogram (kg) and conversion_val=9.81, the output will be in Newton/Sec (N/Sec). If conversion_val=0 (default), the results will simply be Original measure unit/Sec. conversion_val can be any custom int or float.</p> <p> TYPE: <code>float or int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>rfd</code> <p>A pd.DataFrame containing the RFD at the different times.</p> <p> TYPE: <code>DataFrame</code> </p> See also <ul> <li>get_mvif : measure the MViF.</li> <li>remove_offset : remove the offset from the REF_SIGNAL.</li> <li>filter_refsig : low-pass filter REF_SIGNAL.</li> </ul> <p>Examples:</p> <p>Load the EMG file, low-pass filter the reference signal and compute RFD.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emg_refsig = emg.askopenfile(filesource=\"OTB_REFSIG\")\n&gt;&gt;&gt; filteredrefsig  = emg.filter_refsig(\n...     emgfile=emg_refsig,\n...     order=4,\n...     cutoff=15,\n... )\n&gt;&gt;&gt; rfd = emg.compute_rfd(\n...     emgfile=filteredrefsig,\n...     ms=[50, 100, 200],\n...     conversion_val=9.81,\n...     )\n&gt;&gt;&gt; rfd\n        50         100        200\n0  68.34342  79.296188  41.308215\n</code></pre> <p>The process can be automated by bypassing the GUI.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; emg_refsig = emg.askopenfile(filesource=\"OTB_REFSIG\")\n&gt;&gt;&gt; filteredrefsig  = emg.filter_refsig(\n...     emgfile=emg_refsig,\n...     order=4,\n...     cutoff=15,\n...     )\n&gt;&gt;&gt; rfd = emg.compute_rfd(\n...     emgfile=filteredrefsig,\n...     ms=[50, 100, 200],\n...     startpoint=3568,\n...     )\n&gt;&gt;&gt; rfd\n        50         100        200\n0  68.34342  79.296188  41.308215\n</code></pre>"},{"location":"api_tools/#openhdemg.library.tools.compute_svr","title":"<code>compute_svr(emgfile, gammain=1 / 1.6, regparam=1 / 0.37, endpointweights_numpulses=5, endpointweights_magnitude=5, discontfiring_dur=1.0)</code>","text":"<p>Fit MU discharge rates with Support Vector Regression, nonlinear regression.</p> <p>Provides smooth and continous estimates of discharge rate useful for quantification and visualisation. Suggested hyperparameters and framework from Beauchamp et. al., 2022 https://doi.org/10.1088/1741-2552/ac4594</p> <p>Author: James (Drew) Beauchamp</p> PARAMETER DESCRIPTION <code>emgfile</code> <p>The dictionary containing the emgfile.</p> <p> TYPE: <code>dict</code> </p> <code>gammain</code> <p>The kernel coefficient.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1/1.6</code> </p> <code>regparam</code> <p>The regularization parameter, must be positive.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1/0.370</code> </p> <code>endpointweights_numpulses</code> <p>Number of discharge instances at the start and end of MU firing to apply a weighting coefficient.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>endpointweights_magnitude</code> <p>The scaling factor applied to the number of pulses provided by endpointweights_numpulses. The scaling is applied to the regularization parameter, per sample. Larger values force the classifier to put more emphasis on the number of discharge instances at the start and end of firing provided by endpointweights_numpulses.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>discontfiring_dur</code> <p>Duration of time in seconds that defines an instnance of discontinuous firing. SVR fits will not be returned at points of discontinuity.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>svrfits</code> <p>A pd.DataFrame containing the smooth/continous MU discharge rates and corresponding time vectors.</p> <p> TYPE: <code>DataFrame</code> </p> See also <ul> <li>compute_deltaf : quantify delta F via paired motor unit analysis.</li> </ul> <p>Examples:</p> <p>Quantify svr fits.</p> <pre><code>&gt;&gt;&gt; import openhdemg.library as emg\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; emgfile = emg.emg_from_samplefile()\n&gt;&gt;&gt; emgfile = emg.sort_mus(emgfile=emgfile)\n&gt;&gt;&gt; svrfits = emg.compute_svr(emgfile)\n</code></pre> <p>Quick plot showing the results.</p> <pre><code>&gt;&gt;&gt; smoothfits = pd.DataFrame(svrfits[\"gensvr\"]).transpose()\n&gt;&gt;&gt; emg.plot_smoothed_dr(\n&gt;&gt;&gt;     emgfile,\n&gt;&gt;&gt;     smoothfits=smoothfits,\n&gt;&gt;&gt;     munumber=\"all\",\n&gt;&gt;&gt;     addidr=False,\n&gt;&gt;&gt;     stack=True,\n&gt;&gt;&gt;     addrefsig=True,\n&gt;&gt;&gt; )\n</code></pre>"},{"location":"cite-us/","title":"Cite us","text":"<p>If you use openhdemg for your reaserch, please cite our tutorial article. Any citation will help us to continue our work.</p> <p>Cite us as:</p> <p>Valli G, Ritsche P, Casolo A, Negro F, De Vito G. Tutorial: analysis of central and peripheral motor unit properties from decomposed High-Density surface EMG signals with openhdemg. Journal of Electromyography and Kinesiology, 2023, 102850, ISSN 1050-6411, https://doi.org/10.1016/j.jelekin.2023.102850.</p>"},{"location":"contacts/","title":"Contacts","text":""},{"location":"contacts/#primary-contact","title":"Primary contact","text":"<p> \u00a0 Any correspondence should be emailed to: openhdemg@gmail.com</p>"},{"location":"contacts/#discussion-forum","title":"Discussion forum","text":"<p> \u00a0 Read answers or ask questions in the openhdemg discussion section. If you are not familiar with GitHub discussions, please read this post. This will allow the openhdemg community to answer your questions.</p>"},{"location":"contacts/#follow-us-on-twitter","title":"Follow us on Twitter","text":"<p> https://twitter.com/openhdemg</p>"},{"location":"contribute/","title":"Contribute","text":"<p>This is probably the most important page of the website. As a community, we need your contribution to grow!</p> <p>There are many ways by which you can contribute to the growth of the openhdemg project, and all of them are equally important.</p> <p>If you want to become part of the team, read through the next sections to understand which ways of contribution fit better with your skills and expertise. For any question, or to begin the collaboration, contact us through your favorite channel.</p>"},{"location":"contribute/#contribution-categories","title":"Contribution categories","text":"<p> \u00a0 Code development</p> <p>This category is for individuals who want to contribute to the openhdemg project by writing code. As a developer, you can help enhance the framework's functionality, improve existing features, fix bugs, and implement new algorithms and analysis techniques. Your contributions will directly impact the usability and effectiveness of openhdemg. For details, read the specific section Guidelines for code developers.</p> <p> \u00a0 Knowledge sharing</p> <p>In the knowledge sharing category, we invite individuals with specialised expertise to contribute their valuable insights and knowledge to the openhdemg project. By sharing your expertise, you can help others in the community gain a deeper understanding of advanced analysis techniques, coding practices, and best practices in the field of HD-EMG. Your contribution will empower others to make the most out of openhdemg and accelerate the progress of HD-EMG research. Knowledge sharing is crucial for the growth and advancement of the openhdemg community.</p> <p> \u00a0 Code sharing</p> <p>The code sharing category is dedicated to individuals who have developed their own algorithms in Python or other languages, such as MATLAB, and want to contribute them to the openhdemg community. Your contribution can range from implementing new analysis techniques, data processing algorithms, or innovative visualization methods. We welcome you to share your code and contribute to the collective knowledge of the project.</p> <p> \u00a0 Accuracy check</p> <p>Ensuring the accuracy and reliability of the openhdemg framework is paramount. In this category, you can contribute by thoroughly testing and verifying the results of the framework's analysis algorithms and functionalities and providing feedback on potential improvements or issues. In this way, you can help enhance the accuracy and validity of openhdemg's results and increase the credibility of the entire openhdemg project.</p> <p> \u00a0 Promotion and advertising</p> <p>In order to grow our community, it is essential to increase our visibility and reach. Promotion and advertising play a crucial role in spreading the word about the openhdemg project and attracting new contributors. By actively engaging in promotion and advertising efforts, you can help us reach a wider audience and encourage more individuals to join our community. There are various ways you can contribute to promotion and advertising:</p> <ol> <li>Social Media: Help us promote openhdemg on social media platforms by sharing project updates, success stories, and relevant content. Use hashtags and tag relevant individuals or organizations to increase visibility.</li> <li>Blogging and Content Creation: Write blog posts, articles, or tutorials about openhdemg and its benefits. Share your experiences, insights, and use cases to inspire others and encourage them to get involved.</li> <li>Outreach and Collaboration: Connect with related communities, organizations, or academic institutions to collaborate on joint projects, guest blog posts, or events. By expanding our network, we can amplify our message and reach new audiences.</li> <li>Presentations and Workshops: Offer presentations or workshops at conferences, seminars, or webinars to showcase the capabilities of openhdemg. Demonstrate its potential applications and engage with the audience to generate interest and curiosity.</li> <li>Documentation and Case Studies: Contribute to the development of comprehensive documentation and case studies that highlight the value and impact of openhdemg. These resources will serve as references for researchers in the field.</li> </ol>"},{"location":"contribute/#open-call-for-contributions","title":"Open Call for Contributions","text":"<p>We welcome all enthusiastic individuals who wish to contribute to the openhdemg project but do not find an appropriate category for their ideas. If you have unique insights, suggestions, or contributions that can benefit the project, we encourage you to share them with us. Your diverse perspectives and ideas can drive innovation and shape the future of openhdemg. Together, we are a vibrant community dedicated to advancing the field. Join us and make a difference in the openhdemg project.</p>"},{"location":"contribute/#general-guidelines-for-code-developers","title":"General guidelines for code developers","text":"<p>By following these guidelines, you can ensure that your code contributions align with the project's standards and promote a smooth collaborative development process.</p> <ol> <li>Familiarize Yourself with the Project: Take the time to understand the openhdemg framework, its goals, and its existing codebase. Explore the documentation, tutorials, and code repositories to gain insights into the project's structure, coding conventions, and design principles.</li> <li>Select an Area of Contribution: Identify an area within openhdemg where you can make a meaningful impact. It could be enhancing existing features, fixing bugs, implementing new algorithms, or improving the overall functionality and performance of the framework.</li> <li>Follow Coding Best Practices: Write clean, readable, and well-documented code. Adhere to established coding standards, such as PEP 8 for Python, to maintain consistency and readability. Comment your code appropriately to enhance its understandability and maintainability.</li> <li>Test and Validate Your Code: Thoroughly test your code to ensure its correctness and robustness. Write unit tests and integration tests to cover different scenarios and edge cases. Validate your code against real-world data and compare the results with expected outcomes.</li> <li>Use Version Control: Utilize the version control systems Git to manage your code changes. Fork the openhdemg repository to create a separate copy under your GitHub account. Make your code contributions in the forked repository by creating a new branch from the current branch used for the development of new features. This allows for easy review, collaboration, and integration of your code into the openhdemg project. When you're ready, submit your changes as pull requests from your forked repository to the corresponding branch in the openhdemg repository.</li> <li>Engage in Code Reviews: Participate in code reviews and provide constructive feedback to your fellow contributors. Actively engage in discussions, address comments and suggestions, and iteratively improve your code based on the feedback received.</li> <li>Document Your Contributions: Document your code changes, including any new features, modifications, or improvements. Update the project's documentation or relevant documentation files to reflect your contributions accurately.</li> <li>Communicate and Collaborate: Join the openhdemg community discussion section to connect with other developers and maintain open communication channels. Collaborate with the community by sharing ideas, seeking help, or contributing to ongoing discussions.</li> <li>Respect Licensing and Intellectual Property: Ensure that your code contributions comply with the project's chosen license. Respect intellectual property rights and avoid incorporating copyrighted code or resources without proper authorization or licensing.</li> </ol> <p>By following these guidelines, you can contribute effectively to the openhdemg project and help advance the field of HD-EMG analysis. Your code contributions will play a vital role in improving the framework, expanding its functionality, and enabling new research possibilities. Thank you for being a valuable member of our code development community!</p>"},{"location":"contribute/#specific-guidelines-for-code-developers","title":"Specific guidelines for code developers","text":"<p>These guidelines should not be interpreted and must apply to all the developers. If you spot any divergence from these rules in the actual code, please suggest the author to edit the corresponding section.</p> <ul> <li>Language: British English</li> <li>Documentation style: NumPy</li> <li>Respect PEP 8</li> <li>Use a code checker (suggested flake8)</li> <li>Never alter the original structure of the emgfile described in the tutorial Structure of the emgfile</li> <li>Always work (i.e., Fetch/Pull request) on the current working branch. Not in the main branch.</li> </ul>"},{"location":"gui_advanced/","title":"Graphical Interface","text":"<p>This is the toturial for the <code>Advanced Tools</code> in the openhdemg GUI. Great that you made it this far! In the next few sections we will take a look at the more advanced functions implemented in the GUI. But first of all, you need to click the <code>Advanced Tools</code> button in the main window of the GUI to get to the respective adavanced analysis. The <code>Advanced Tools Window</code> will open.</p> <p></p> <p>Please note, the <code>Advanced Tools</code> might not be available for all the files, as some of them might not have a sufficient number of electrodes to directly perform the advanced analyses. If you want to use the advanced tools anyway, you can still do so from the library.</p>"},{"location":"gui_advanced/#start-a-specific-tool","title":"Start a Specific Tool","text":"<p>So far, we have included four advanced analyses in the openhdemg GUI.</p> <ul> <li><code>Motor Unit Tracking</code></li> <li><code>Duplicate Removal</code></li> <li><code>Conduction Velocity Estimation</code></li> <li><code>Persistent Inward Currents</code></li> </ul> <p>For some of these analyses, the specification of a <code>Matrix Code</code> and a <code>Matrix Orientation</code> is required.</p> <p>The <code>Matrix Code</code> must be specified according to the one you used during acquisition. So far, the implemented codes are:</p> <pre><code>- `Custom order`\n- `None`\n- `GR08MM1305`\n- `GR04MM1305`\n- `GR10MM0808`\n</code></pre> <p>In case you selected <code>Custom order</code>, you must also specify the custom order in the GUI settings. Please refer to this tutorial for further instructions on how to do so.</p> <p>In case you selected <code>None</code>, the entrybox <code>Rows, Columns</code> will appear. Please specify the number of rows and columns of your used matrix since you now bypass included matrix codes. In example, specifying</p> <p><pre><code>Rows, Columns: 13, 5\n</code></pre> means that your File has 65 channels organised over 13 rows and 5 columns.</p> <p>The use of <code>None</code> is suggested anytime your loaded file contains already sorted EMG channels and you want to avoid further sorting.</p> <p>If you selected one of the built-in sorting orders (e.g., <code>GR08MM1305</code>, <code>GR04MM1305</code>, <code>GR10MM0808</code>), you need to specify also the <code>Orientation</code> in row two and column four in the left side of the <code>Plot Window</code>. The <code>Orientaion</code> must match the one of your matrix during acquisition. You can find a reference image for the <code>Orientation</code> at the bottom in the right side of the <code>Plot Window</code>. <code>Orientation</code> is ignored when <code>Matrix Code</code> is <code>None</code> or <code>Custom order</code>.</p> <p>Once you specified these parameter, you can click the <code>Advaned Analysis</code> button to start your analysis.</p>"},{"location":"gui_advanced/#motor-unit-tracking","title":"Motor Unit Tracking","text":"<p>When you want to track MUs across two different files, you need to select the <code>Motor Unit Tracking</code> option and specify the <code>Matrix Code</code> and <code>Matrix Orentation</code> in the <code>Advanced Tools Window</code>. Once you clicked the <code>Advanced Analysis</code> button, the <code>MUs Tracking Window</code> will pop-up.</p> <p></p> <ol> <li> <p>You need to specify the <code>Type of file</code> you want to track MUs across in the respective dropdown. The available filetypes are:</p> <ul> <li><code>OPENHDEMG</code> (emgfile or reference signal stored in .json format)</li> <li><code>CUSTOMCSV</code> (custom data from a .csv file)</li> <li><code>OTB</code> (.mat file exportable by OTBiolab+)</li> <li><code>DEMUSE</code> (.mat file used in DEMUSE)</li> </ul> <p>Each filetype corresponds to a distinct datatype that should match the file you want to analyse. So, select the Type of file corresponding to the type of your file. In case you selected <code>OTB</code>, specify the <code>extension factor</code> in the dropdown.</p> </li> <li> <p>Load the files according to specified <code>Type of file</code>using the <code>Load File 1</code> and <code>Load File 2</code> buttons.</p> </li> <li> <p>Select the minimum cross-correlation value to consider two MUs to be the same in the <code>Threshold</code> dropdown.</p> </li> <li> <p>Specify the timewindow across which you want the spike triggered average to be computed in the <code>Timewindow</code> dropdown.</p> </li> <li> <p>Select whether to exclude results with cross-correlation below specified <code>Threshold</code> by ticking the <code>Exclude below threshold</code> checkbox. </p> </li> <li> <p>If you select the <code>Filter</code> checkbox, only the match with the highest cross-correlation is returned when the same MU has a match of cross-correlation &gt; <code>Threshold</code> with multiple MUs.</p> </li> <li> <p>The <code>Show</code> checkbox indicates whether to plot the spike triggered average of pairs of MUs with cross-correlation above <code>Threshold</code>.</p> </li> <li> <p>By clicking the <code>Track</code> button, you can start the analysis. The tracking results will be displayed in the <code>MUs Tracking Result</code> output in the right side of the <code>MUs Tracking Window</code>.</p> </li> </ol>"},{"location":"gui_advanced/#duplicate-removal","title":"Duplicate Removal","text":"<p>When you want to remove MUs duplicates across different files, you need to select the <code>Duplicate Removal</code> options and specify the <code>Matrix Code</code> and <code>Matrix Orentation</code> in the <code>Advanced Tools Window</code>. Once you clicked the <code>Advanced Analysis</code> button, the <code>Duplicate Removal Window</code> will pop-up. <code>Duplicate Removal</code> requires similar input as <code>Motor Unit Tracking</code>, so please take a look at the <code>Motor Unit Tracking</code> section. However, you need to do two more things. </p> <p></p> <ol> <li> <p>You should specify How to remove the duplicated MUs in the <code>Which</code> dropdown. You can choose between</p> <ul> <li>munumber: Duplicated MUs are removed from the file with more MUs.</li> <li>accuracy: The MU with the lowest accuracy score is removed.</li> </ul> </li> <li> <p>By clicking the <code>Remove Duplicates</code> button, you start the removal process.</p> </li> <li> <p>Specify a filename and location to save the file(s) with duplicates removed in a .json format.</p> </li> </ol>"},{"location":"gui_advanced/#conduction-velocity","title":"Conduction Velocity","text":"<p>Prior to calculation of the <code>Conduction Velocity</code> you need to load a file in the main window of the GUI. Take a look at the intro section.  Once you have done this, open the <code>Advanced Tool Window</code> using the <code>Advanced Analaysis</code> button. </p> <ol> <li> <p>Select <code>Conduction Velocity</code> in the <code>Analysis Tool</code> dropdown, decide on the <code>Matrix Orientation</code> and <code>Matrix Code</code> as described above.</p> </li> <li> <p>Click the <code>Advanced Analysis</code> button to start the calculation of the <code>Conduction Velocity</code>. The <code>MUs cv estimation</code> window will pop up. </p> <p></p> </li> <li> <p>In the top left of the <code>MUs cv estimation</code> window select the MU for which you want to calculate the conduction velocity using the <code>MU Number</code> dropdown. </p> </li> <li> <p>In the top middle of the window select the column for which you want to calculate the conduction velocity choosing from the <code>Column</code> dropdown.</p> </li> <li> <p>In the top right of the window select the rows for which you want to calculate the conduction velocity using the <code>From row</code> and <code>To row</code> dropdown. For example, if you want to calculate the conduction velocity from row 3 to 7, select </p> <pre><code>From row: 3\nTo row: 7\n</code></pre> </li> <li> <p>Click the <code>Estimate</code> button to start the calculation for the respective column and rows. The results will be displayed on the right side of the <code>MUs cv estimation</code> window. </p> </li> <li> <p>You can copy the estimation results using the <code>Copy Results</code> button for futher analysis. The results are copied in the clipboard and can be pasted into any .csv (Excel). </p> </li> </ol> <p>We are now at the end of describing the advanced functions included in the openhdemg GUI. If you want to take a look at more basic stuff, check out the basic.</p>"},{"location":"gui_advanced/#persistent-inward-currents","title":"Persistent Inward Currents","text":"<p>When you want to estimate Persistent Inward Currents, you need to select the <code>Persistent Inward Currents</code> option. In this case, <code>Matrix Code</code> and <code>Matrix Orentation</code> will be locked, as these are not needed for the analysis. Once you clicked the <code>Advanced Analysis</code> button, the <code>Persistent Inward Currents Window</code> will pop-up.</p> <p></p> <p>Please note that it is suggested to sort the MUs based on recruitment order before performing the PICs estimation. This can be done in the main GUI window.</p> <ol> <li> <p>In row 1 of this window you can select the smoothing tecnique to adopt (at the time of writing, only the <code>Support Vector Regression</code> is available, but more are under development).</p> </li> <li> <p>Select the <code>Average Method</code> to use for test MU deltaF value.</p> </li> <li> <p>Select the method for deltaF  <code>Normalisation</code>.</p> </li> <li> <p>Select the <code>Clean</code> option if you want to remove values that do not meet exclusion criteria.</p> </li> <li> <p>By clicking the <code>Compute PIC</code> button, you can start the analysis. The results will be displayed in the right side of the <code>Persistent Inward Currents Window</code>.</p> </li> </ol>"},{"location":"gui_advanced/#more-questions","title":"More questions?","text":"<p>We hope that this tutorial was useful. If you need any additional information, do not hesitate to read the answers or ask a question in the openhdemg discussion section. If you are not familiar with GitHub discussions, please read this post. This will allow the openhdemg community to answer your questions.</p> <p>Moreover, if you noticed an error that was not properly catched by the GUI, please report the issue.</p>"},{"location":"gui_basics/","title":"Graphical Interface","text":"<p>This is the basic introduction to the openhdemg GUI. In the next few sections, we will go through the basic analysis functions embedded in the GUI. For the advanced stuff, take a look at the advanced chapter. We will start with how to sort the motor units (MUs) included in your analysis file, go over force and MU property analysis, take a detour on plotting, and take a look at how to save and reset your analysis. Have fun!</p>"},{"location":"gui_basics/#motor-unit-sorting","title":"Motor Unit Sorting","text":"<p>To sort the MUs included in your analysis file in order of their recruitement, we implemented a sorting algorithm. The MUs are sorted based on their recruitement order in an ascending manner.</p> <ol> <li> <p>Load a file. Take a look at the intro section on how to do so.</p> </li> <li> <p>On the left hand side in the main window of the GUI, you can find the <code>Sort MUs</code> button. It is located in row three, column two. Once you press the button, the MUs will be sorted based on recruitment order. </p> </li> </ol>"},{"location":"gui_basics/#remove-motor-units","title":"Remove Motor Units","text":"<p>To remove MUs included in your analysis file, you can click the <code>Remove MUs</code> button. The button is located on the left hand side in the main window of the GUI in column one of row four.</p> <p></p> <ol> <li> <p>Click the <code>Remove MUs</code> button, and a file is loaded, a pop-up window will open. </p> </li> <li> <p>Select the MU you want to delete from the analysis file from the <code>Select MU:</code>dropdown.</p> <p><pre><code>Select MU: 1\n</code></pre> will result in the second MU to be deleted (Python is base 0).</p> </li> <li> <p>Click the <code>Remove MU</code> button to remove the MU.</p> </li> </ol> <p>Alternatively, you can click the <code>Remove empty MUs</code> button to delete all the MUs without discharge times. These can be present in the emgfile as the result of decomposed duplicates that have not been fully removed.</p>"},{"location":"gui_basics/#signal-editing","title":"Signal Editing","text":"<p>It is often necessary to edit (e.g., filter or convert) the signals. In the openhdemg GUI this can be done from the <code>Signal Editing Window</code>. In order to open this window, click the <code>Signal Editing</code> button.</p> <p></p>"},{"location":"gui_basics/#emg-signal-filtering","title":"EMG Signal Filtering","text":"<p>It is common practice to filter the EMG signal before decomposition. However, if your emgfile contains the raw (unfiltered) signal, this can be easily filtered from the <code>Signal Editing Window</code>.</p> <ol> <li> <p>Click the <code>Signal Editing</code> button located in row five and column one, a new pop-up window opens. In the <code>Signal Editing Window</code>, you can band-pass filter the EMG signal and process the reference signal (see next paragraph).</p> </li> <li> <p>When you click the <code>Filter EMG signal</code> button, the EMG signal is band-pass filtered (Zero-lag, Butterworth) according to values specified in the <code>Filter Order</code> and <code>BandPass Freq</code> textboxes. In example, specifiying </p> <p><pre><code>Filter Order: 2\nBandPass Freq: 20-500\n</code></pre> will allow only frequencies between 20 and 500 Hz to pass trough.</p> </li> </ol>"},{"location":"gui_basics/#reference-signal-editing","title":"Reference Signal Editing","text":"<p>The openhdemg GUI also allows you to edit and filter reference signals contained in your analysis file (this can be either a file containing both the MUs and the reference signal or a file containing only the reference signal).</p> <ol> <li> <p>Click the <code>Signal Editing</code> button located in row five and column one, a new pop-up window opens. In the <code>Signal Editing Window</code>, you can low-pass filter the reference signal as well as remove any signal offset. Additionally, you can also convert your reference signal by a specific factor (amplification factor) or convert it from absolute to percentage (relative or normalised) values.</p> </li> <li> <p>When you click the <code>Filter RefSig</code> button, the reference signal is low-pass filtered (Zero-lag, Butterworth) according to values specified in the <code>Filter Order</code> and <code>Cutoff Freq</code> textboxes. In example, specifiying </p> <p><pre><code>Filter Order: 4\nCutoff Freq: 15\n</code></pre> will allow only frequencies below 15 Hz to pass trough.</p> </li> <li> <p>When you click the <code>Remove Offset</code> button, the reference signal's offset will be removed according to the values specified in the <code>Offset Value</code> and <code>Automatic Offset</code> textboxes. In example, specifying</p> <p><pre><code>Offset Value : 4\nAutomatic: 0\n</code></pre> will result in an offset correction by -4 in y-axis direction. Furthermore, specifying</p> <p><pre><code>Offset Value : 0\nAutomatic: != 0\n</code></pre> will result in automatic offset removal. In this case, the offset value is determined as the mean value of n samples at the beginning of the contraction (where n is equal to the value passed to Automatic). Moreover, specifying</p> <p><pre><code>Offset Value : 0\nAutomatic: 0\n</code></pre> will allow you to manually correct the offset in a new pop-up plot. You just need to follow the instructions on the plot.</p> </li> <li> <p>When you click the <code>Convert</code> button, the reference signal will be multiplied or divided (depending on <code>Operator</code>) by the <code>Factor</code>. In example, specifying</p> <p><pre><code>Operator : \"Multiply\"\nFactor: 2.5\n</code></pre> will amplify the reference signal 2.5 times.</p> <p>While:</p> <p><pre><code>Operator : \"Multiply\"\nFactor: -1\n</code></pre> will make your negative reference signal become positive.</p> </li> <li> <p>When you click the <code>To Percent</code> button, the reference signal in absolute values is converted to percentage (relative or normalised) values based on the provided <code>MVC Value</code>. This step should be performed before any analysis, because openhdemg is designed to work with a normalised reference signal. In example, a file with a reference signal in absolute values ranging from 0 to 100 will be normalised from 0 to 20 if</p> <pre><code>MVC Value : 500\n</code></pre> </li> </ol>"},{"location":"gui_basics/#resize-emg-file","title":"Resize EMG File","text":"<p>Sometimes, resizing of your analysis file is unevitable. Luckily, openhdemg provides an easy solution. In row five and column two in the left side of the GUI, you can find the <code>Resize File</code> button. </p> <p></p> <ol> <li> <p>View the MUs using the <code>View MUs</code> button prior to file resizing, you can directly see what is happening.</p> </li> <li> <p>Clicking the <code>Resize File</code> button will open a new pop-up plot of your analysis file. </p> </li> <li> <p>Follow the instructions in the plot to resize the file. Simply click in the signal twice (once for start-point, once for end-point) to specify the resizing region and press enter to confirm your choice.</p> </li> </ol>"},{"location":"gui_basics/#analyse-force-signal","title":"Analyse Force Signal","text":"<p>In order to analyse the force signal in your analysis file, you can press the <code>Analyse Force</code> button located in row six and column one in the left side of the GUI. A new pop-up window will open where you can analyse the maximum voluntary contraction (MVC) value as well as the rate of force development (RFD). </p> <p></p>"},{"location":"gui_basics/#maximum-voluntary-contraction","title":"Maximum voluntary contraction","text":"<ol> <li>In order to get the MVC value, simply press the <code>Get MVC</code> button. A pop-up plot opens and you can select the area where you suspect the MVC to be. </li> <li>Click once to specify the start-point and once to specify the end-point. </li> <li>Press enter to confirm you choice. You will then see a <code>Result Output</code> appearing at the bottom of the main window of the GUI. There you can find the actual result of your MVC analysis. </li> <li>You can edit or copy any value in the <code>Result Output</code>, however, you need to close the top-level <code>Force Analysis Window</code> first.</li> </ol>"},{"location":"gui_basics/#rate-of-force-development","title":"Rate Of Force Development","text":"<ol> <li>To calculate the RFD values you can press the <code>Get RFD</code> button. </li> <li>A pop-up plot appears and you need to specify the starting point of the rise in the force signal by clicking and subsequenlty pressing enter. </li> <li> <p>The respective RFD values between the stated timepoint ranges (ms) in the <code>RFD miliseconds</code> textinput are displayed in the <code>Result Output</code>. In example, specifying</p> <p><pre><code>RFD miliseconds: 50,100,150,200\n</code></pre> will result in RFD value calculation between the intervals 0-50ms, 0-100ms, 0-150ms and 0-200ms. You can also specify less or more values in the <code>RFD miliseconds</code> textbox. </p> </li> <li> <p>You can edit or copy any value in the <code>Result Output</code>, however, you need to close the top-level <code>Force Analysis Window</code> first.</p> </li> </ol>"},{"location":"gui_basics/#motor-unit-properties","title":"Motor Unit Properties","text":"<p>When you press the <code>MU Properties</code> button in row six and column two, the <code>Motor Unit Properties</code> Window will pop up. In this window, you have the option to analyse several MUs propierties such as the MUs recruitement threshold or the MUs discharge rate. </p> <p></p> <ol> <li> <p>Specify your priorly calculated MVC in the <code>Enter MVC [N]:</code> textbox, like</p> <pre><code>Enter MVC [N]: 424\n</code></pre> </li> </ol>"},{"location":"gui_basics/#compute-motor-unit-threshold","title":"Compute Motor Unit Threshold","text":"<p>Subsequently to specifying the MVC, you can compute the MUs recruitement threshold by specifying the respective event and type in the <code>Event</code> and <code>Type</code> dropdown list. </p> <ol> <li> <p>Specify the <code>Event</code> dropdown and choose: </p> <pre><code>\"rt_dert\" : Both recruitment and derecruitment thresholds will be calculated.\n\"rt\" : Only recruitment thresholds will be calculated.\n\"dert\" : Only derecruitment thresholds will be calculated.\n</code></pre> </li> <li> <p>Specify the <code>Type</code> dropdown and choose:</p> <pre><code>\"abs_rel\" : Both absolute and relative thresholds will be calculated.\n\"rel\" : Only relative thresholds will be calculated.\n\"abs\" : Only absolute thresholds will be calculated.\n</code></pre> </li> <li> <p>Once you click the <code>Compute threshold</code> button, the recruitement threshold will be computed. </p> </li> <li>The recruitement threshold for each inluded MU in the analysis file will be displayed in the <code>Result Output</code> of the GUI.</li> <li>You can edit or copy any value in the <code>Result Output</code>, however, you need to close the top-level <code>Motor Unit Properties Window</code> first.</li> </ol>"},{"location":"gui_basics/#compute-motor-unit-discharge-rate","title":"Compute Motor Unit Discharge Rate","text":"<p>Subsequently to specifying the MVC, you can compute the MUs discharge rate by entering the respective firing rates and event.</p> <ol> <li>Specify the number of firings at recruitment and derecruitment to consider for the calculation in the <code>Firings at Rec</code> textbox. </li> <li> <p>Enter the number of firings over which to calculate the discharge rate at the start and end of the steady-state phase in the <code>Firings Start/End Steady</code> textbox.</p> <p>For example: <pre><code>Firings at Rec: 4\nFirings Start/End Steady: 10\n</code></pre></p> </li> <li> <p>Lastly you need to specify the computation <code>Event</code>. From the <code>Event</code> dropdown list, you can choose:</p> <pre><code>\"rec_derec_steady\" : Discharge rate is calculated at recruitment, derecruitment and during the steady-state phase.\n\"rec\" : Discharge rate is calculated at recruitment.\n\"derec\" : Discharge rate is calculated at derecruitment.\n\"rec_derec\" : Discharge rate is calculated at recruitment and derecruitment.\n\"steady\" : Discharge rate is calculated during the steady-state phase.\n</code></pre> </li> <li> <p>Once you press the <code>Compute discharge rate</code> button, the discharge rate will be calculated. </p> </li> <li>The discharge rate for each inluded MU in the analysis file at the stated event as well a for all the contraction will be displayed in the <code>Result Output</code> of the GUI. </li> <li>You can edit or copy any value in the <code>Result Output</code>, however, you need to close the top-level <code>Motor Unit Properties Window</code> first.</li> </ol>"},{"location":"gui_basics/#basic-motor-unit-properties","title":"Basic Motor Unit Properties","text":"<p>Subsequently to specifying the MVC, you can calculate a number of basic MUs properties with one click. These include</p> <ul> <li>The absolute/relative recruitment/derecruitment thresholds</li> <li>The discharge rate at recruitment, derecruitment, during the steady-state phase and during the entire contraction</li> <li>The individual and average accuracy</li> <li>The coefficient of variation of interspike interval</li> <li>The coefficient of variation of force signal</li> </ul> <p>and are all displayed in the <code>Result Output</code> once the analysis in completed. </p> <ol> <li>Specify the number of firings at recruitment and derecruitment to consider for the calculation of discharge rate in the <code>Firings at Rec</code> textbox. </li> <li> <p>Enter the number of firings over which to calculate the discharge rate at the start and end of the steady-state phase in the <code>Firings Start/End Steady</code> textbox. For example,</p> <pre><code>Firings at Rec: 4\nFirings Start/End Steady: 10\n</code></pre> </li> <li> <p>The basic MUs properties will be displayed in the <code>Result Output</code> of the GUI. </p> </li> <li>You can edit or copy any value in the <code>Result Output</code>, however, you need to close the top-level <code>Motor Unit Properties Window</code> first.</li> </ol>"},{"location":"gui_basics/#plot-motor-units","title":"Plot Motor Units","text":"<p>In openhdemg we have implemented options to plot your analysis file ... a lot of options! Upon clicking the <code>Plot MUs</code> button, the <code>Plot Window</code> will pop up. In the top right corner of the window, you can find an information button forwarding you directly to this tutorial. </p> <p></p> <p>You can choose between the follwing plotting options:</p> <ul> <li>Plot the raw emg signal. Single or multiple channels. (Plot EMGSig)</li> <li>Plot the reference signal. (Plot RefSig)</li> <li>Plot all the MUs pulses (binary representation of the firings time). (Plot MUPulses)</li> <li>Plot the decomposed source. (Plot Source)</li> <li>Plot the instantaneous discharge rate (IDR). (Plot IDR)</li> <li>Plot the differential derivation of the raw emg signal by matrix column. (Plot Derivation)</li> <li>Plot motor unit action potentials (MUAPs) obtained from spike-triggered average (STA) from one or multiple MUs. Please note that for Delsys files, the displayed MUAPs are those computed in the Delsys software and not those obtained via STA. (Plot MUAPs)</li> </ul> <p>Prior to plotting you can optionally select a few options on the left side of the <code>Plot Window</code>. </p> <ol> <li>When you want the reference signal to be displayed in the plots you can select the <code>Reference Signal</code> checkbox in row one and column two in the left side of the <code>Plot Window</code>. </li> <li>You can specify wheter you want the x-axis of the plots to be scaled in seconds by selecting the <code>Time in seconds</code> checkbox in row two and column two in the left side of the <code>Plot Window</code>. </li> <li> <p>You can change the size of the plot as well, by inputting your prefered height and width in the <code>Figure in size in cm (h,w)</code> textbox in row three and column two in the left side of the <code>Plot Window</code>. For example, if you want your plot to have a height of 6 and a width of 8, your input should look like this</p> <pre><code>Figure in size in cm (h,w): 6,8\n</code></pre> </li> </ol> <p>These three setting options are universally used in all plots. There are two more specification options on the right side of the <code>Plot Window</code> only relevant when using the <code>Plot Derivation</code> or <code>Plot MUAP</code> buttons. </p> <ol> <li> <p>The <code>Matrix Code</code> must be specified in row one and column four in the right side of the <code>Plot Window</code> according to the one you used during acquisition. So far, implemented codes are:</p> <ul> <li><code>Custom order</code></li> <li><code>None</code></li> <li><code>GR08MM1305</code></li> <li><code>GR04MM1305</code></li> <li><code>GR10MM0808</code></li> <li><code>Trigno Galileo Sensor</code></li> </ul> <p>In case you selected <code>Custom order</code>, you must also specify the custom order in the GUI settings. Please refer to this tutorial for further instructions on how to do so.</p> <p>In case you selected <code>None</code>, the entrybox <code>Rows, Columns</code> will appear. Please specify the number of rows and columns of your used matrix since you now bypass included matrix codes. In example, specifying</p> <p><pre><code>Rows, Columns: 13, 5\n</code></pre> means that your File has 65 channels organised over 13 rows and 5 columns.</p> </li> <li> <p>If you selected one of the built-in sorting orders (e.g., <code>GR08MM1305</code>, <code>GR04MM1305</code>, <code>GR10MM0808</code>), you need to specify also the <code>Orientation</code> in row two and column four in the left side of the <code>Plot Window</code>. The <code>Orientaion</code> must match the one of your matrix during acquisition. You can find a reference image for the <code>Orientation</code> at the bottom in the right side of the <code>Plot Window</code>. <code>Orientation</code> is ignored when <code>Matrix Code</code> is <code>None</code>, <code>Custom order</code> or <code>Trigno Galileo Sensor</code>.</p> </li> </ol>"},{"location":"gui_basics/#plot-raw-emg-signal","title":"Plot Raw EMG Signal","text":"<ol> <li>Click the <code>Plot EMGsig</code> button in row four and column one in the left side of the <code>Plot Window</code>, to plot the raw emg signal of your analysis file. </li> <li>Enter or select a <code>Channel Number</code> in / from the dropdown list. For example, if you want to plot <code>Channel Number</code> one enter 0 in the dropdown. If you want to plot <code>Channel Numbers</code> one, two and three enter 0,1,2 in the dropdown. </li> <li>Once you have clicked the <code>Plot EMGsig</code> button, a pop-up plot will appear. </li> </ol>"},{"location":"gui_basics/#plot-reference-signal","title":"Plot Reference Signal","text":"<ol> <li>Click the <code>Plot RefSig</code> button in row five and column one in the left side of the <code>Plot Window</code>, to plot the reference signal. </li> <li>Once you have clicked the <code>Plot RefSig</code> button, a pop-up plot will appear. </li> </ol>"},{"location":"gui_basics/#plot-motor-unit-pulses","title":"Plot Motor Unit Pulses","text":"<ol> <li>Click the <code>Plot MUpulses</code> button in row six and column one in the left side of the <code>Plot Window</code>, to plot the single pulses of the MUs in your analysis file.</li> <li>Enter/select a pulse <code>Linewidth</code> in/from the dropdown list. For example, if you want to use a <code>Linewidth</code> of one, enter 1 in the dropdown. </li> <li>Once you have clicked the <code>Plot MUpulses</code> button, a pop-up plot will appear. </li> </ol>"},{"location":"gui_basics/#plot-the-decomposed-source","title":"Plot the Decomposed Source","text":"<ol> <li>Click the <code>Plot Source</code> button in row seven and column one in the left side of the <code>Plot Window</code>, to plot the Source of the decomposed MUs in your analysis file. </li> <li>Enter/select a <code>MU Number</code> in/from the dropdown list. For example, if you want to plot the source for <code>MU Number</code> one enter 0 in the dropdown. If you want to plot the sources for <code>MU Number</code> one, two and three enter 0,1,2, in the dropdown. You can also set <code>MU Number</code> to \"all\" to plot the sources for all included MUs in the analysis file.</li> <li>Once you have clicked the <code>Plot Source</code> button, a pop-up plot will appear. </li> </ol>"},{"location":"gui_basics/#plot-instanteous-discharge-rate","title":"Plot Instanteous Discharge rate","text":"<ol> <li>Click the <code>Plot IDR</code> button in row eight and column one in the left side of the <code>Plot Window</code>, to plot the IDR of the MUs in your analysis file. </li> <li>Enter/select a <code>MU Number</code> in/from the dropdown list. For example, if you want to plot the IDR of <code>MU Number</code> one enter 0 in the dropdown. If you want to plot the IDR of <code>MU Number</code> one, two and three enter 0,1,2 in the dropdown. You can also set <code>MU Number</code> to \"all\" to plot the IDR of all included MUs in the analysis file.</li> <li>Once you have clicked the <code>Plot IDR</code> button, a pop-up plot will appear. </li> </ol>"},{"location":"gui_basics/#plot-differential-derivation","title":"Plot Differential Derivation","text":"<ol> <li>Click the <code>Plot Derivation</code> button in row four and column three in the right side of the <code>Plot Window</code>, to plot the differential derivation of the MUs in your analysis file. </li> <li>Specify the <code>Configuration</code> for the calculation first. You can choose from:<ul> <li><code>Single differential</code> (Calculate single differential of raw signal on matrix rows)</li> <li><code>Double differential</code>(Calculate double differential of raw signal on matrix rows)</li> </ul> </li> <li>Specify the respective <code>Matrix Column</code> you want to plot. You can choose one from the <code>Matrix Column</code> dropdown list. </li> <li>Once you have clicked the <code>Plot Derivation</code> button, a new pop-up plot appears. </li> </ol>"},{"location":"gui_basics/#plot-motor-unit-action-potentials","title":"Plot Motor Unit Action Potentials","text":"<ol> <li>Click the <code>Plot MUAPs</code> button in row five and column three in the right side of the <code>Plot Window</code>, you can plot the action potential of the MUs in your analysis file. </li> <li>Specify the <code>Configuration</code> for  calculation first. You can choose from:<ul> <li><code>Monopolar</code></li> <li><code>Single differential</code> (Calculate single differential of raw signal on matrix rows)</li> <li><code>Double differential</code>(Calculate double differential of raw signal on matrix rows)</li> </ul> </li> <li>Specify the respective <code>MU Number</code> you want to plot. You can choose one from the <code>MU Number</code> dropdown list. </li> <li>Specify the <code>Timewindow</code> of the plots. You can choose from the <code>Timewindow</code> dropdown list or enter any integer. </li> <li>Once you have clicked the <code>Plot MUAPs</code> button, a new pop-up plot appears.</li> </ol> <p>Please note, if you are using the Delsys decomposition outcome, the plotted MUAPs will be those calculated bu the Delsys software.</p>"},{"location":"gui_basics/#saving-your-analysis-file","title":"Saving Your Analysis File","text":"<p>Subsequently to analysing your emg-file in the openhdemg GUI, it is beneficial to save it. Otherwise, all changes will be lost when the GUI is closed. </p> <ol> <li>Click the <code>Save File</code> button in row two and column two in the left side of the main window. </li> <li>Specify a filename and a location and confirm! That's it!</li> </ol>"},{"location":"gui_basics/#saving-your-analysis-results","title":"Saving Your Analysis Results","text":"<p>Some analyses included in the openhdemg GUI return values that are displayed in the <code>Result Output</code> of the GUI. Of course, you can simply copy-paste them, but it might be more convenient to directly save your analysis results. Additionally, all the values in the <code>Results Output</code> will be overwritten by new analyses or deleted in case of closing the GUI. </p> <ol> <li>click the <code>Save Results</code> button in row two and column two in the left side of the main window. </li> <li>Specify a location where to save the file and confirm. You can find the file there with the name of your analysis file. </li> </ol>"},{"location":"gui_basics/#resetting-your-analysis","title":"Resetting Your Analysis","text":"<p>We all make mistakes! But, most likely, we are also able to correct them. In case you have made a mistake in the analysis of your emgfile in the openhdemg GUI, we have implemented a reset button for you. Click the <code>Reset Analysis</code> button in row eight and column two in the lef side of the main window to  reset any analysis you previously performed since opening the GUI and inputting an analysis file. Your analysis file is reset to the original file and all the changes are discarded. So, no need to be perfect!</p> <p>If you want to proceed to the advanced stuff now, take a look at the advanced tab on the left side of the webpage.</p>"},{"location":"gui_basics/#more-questions","title":"More questions?","text":"<p>We hope that this tutorial was useful. If you need any additional information, do not hesitate to read the answers or ask a question in the openhdemg discussion section. If you are not familiar with GitHub discussions, please read this post. This will allow the openhdemg community to answer your questions.</p> <p>Moreover, if you noticed an error that was not properly catched by the GUI, please report the issue.</p>"},{"location":"gui_intro/","title":"Graphical Interface","text":"<p>Welcome, to the openhdemg Graphical User Interface (GUI) introduction! </p> <p>The openhdemg GUI incorporates all relevant high-level functions of the openhdemg library. The GUI allows you to successfully perform High-Density Electromyography (HD-EMG) data anlysis without any programming skills required. Moreover, there is no downside to using the GUI even if you are an experienced programmer.</p> <p>The GUI can be simply accessed from the command line with:</p> <pre><code>python -m openhdemg.gui.openhdemg_gui\n</code></pre> <p>Let us shortly walk you through the main window of the GUI. An image of the starting page of the GUI is displayed below.</p> <p></p> <p>This is your starting point for every analysis. On the left hand side you can find all the entryboxes and buttons relevant for the analyses you want to perform. In the middle you can see the plotting canvas where plots of the HD-EMG data analysis are displayed. On the right hand side you can find information buttons leading you directly to more information, tutorials, and more. Very important, at the top of this section, there is the settings icon (Gear icon). By clicking this icon, you will be able to change some of the GUI settings. Finally, at the bottom of the GUI there is a window used to display the results of the analyses. </p>"},{"location":"gui_intro/#specifying-an-analysis-file","title":"Specifying an analysis file","text":"<ol> <li> <p>In order to load file into the GUI, you first need to select something in the Type of file dropdown box at the top left corner. The available filetypes are:</p> <ul> <li><code>OPENHDEMG</code> (emgfile or reference signal stored in .json format)</li> <li><code>DEMUSE</code> (.mat file used in DEMUSE)</li> <li><code>OTB</code> (.mat file exportable by OTBiolab+)</li> <li><code>OTB_REFSIG</code> (Reference signal in the .mat file exportable by OTBiolab+)</li> <li><code>DELSYS</code> (.mat and .txt files exportable by Delsys software)</li> <li><code>DELSYS_REFSIG</code> (.mat file exportable by Delsys software)</li> <li><code>CUSTOMCSV</code> (custom data from a .csv file)</li> <li><code>CUSTOMCSV_REFSIG</code> (Reference signal in a custom .csv file)</li> </ul> <p>Each filetype corresponds to a distinct datatype that should match the file you want to analyse. So, select the <code>Type of file</code> corresponding to the type of your file.</p> </li> <li> <p>Before loading a file, verify that the GUI settings are correct for your needs.</p> </li> <li> <p>To actually load the file, click the Load File button and select the file you want to analyse. In case of occurence, follow the error messages and repeat this and the previos step.</p> </li> <li> <p>Once the file is successfully loaded, the specifications of the file you want to analyse will be displayed next to the Load File button. </p> </li> </ol>"},{"location":"gui_intro/#viewing-an-analysis-file","title":"Viewing an analysis file","text":"<p>It doesn't get any simpler than this! </p> <p>Once a file is successfully loaded as described above, a plot containing your data should appear in the middle section of the GUI, allowing you to view the content of your file. This can also be force by clicking the <code>View MUs</code> button.</p> <p>In the two sections above, we described the two most rudimental functions in the GUI. To learn more about basic and more advanced analysis features of the GUI, check out the basic and advanced chapters.</p>"},{"location":"gui_intro/#more-questions","title":"More questions?","text":"<p>We hope that this tutorial was useful. If you need any additional information, do not hesitate to read the answers or ask a question in the openhdemg discussion section. If you are not familiar with GitHub discussions, please read this post. This will allow the openhdemg community to answer your questions.</p>"},{"location":"gui_settings/","title":"Settings","text":"<p>Since the release of version 0.1.0-beta.4, we have introduced GUI settings. These allow you to customise functions behaviour when using the GUI, making it more flexible and adaptable to specific users needs.</p>"},{"location":"gui_settings/#access-gui-settings","title":"Access GUI settings","text":"<p>Accessing these GUI settings is simple: just click on the Gear icon located at the top-right corner of the GUI window.</p> <p></p> <p>Upon clicking the settings icon, a Python file will open in your default text editor. Here, you'll be able to modify the settings according to your requirements.</p> <p>Always remember to save the Python settings file after changing the variables, or the changes will not be effective.</p> <p>If the Python file does not open, please read the Troubleshooting section.</p>"},{"location":"gui_settings/#modify-gui-settings","title":"Modify GUI settings","text":"<p>The GUI settings file (named settings.py) is organised into distinct topic sections.</p> <p>All the variables that can be modified are labelled as:</p> <ul> <li>Name of the calling function + _ _ + Name of the variable</li> </ul> <p>In this way, the values that each variable can assume can be discovered from the API section of this website by navigating into the topic, then into the Name of the function and then looking at the specific variable.</p> <p>The variables that can be modified from the GUI settings, as well as their values, can differ between different openhdemg releases. Therefore, the user is always encouraged to check the specifics APIs, and not to rely on this guide, which only serves didactical purposes.</p>"},{"location":"gui_settings/#openfiles","title":"openfiles","text":"<p>The first section is named openfiles and controls how files are loaded into openhdemg or saved in .json format.</p> <p>The API section for this topic is here.</p> <p>For example, the GUI behaviour when loading Custom .csv files can be adjusted in the following code snippet:</p> <pre><code># in emg_from_customcsv()\nemg_from_customcsv__ref_signal = \"REF_SIGNAL\"\nemg_from_customcsv__raw_signal = \"RAW_SIGNAL\"\nemg_from_customcsv__ipts = \"IPTS\"\nemg_from_customcsv__mupulses = \"MUPULSES\"\nemg_from_customcsv__binary_mus_firing = \"BINARY_MUS_FIRING\"\nemg_from_customcsv__accuracy = \"ACCURACY\"\nemg_from_customcsv__extras = \"EXTRAS\"\nemg_from_customcsv__fsamp = 2048\nemg_from_customcsv__ied = 8\n</code></pre> <p>In the first line of code, emg_from_customcsv__ref_signal = \"REF_SIGNAL\" indicates that the variable ref_signal belonging to the function emg_from_customcsv is set to \"REF_SIGNAL\".</p> <p>The complete documentation of the function emg_from_customcsv() can be accessed here. Reading the specific APIs, you will always know what parameters can be passed to each variable!</p> <p>Similarly, the GUI behaviour when saving .json files can be adjusted in the following code snippet:</p> <pre><code># in save_json_emgfile()\nsave_json_emgfile__compresslevel = 4\n</code></pre> <p>And the corresponding APIs can be accessed here.</p>"},{"location":"gui_settings/#analysis","title":"analysis","text":"<p>The section named analysis controls how basic MUs properties (i.e., MUs recruitment/derecruitment thresholds, discharge rate and accuracy measures) are calculated.</p> <p>The API section for this topic is here.</p> <p>For example, in the following code snippet we can adjust how many firings are used to calculate the recruitment/derecruitment thresholds or how the accuracy measure is computed.</p> <pre><code># in basic_mus_properties()\nbasic_mus_properties__n_firings_rt_dert = 1\nbasic_mus_properties__accuracy = \"default\"\nbasic_mus_properties__ignore_negative_ipts = False\nbasic_mus_properties__constrain_pulses = [True, 3]\n</code></pre> <p>The corresponding APIs for the function basic_mus_properties can be accessed here.</p>"},{"location":"gui_settings/#tools","title":"tools","text":"<p>The section named tools controls additional functionalities that are necessary for the usability of the library. The functions contained in this section can be considered as \"tools\" or shortcuts necessary to operate with the HD-EMG recordings.</p> <p>The API section for this topic is here.</p> <p>For example, in the following code snippet we can adjust how to resize the emgfile and how to deal with the accuracy measure in the new resized file.</p> <pre><code># in resize_emgfile()\nresize_emgfile__how = \"ref_signal\"\nresize_emgfile__accuracy = \"recalculate\"\nresize_emgfile__ignore_negative_ipts = False\n</code></pre> <p>The corresponding APIs for the function resize_emgfile can be accessed here.</p>"},{"location":"gui_settings/#pic","title":"pic","text":"<p>The section named pic controls the Persistent Inward Currents estimation.</p> <p>The API section for this topic is here.</p> <p>For example, in the following code snippet we can adjust how to estimate Delta F.</p> <pre><code>compute_deltaf__recruitment_difference_cutoff = 1.0\ncompute_deltaf__corr_cutoff = 0.7\ncompute_deltaf__controlunitmodulation_cutoff = 0.5\n</code></pre> <p>The corresponding APIs for the function compute_deltaf can be accessed here.</p>"},{"location":"gui_settings/#muap","title":"muap","text":"<p>The section named muap controls all the functionalities that require MU action potentials. Currently, it controls the behaviour of functionalities such as MU tracking, duplicate removal and conduction velocity estimation, among others.</p> <p>The API section for this topic is here.</p> <p>For example, in the following code snippet we can adjust how to perform MU tracking. As you might have noticed using the GUI, it is already possibile to specify many parameters for MU tracking directly in the GUI, and these settings here offer an additional level of customisability.</p> <pre><code># in tracking()\ntracking__firings = \"all\"\ntracking__derivation = \"sd\"\n</code></pre> <p>The corresponding APIs for the function tracking can be accessed here.</p>"},{"location":"gui_settings/#electrodes","title":"electrodes","text":"<p>The section named electrodes allows to specify a custom order for electrodes sorting. The sorting order is used any time the grid channels need to be oriented in a specific manner, wich usually reflects how the operator positioned the grid on the skin. A number of common sorting orders are already present the library. However, if the needed sorting order is not available, the user can specify any custom order in this section. This allows for maximum flexibility of the sorting functionalities.</p> <p>The API section for this topic is here.</p> <p>In the following example, we show how the sorting order of a grid can be obtained and specified.</p> <p>Here you can see the channels order as displayed on the grid. This example refers to the commercially available grid GR08MM1305.</p> <pre><code>Channel Order GR08MM1305\n       0   1   2   3   4\n0     64  39  38  13  12\n1     63  40  37  14  11\n2     62  41  36  15  10\n3     61  42  35  16   9\n4     60  43  34  17   8\n5     59  44  33  18   7\n6     58  45  32  19   6\n7     57  46  31  20   5\n8     56  47  30  21   4\n9     55  48  29  22   3\n10    54  49  28  23   2\n11    53  50  27  24   1\n12    52  51  26  25 NaN\n</code></pre> <p>As you can see, this grid of electrodes is composed of 5 columns (from 0 to 4) and 13 rows (from 0 to 12) for a total of 64 channels. Given that the channels are represented in a quadrilateral structure, one channels will result empty.</p> <p>Given that Python is in base 0, we first need to convert the channels in base 0, with the final matrix looking like this:</p> <pre><code>Channel Order in base 0\n       0   1   2   3   4\n0     63  38  37  12  11\n1     62  39  36  13  10\n2     61  40  35  14   9\n3     60  41  34  15   8\n4     59  42  33  16   7\n5     58  43  32  17   6\n6     57  44  31  18   5\n7     56  45  30  19   4\n8     55  46  29  20   3\n9     54  47  28  21   2\n10    53  48  27  22   1\n11    52  49  26  23   0\n12    51  50  25  24 NaN\n</code></pre> <p>After the conversion from base 1 to base 0, we can proceed creating a list of lists, where each internal list represents a column of the grid, as follows:</p> <pre><code>custom_sorting_order = [\n    [63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52,     51],\n    [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,     50],\n    [37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26,     25],\n    [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,     24],\n    [11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0, np.nan],\n]\n</code></pre> <p>The empty channel can be indicated with np.nan, which stands for \"not a number\". Similarly, we can mark more missing channels with the same approach.</p> <pre><code>custom_sorting_order = [\n    [63, 62, 61,     60, 59, 58, np.nan, 56, 55, 54, 53, 52,     51],\n    [38, 39, 40,     41, 42, 43,     44, 45, 46, 47, 48, 49,     50],\n    [37, 36, 35,     34, 33, 32,     31, 30, 29, 28, 27, 26,     25],\n    [12, 13, 14,     15, 16, 17,     18, 19, 20, 21, 22, 23,     24],\n    [11, 10,  9, np.nan,  7,  6,      5,  4,  3,  2,  1,  0, np.nan],\n]\n</code></pre>"},{"location":"gui_settings/#what-variables-can-be-modified","title":"What variables can be modified?","text":"<p>Please note that only the variables present in the settings.py file can be modified. If you would like to modify additional variables, please get in touch with us.</p> <p>Additionally, you cannot remove the unused variables from the settings file! You can only modify their value.</p>"},{"location":"gui_settings/#restore-gui-settings","title":"Restore GUI settings","text":"<p>If you accidentally modify some variables and the GUI stops working properly, you can restore the original settings by copying and pasting the content of the backup_settings.py file. This will be visible in the file explorer of your editor next to the settings.py file.</p>"},{"location":"gui_settings/#troubleshooting","title":"Troubleshooting","text":""},{"location":"gui_settings/#the-settings-dont-show-up","title":"The settings don't show up","text":"<p>If clicking the Gear icon doesn't open the settings.py file, it might be because your operating system doesn't recognize the .py file extension. This can happen if you've never opened a Python file before. To solve this:</p> <ol> <li> <p>Double-click on any Python file (do this from outside Visual Studio Code, or it will take care of the process and your operating system will not associate the Python file to a specific software).</p> </li> <li> <p>A window should prompt you to choose which software to use to open the file.</p> </li> <li> <p>Select Visual Studio Code and set it as the default application for .py files.</p> </li> <li> <p>After doing this, try restarting the openhdemg GUI and Visual Studio Code. The Gear icon should now function correctly.</p> </li> </ol> <p>If the issue persists, please continue reading.</p>"},{"location":"gui_settings/#locate-the-settingspy-file","title":"Locate the settings.py file","text":"<p>If the settings.py file does not open after clicking on the Gear icon, you can still manually navigate to this file and change the settings. The settings.py file can be accessed navigating the file explorer of your editor (usually on the left side of Visual Studio Code).</p> <p>In your file explorer, navigate as follows:</p> <ol> <li> <p>Click on your virtual environment folder</p> </li> <li> <p>Click on Lib</p> </li> <li> <p>Click on openhdemg</p> </li> <li> <p>Click on gui</p> </li> <li> <p>Here you will find the settings.py file. Double click it and edit the settings as needed.</p> </li> <li> <p>Save the file</p> </li> </ol>"},{"location":"gui_settings/#changes-are-not-effective","title":"Changes are not effective","text":"<p>Always remember to save the Python settings file after changing the variables, or the changes will not be effective. It is not necessary to restart the GUI when changes are made to the settings.py file.</p>"},{"location":"gui_settings/#more-questions","title":"More questions?","text":"<p>We hope that this tutorial was useful. If you need any additional information, do not hesitate to read the answers or ask a question in the openhdemg discussion section. If you are not familiar with GitHub discussions, please read this post. This will allow the openhdemg community to answer your questions.</p>"},{"location":"isek_jek_tutorials/","title":"ISEK-JEK Tutorials","text":"<p>Welcome to the page dedicated to our dissemination activity with the International Society of Electrophysiology and Kinesiology (ISEK) and the Journal of Electromyography and Kinesiology (JEK).</p> <p></p>"},{"location":"isek_jek_tutorials/#jek-tutorial-article","title":"JEK Tutorial article","text":"<p>Tutorial: analysis of central and peripheral motor unit properties from decomposed High-Density surface EMG signals with openhdemg.</p> <p>https://doi.org/10.1016/j.jelekin.2023.102850</p> <p>Here you can find the manuscript, published open access and freely available to anybody, along with all the up-to-date material necessary to follow the tutorial article using openhdemg.</p> <p>You can download the sample files and the sample scripts here. We hope you find this work useful. If that's the case, please cite it in your research; it will help us continue the development of openhdemg.</p> <p>Dowload files \u00a0 </p> <p></p> <p> <p></p> <p> </p>"},{"location":"isek_jek_tutorials/#2024-isek-workshop","title":"2024 ISEK Workshop","text":"<p>Workshop: Simplified analysis of motor unit properties with openhdemg.</p> <p>On the 26<sup>th</sup> of June 2024, we will present the openhdemg framework at the ISEK congress, which will be held in Nagoya, Japan.</p> <p>Below, you can find a preliminary design of the workshop and the fantastic speakers who will participate. We look forward to seeing you there!</p> <p>More info will come soon.</p> <p></p> <p>Click on the image for full-screen mode</p> <p></p>"},{"location":"quick-start/","title":"Quick-Start","text":"<p>Let's implement together, step-by-step, a script to analyse all the relevant motor units' (MUs) properties.</p> <p>In particular, we will go through:</p> <ol> <li>Install opendemg</li> <li>Load a file</li> <li>Visualise the content of the file</li> <li>Edit the reference signal</li> <li>Remove unwanted MUs</li> <li>Analyse fundamental MUs properties</li> <li>Save the edited file and the results of the analysis</li> </ol>"},{"location":"quick-start/#1-install","title":"1. Install","text":"<p>openhdemg can be easily installed using pip:</p> <pre><code>pip install openhdemg\n</code></pre> <p>or conda:</p> <pre><code>conda install -c conda-forge openhdemg\n</code></pre> <p>Once the installation of openhdemg is succesfull, you can install all the required packages from the reqirements.txt file.</p>"},{"location":"quick-start/#2-load-a-file","title":"2. Load a file","text":"<p>Before calling the functions contained in the openhdemg library, we need to import it. This can be done as:</p> <pre><code>import openhdemg.library as emg\n</code></pre> <p>Great, we are now ready to exploit all the functionalities of the library!</p> <p></p> <p>In this example, we will use the sample file provided with openhdemg.</p> <p>This can be simply loaded calling the function emg_from_samplefile.</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file\nemgfile = emg.emg_from_samplefile()\n</code></pre> <p>emgfile is organised as a Python dictionary and contains different elements (which are labelled by keys).</p> <p>For a full list of keys contained in the emgfile refer to the openfiles documentation.</p> <p>Each element in the emgfile can be accessed as <code>emgfile[\"element\"]</code>.</p> <p>So, if we want to access, for example, the reference signal, we can use <code>emgfile[\"REF_SIGNAL\"]</code>.</p>"},{"location":"quick-start/#3-visualise-the-content-of-the-file","title":"3. Visualise the content of the file","text":"<p>Now that we loaded the emgfile, we can inspect its content.</p> <p>As we said above, there are different elements in the emgfile and we can visualise both their type and their content with 2 lines of code:</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file\nemgfile = emg.emg_from_samplefile()\n\n# Print type\nprint(type(emgfile[\"REF_SIGNAL\"]))\n\n# Print content\nprint(emgfile[\"REF_SIGNAL\"])\n\n\n\"\"\" Output\n&lt;class 'pandas.core.frame.DataFrame'&gt;\n              0\n0     -0.159466\n1     -0.139630\n2     -0.099957\n3     -0.080121\n4     -0.060284\n...         ...\n66555 -0.337994\n66556 -0.318158\n66557 -0.298321\n66558 -0.318158\n66559 -0.318158\n\"\"\"\n</code></pre> <p>As you can see from the printed output, the reference signal is contained in a pandas DataFrame with 1 column (column 0).</p> <p>This is an extremely important information if you want to manipulate the content of the emgfile although it is outside the scope of this Quick-Start tutorial.</p> <p>Apart from accessing the numerical values, we can also plot them.</p> <p>In this case we are interested in visualising the MUs firing times together with the reference signal. This can be done with the function plot_mupulses.</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file\nemgfile = emg.emg_from_samplefile()\n\n# Plot MUs firing times and ref signal\nemg.plot_mupulses(emgfile=emgfile)\n</code></pre> <p></p> <p>Looks good, but I would rather have the MUs ordered by recruitment order and also with thinner lines!</p> <p>We can do that with the function sort_mus and changing the parameters in plot_mupulses.</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file\nemgfile = emg.emg_from_samplefile()\n\n# Sort MUs based on recruitment order\nemgfile = emg.sort_mus(emgfile=emgfile)\n\n# Plot MUs firing times and ref signal\nemg.plot_mupulses(emgfile=emgfile, linewidths=0.4)\n</code></pre> <p></p> <p></p> <p>Are you curious about the dicharge rate of the MUs? You can view that with the function plot_idr.</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file\nemgfile = emg.emg_from_samplefile()\n\n# Sort MUs based on recruitment order\nemgfile = emg.sort_mus(emgfile=emgfile)\n\n# Plot MUs instantaneous discharge rate\nemg.plot_idr(emgfile=emgfile)\n</code></pre> <p></p>"},{"location":"quick-start/#4-edit-the-reference-signal","title":"4. Edit the reference signal","text":"<p>The MUs look quite good; however, the reference signal is a bit noisy and the offset is not to 0.</p> <p>The noise can be removed filtering the reference signal with the function filter_refsig that, by default, applies a 4<sup>th</sup> order, zero-lag, low-pass Butterworth filter with a cutoff frequency of 15 Hz.</p> <p>Instead, the offset can be removed with the function remove_offset that automatically detects the offset based on a number of samples at the beginning of the recording.</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file\nemgfile = emg.emg_from_samplefile()\n\n# Sort MUs based on recruitment order\nemgfile = emg.sort_mus(emgfile=emgfile)\n\n# Filter the ref signal\nemgfile = emg.filter_refsig(emgfile=emgfile)\n\n# Remove the offset based on the first 1024 samples (that corresponds to 0.5\n# seconds when sampling the signal at 2048 Hz).\nemgfile = emg.remove_offset(emgfile=emgfile, auto=1024)\n\n# Plot MUs instantaneous discharge rate\nemg.plot_idr(emgfile=emgfile)\n</code></pre> <p></p>"},{"location":"quick-start/#5-remove-unwanted-mus","title":"5. Remove unwanted MUs","text":"<p>There might be cases in which we need to remove one or more MUs from our emgfile.</p> <p>From the visual inspection of our plots, we can see that the firings pattern of MU number 2 (remember, Python is in base 0!!!) is not really regular. We might therefore have doubts about its quality.</p> <p>A way to assess the quality of the MUs is to look at the separation between the signal and the noise. This is efficiently measured by accuracy scores.</p> <p>This score is automatically calculated while importing the emgfile and can be easily accessed as <code>emgfile[\"ACCURACY\"]</code>. In our sample file, the accuracy is calculated by the Silhouette (SIL) score (Negro 2016).</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file\nemgfile = emg.emg_from_samplefile()\n\n# Print the SIL score\nprint(emgfile[\"ACCURACY\"])\n\n\"\"\"Output\n          0\n0  0.899082\n1  0.919601\n2  0.879079\n3  0.917190\n4  0.955819\n\"\"\"\n</code></pre> <p>Our suspicion was right, MU number 2 has the lowest accuracy score.</p> <p>In order to remove this MU, we can use the function delete_mus.</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file\nemgfile = emg.emg_from_samplefile()\n\n# Sort MUs based on recruitment order\nemgfile = emg.sort_mus(emgfile=emgfile)\n\n# Filter the ref signal\nemgfile = emg.filter_refsig(emgfile=emgfile)\n\n# Remove the offset based on the first 1024 samples (that corresponds to 0.5\n# seconds when sampling the signal at 2048 Hz).\nemgfile = emg.remove_offset(emgfile=emgfile, auto=1024)\n\n# Remove MU number 2\nemgfile = emg.delete_mus(emgfile=emgfile, munumber=2)\n\n# Plot MUs instantaneous discharge rate\nemg.plot_idr(emgfile=emgfile)\n</code></pre> <p></p>"},{"location":"quick-start/#6-analyse-fundamental-mus-properties","title":"6. Analyse fundamental MUs properties","text":"<p>Now that we removed the unwanted MUs and adjusted the reference signal, we can proceed with the analysis of some fundamental MUs properties like the thresholds of recruitment and derecruitment and the discharge rate.</p> <p>In the past, this used to require many lines of code, but thanks to openhdemg, we can now do that with 1 line of code using the function basic_mus_properties.</p> <p>After calling the function basic_mus_properties, the user will be asked to select the start and the end of the steady-state phase. This can be done positioning the mouse on the desired point and then pressing a keybord key (such as 'a'). To remove points, right click with your mouse.</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file\nemgfile = emg.emg_from_samplefile()\n\n# Sort MUs based on recruitment order\nemgfile = emg.sort_mus(emgfile=emgfile)\n\n# Filter the ref signal\nemgfile = emg.filter_refsig(emgfile=emgfile)\n\n# Remove the offset based on the first 1024 samples (that corresponds to 0.5\n# seconds when sampling the signal at 2048 Hz).\nemgfile = emg.remove_offset(emgfile=emgfile, auto=1024)\n\n# Remove MU number 2\nemgfile = emg.delete_mus(emgfile=emgfile, munumber=2)\n\n# Calculate all the basic MUs propertis.\n# Specify maximum voluntary contraction in Newtons.\nresults = emg.basic_mus_properties(\n    emgfile=emgfile,\n    mvc=634,\n)\n\nprint(results)\n\n\"\"\"\n     MVC  MU_number  ACCURACY  avg_ACCURACY      abs_RT    abs_DERT  \\\n0  634.0          0  0.899082      0.922923   30.621759   36.168135  \n1    NaN          1  0.919601           NaN   32.427026   31.167703  \n2    NaN          2  0.917190           NaN   68.371911   67.308703  \n3    NaN          3  0.955819           NaN  118.504004  102.761472  \n\n       rel_RT   rel_DERT    DR_rec  DR_derec  DR_start_steady  DR_end_steady  \\\n0    4.829930   5.704753  7.548770  5.449581        11.788779      10.401857  \n1    5.114673   4.916041  8.344515  5.333535        11.254445       9.999033  \n2   10.784213  10.616515  5.699017  3.691367         9.007505       7.053079  \n3   18.691483  16.208434  5.701081  4.662196         7.393645       6.430807  \n\n   DR_all_steady     DR_all  COVisi_steady  COVisi_all  COV_steady\n0      11.154952  10.693076       6.833642   19.104306    1.422424\n1      10.751960  10.543011       8.364553   15.408739         NaN\n2       8.168471   7.949294      10.097045   23.324503         NaN\n3       6.908502   6.814687      11.211862   16.319474         NaN\n\"\"\"\n</code></pre>"},{"location":"quick-start/#7-save-the-results-and-the-edited-file","title":"7. Save the results and the edited file","text":"<p>It looks like we got a lot of results, which makes of it extremely inefficient to copy them manually.</p> <p>Obviously, this can be automated using one attribute of the results object and we can conveniently save all the results in a .csv file.</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file\nemgfile = emg.emg_from_samplefile()\n\n# Sort MUs based on recruitment order\nemgfile = emg.sort_mus(emgfile=emgfile)\n\n# Filter the ref signal\nemgfile = emg.filter_refsig(emgfile=emgfile)\n\n# Remove the offset based on the first 1024 samples (that corresponds to 0.5\n# seconds when sampling the signal at 2048 Hz).\nemgfile = emg.remove_offset(emgfile=emgfile, auto=1024)\n\n# Remove MU number 2\nemgfile = emg.delete_mus(emgfile=emgfile, munumber=2)\n\n# Calculate all the basic MUs propertis.\n# Specify maximum voluntary contraction in Newtons.\nresults = emg.basic_mus_properties(\n    emgfile=emgfile,\n    mvc=634,\n)\n\n# Save the results to a .csv file.\n# Remember to change this path to a real path!\nresults.to_csv(\"C:/Users/.../Desktop/Results.csv\")\n</code></pre> <p>Our results are now safe but, additionally, we might want to save also the emgfile with all the changes that we made. This can be easily done with the function asksavefile that will save your emgfile in the open standard JSON file format which has a better integration with Python and has a very high cross-platform compatibility.</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file\nemgfile = emg.emg_from_samplefile()\n\n# Sort MUs based on recruitment order\nemgfile = emg.sort_mus(emgfile=emgfile)\n\n# Filter the ref signal\nemgfile = emg.filter_refsig(emgfile=emgfile)\n\n# Remove the offset based on the first 1024 samples (that corresponds to 0.5\n# seconds when sampling the signal at 2048 Hz).\nemgfile = emg.remove_offset(emgfile=emgfile, auto=1024)\n\n# Remove MU number 2\nemgfile = emg.delete_mus(emgfile=emgfile, munumber=2)\n\n# Calculate all the basic MUs propertis.\n# Specify maximum voluntary contraction in Newtons.\nresults = emg.basic_mus_properties(\n    emgfile=emgfile,\n    mvc=634,\n)\n\n# Save the results to a .csv file.\n# Remember to change this path to a real path!\nresults.to_csv(\"C:/Users/.../Desktop/Results.csv\")\n\n# Save the edited emgfile\nemg.asksavefile(emgfile=emgfile)\n</code></pre>"},{"location":"quick-start/#8-important-notes","title":"8. Important notes","text":"<p>As you have seen, openhdemg makes it really easy to analyse MUs properties but please, don't think that what you saw in this tutorial is all you can do with this powerful framework.</p> <p>We invite you to read the API reference section to understand how you can customise all the functions present in the library.</p>"},{"location":"what%27s-new/","title":"Release notes","text":""},{"location":"what%27s-new/#010","title":"0.1.0","text":"<p> June 2024</p> <p>This release is aimed at expanding the functionalities of the library with new and improved analysis tools. It also marks the exit from the beta phase!</p>"},{"location":"what%27s-new/#backward-compatibility","title":"Backward Compatibility","text":"<p>This version is fully backward compatible with v0.1.0-beta.3 and 4.</p>"},{"location":"what%27s-new/#major-achievements","title":"Major Achievements","text":"<ul> <li>More functionalities</li> </ul>"},{"location":"what%27s-new/#major-changes","title":"Major Changes","text":"<ul> <li> <p>New modules:</p> <ul> <li>With this release, we introduce the module <code>pic</code>. A module dedicated to Persistent Inward Currents estimation. It now allows to estimate PICs via Delta F and will be enriched with new functionalities in the near future.</li> </ul> </li> <li> <p>New classes:</p> <ul> <li>The class <code>Tracking_gui</code> provides a convenient interface for the visual inspection of the tracking results, improving the flexibility and accuracy of MUs tracking based on MUAPs shape.</li> </ul> </li> <li> <p>Updated classes:</p> <ul> <li>The class <code>MUcv_gui</code> has been optimised to reduce RAM memory usage and can now be expanded to full-screen. Furthermore, it now accepts custom separators for copying the results and pasting them into Excel (or any other text/tabular document).</li> </ul> </li> <li> <p>New functions:</p> <ul> <li>The function <code>compute_svr</code> allows to fit MU discharge rates with Support Vector Regression, nonlinear regression.</li> <li>The function <code>compute_deltaf</code> allows to quantify delta F via paired motor unit analysis.</li> <li>The function <code>plot_smoothed_dr</code> allows to visualise the smoothed discharge rate, with or without IDR and with or without stacking MUs.</li> </ul> </li> <li> <p>Updated functions:</p> <ul> <li>The functions <code>tracking()</code> and <code>remove_duplicates_between()</code> now allow to directly show the <code>Tracking_gui</code> after completing the tracking procedure for additional inspection of the results. They also allow to select whether to use parallel processing to improve execution speed.</li> <li>The functions <code>plot_muaps</code> and <code>plot_muaps_for_cv</code> now allow to use a tight layout for the output figure.</li> <li>The functions <code>compute_dr</code>, <code>compute_drvariability</code>, <code>compute_covisi</code> and <code>basic_mus_properties</code> now allow to exclude firings outside a custom range of frequencies.</li> </ul> </li> <li> <p>GUI updates:</p> <ul> <li>The openhdemg GUI allows access to the <code>Tracking_gui</code> during MUs tracking (not after duplicates removal) and to perform PICs estimation via the advanced tools window. It also allows tuning the behaviour of these functionalities through the settings window.</li> </ul> </li> </ul> <p></p>"},{"location":"what%27s-new/#010-beta4","title":"0.1.0-beta.4","text":"<p> April 2024 </p> <p>This release is aimed at increasing the robustness of the implemented functions and at improving the usability of the graphical user interface (GUI).</p>"},{"location":"what%27s-new/#backward-compatibility_1","title":"Backward Compatibility","text":"<p>This version is fully backward compatible (with v0.1.0-beta.3) although the PNR (pulse to noise ratio) estimation might slightly differ from the previous versions.</p>"},{"location":"what%27s-new/#major-achievements_1","title":"Major Achievements","text":"<ul> <li>Much faster</li> <li>More accurate</li> <li>More robust</li> <li>More user-friendly</li> </ul>"},{"location":"what%27s-new/#major-changes_1","title":"Major Changes","text":"<ul> <li> <p>Restyled, debugged and more flexible GUI:</p> <ul> <li>Almost all the functioning issues affecting the GUI have been solved. Enjoy a much better experience with this new release.</li> <li>New settings file: it is now possible to customise the functions behaviour directly from the GUI. This increases the number of possible analyses that can be performed from the GUI.</li> <li>New modern look</li> <li>Better responsiveness</li> <li>Expandable main window and figure</li> <li>New modular structure of the source code for easier implementation of new functionalities.</li> </ul> </li> <li> <p>Awesome performance improvements:</p> <ul> <li>The estimation of MUs conduction velocity is 96% faster compared to the previous implementation, making it suitable also for the estimation of global conduction velocity.</li> </ul> </li> <li> <p>New functions:</p> <ul> <li>The function <code>estimate_cv_via_mle</code> has been created to allow the user to estimate CV of any given signal with only 1 line of code.</li> </ul> </li> <li> <p>Updated functions:</p> <ul> <li>The function <code>compute_sil</code> has a new argument that allows to include or exclude negative source values from the SIL estimation. This increases the estimation robustness when the source has large negative components.</li> <li>The function <code>compute_pnr</code> has a new argument that allows to select whether to cluster firings/noise via a heuristic penalty function or by using the provided discharge times.</li> <li>It is now possible to specify how to estimate accuracy in <code>emg_from_demuse</code>, <code>emg_from_otb</code> and <code>basic_mus_properties</code> based on the new implementation of <code>compute_sil</code> and <code>compute_pnr</code>.</li> <li>The function <code>sort_rawemg</code> now allows to sort channels based on custom orders with a custom number of empty channels.</li> <li>The function <code>resize_emgfile</code> now allows to select the area to resize based on the reference signal or on the mean EMG signal.</li> <li>The function <code>delete_mus</code> now allows to delete also the MUAPs computed in the Delsys software (stored in emgfile[\u201cEXTRAS\u201d]) simultaneously with the removal of MUs firing. This is now the default in the GUI.</li> </ul> </li> <li> <p>New modules: With this release, we introduce dedicated test modules. These will progressively allow for automated extensive testing of the implemented functions and to exit the beta phase. Currently, test functions have been created for the <code>openfiles</code> module.</p> </li> </ul>"},{"location":"what%27s-new/#other-changes","title":"Other changes","text":"<ul> <li>It is now possible to pass OTB EXTRAS to the function <code>askopenfile</code>.</li> <li>Improved readability of the string values in the docstrings and in the online documentation.</li> </ul>"},{"location":"what%27s-new/#tutorials","title":"Tutorials","text":"<ul> <li>Added new troubleshooting in setup working env</li> <li>Added new tutorial explaining how to use the GUI settings</li> </ul>"},{"location":"what%27s-new/#010-beta3","title":"0.1.0-beta.3","text":"<p> November 2023</p> <p>This release is focused on expanding the range of supported input files (decomposition outcomes) and to increase the speed and efficiency of the code. Furthermore, the introduction of a new backward compatibility module brings openhdemg a step closer to exiting the beta phase.</p>"},{"location":"what%27s-new/#backward-compatibility_2","title":"Backward Compatibility","text":"<p>By default, the .json files saved from openhdemg version 0.1.0-beta.2 (released in September 2023) cannot be opened in openhdemg version 0.1.0-beta.3. However, these files can be easily converted to the newer file format thanks to the new backward compatibility module. We also created a tutorials section where the users are guided to the migration towards newer versions of the library. This will ensure easy migration to the latest openhdemg release.</p>"},{"location":"what%27s-new/#major-achievements_2","title":"Major Achievements","text":"<ul> <li>Extended input file compatibility: now supporting a wider range of input files, making it easily accessible to anybody.</li> <li>Much faster: Spend more time on research and less time with tools.</li> <li>Backward compatibility: enjoy a smooth transition without concerns about compatibility.</li> </ul>"},{"location":"what%27s-new/#major-changes_2","title":"Major Changes","text":"<ul> <li> <p>Support for Delsys decomposition outcome: users of the 4 pin Galileo sensors can now directly open and analyze their motor units in openhdemg. This will expand the user base of the openhdemg framework.</p> <ul> <li>New function <code>emg_from_delsys</code> to load the Delsys decomposition outcome.</li> <li>New function <code>refsig_from_delsys</code> to load the reference signal from Delsys.</li> <li>New function <code>extract_delsys_muaps</code> to use the MUAPs computed during Delsys decomposition wherever the MUAPs are necessary.</li> </ul> </li> <li> <p>Awesome performance improvements:</p> <ul> <li>The <code>save_json_emgfile</code> function has been modified, and it is now possible to adjust the level of compression of the output file. It is now up to 90-95% faster than the previous implementation, with the output file 50% smaller than before and 50% smaller than the corresponding file in .mat format. This will facilitate and promote the adoption of the openhdemg file format.</li> <li>The <code>emg_from_json</code> function has been modified, and you can now load files 55% faster than the previous implementation. This will facilitate and promote the adoption of the openhdemg file format.</li> <li>The function <code>emg_from_demuse</code> can now load files 25 to 50% faster than the previous implementation. This will promote the use of other file sources in the openhdemg framework.</li> <li>The functions performing spike-triggered averaging (<code>sta</code> and <code>st_muap</code>) have been optimized and are now 95% faster. This allows for a faster execution of all the functions requiring the MU action potential shape.</li> </ul> </li> <li> <p>Backward compatibility: we introduced a dedicated module to ensure backward compatibility starting from this version and going forward. This will permit any user to easily migrate to newer versions of the library.</p> </li> </ul>"},{"location":"what%27s-new/#other-changes_1","title":"Other Changes","text":"<ul> <li>90% Faster execution of the function <code>create_binary_firings</code>.</li> <li>Support for arrays: The various functions using MUAPs now support also grids with only one column (arrays of electrodes). This is predisposing openhdemg to interface also with arrays and not only with grids.</li> <li>MUs conduction velocity estimation now allows to set the size of the figure to make it as large and easy to see as you wish. It also returns which column and rows have been used to estimate conduction velocity. The functions used to estimate conduction velocity will undergo a major optimisation in the next releases to make them faster and more flexible.</li> <li>When calculating recruitment and derecruitment thresholds with the functions <code>compute_thresholds</code> and <code>basic_mus_properties</code>, it is now possible to calculate the thresholds as the average value of n firings.</li> </ul>"},{"location":"what%27s-new/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed a bug in the <code>emg.info().data()</code> function that crashed when called with CUSTOMCSV file sources.</li> <li>Class docstrings can now be accessed directly from Visual Studio Code.</li> </ul>"},{"location":"what%27s-new/#tutorials_1","title":"Tutorials","text":"<p>Added new tutorials explaining:</p> <ul> <li>How to export your decomposed files to directly load them in openhdemg.</li> <li>How to use the backward compatibility module to easily migrate to the newer openhdemg releases.</li> <li>In the tutorial \u201cSetup working environment,\u201d we specified that openhdemg is currently working with Python up to the 3.11.x version. We are working to make it compatible with Python 3.12.</li> </ul> <p></p>"},{"location":"what%27s-new/#010-beta2","title":"0.1.0-beta.2","text":"<p> September 2023</p> <p>This release is mainly addressing the necessity of maximum flexibility and easy integration with any custom or proprietary file source. This release is not backward compatible.</p>"},{"location":"what%27s-new/#major-changes_3","title":"Major changes","text":"<ul> <li> <p>Accuracy Measurement: Replaced the double accuracy measures in the <code>emgfile</code> (i.e., \u201cSIL\u201d and \u201cPNR\u201d) with a single accuracy measure named \u201cACCURACY.\u201d For files containing the decomposed source (also named \u201cIPTS\u201d), the \u201cACCURACY\u201d variable will contain the silhouette score (Negro et al. 2016). For files that do not contain the decomposed source, the accuracy will be the original (often proprietary) accuracy estimate. This allows for maximum flexibility and is fundamental to interface the openhdemg library with any proprietary and custom implementation of the different decomposition algorithms currently available.</p> <p>To accommodate this change, all the functions in the <code>openfile</code> module have been updated. Consequently, the functions using the \u201cSIL\u201d or \u201cPNR\u201d variables have also been modified. Specifically:</p> <ul> <li>The <code>basic_mus_properties</code> function has a new input parameter (i.e., \u201caccuracy\u201d) to customize the returned accuracy estimate.</li> <li>In the function <code>remove_duplicates_between</code>, the input parameter \u201cwhich\u201d now only accepts \u201cmunumber\u201d and \u201caccuracy\u201d instead of \u201cmunumber,\u201d \u201cSIL,\u201d and \u201cPNR.\u201d</li> </ul> </li> <li> <p>EXTRAS Variable: Introduced a new \u201cEXTRAS\u201d variable to store any custom information in the opened file. This will be accessible in the <code>emgfile</code> dictionary with the \u201cEXTRAS\u201d key. This variable must contain a pd.DataFrame structure and will be preserved when saving the file. This change extends the customisability of the <code>emgfile</code>.</p> </li> <li> <p>Handling Missing Variables: Replaced \u201cnp.nan\u201d with empty \"pd.DataFrame\u201d for missing variables upon import of files. This change ensures consistency and avoids compatibility issues with other functions.</p> </li> <li> <p>File Import Restriction: Restricted flexibility in the import of files. To import decomposed HD-EMG files, these must contain at least the raw EMG signal and one of the times of discharge of each MU (\"MUPULSES\") or their binary representation. This change ensures consistency and avoids compatibility issues with other functions.</p> </li> </ul>"},{"location":"what%27s-new/#other-changes_2","title":"Other changes","text":"<ul> <li> <p>Sampling Frequency and Interelectrode Distance: Sampling frequency and interelectrode distance are now represented by float point values to accommodate different source files.</p> </li> <li> <p><code>emg_from_customcsv</code> and <code>emg_from_otb</code>: Improved robustness and flexibility, with the possibility to load custom information in \u201cEXTRAS.\u201d</p> </li> <li> <p><code>emg_from_demuse</code>: Improved robustness and flexibility.</p> </li> <li> <p>New Functions:  </p> <ul> <li><code>refsig_from_customcsv</code> to load the reference signal from a custom .csv file.</li> <li><code>delete_empty_mus</code> to delete all the MUs without firings.</li> </ul> </li> <li> <p>Exposed Function: Exposed <code>mupulses_from_binary</code> to extract the times of firing from the binary representation of MUs firings.</p> </li> <li> <p>Dependency Management: Addressed reported functioning issues related to external dependencies invoked by openhdemg. Stricter rules have been adopted in the setup.py file for automatically installing the correct version of these dependencies.</p> </li> </ul>"},{"location":"what%27s-new/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Fixed a BUG in the GUI when saving results in Excel files. The bug was due to changes in newer pandas versions.</li> <li>Fixed a BUG in the function \u201csort_mus\u201d when empty MUs were present.</li> </ul>"},{"location":"what%27s-new/#010-beta1","title":"0.1.0-beta.1","text":"<p> June 2023</p> <p>What's new? Well, everything. This is our first release, if you are using it, congratulations, you are a pioneer!</p> <p>Please note, this is a beta release, which means that a lot can change in this version and the library is not yet ready to be used without double-checking the results that you get.</p>"},{"location":"about-us/complete-roadmap/","title":"Complete roadmap","text":"<pre><code>graph TB;\n    A[Development] --&gt; B(Feedback from beta test)\n    B --&gt; C(Stable release v0.1)\n    C --&gt; D(Continuous updates)\n    E[Engagement] --&gt; F(Reach)\n    E[Engagement] --&gt; G(Outreach)\n    E[Engagement] --&gt; H(New contributors)\n    F --&gt; I(Feedback)\n    G --&gt; I(Feedback)\n    I --&gt; D\n    H --&gt; D\n    D --&gt; L(Release v1.0)</code></pre> <p>A roadmap is a collection of planned milestones and tasks that are necessary for the successful development and growth of the openhdemg project. It outlines the key steps and objectives that need to be achieved to meet the project's goals and deliver value to the community. The roadmap drives the project's evolution, ensuring that efforts are focused, organized, and aligned with the overall vision.</p> <p>Milestones represent significant achievements and tasks are the actionable steps to reach those milestones. They provide a structured approach to project planning and execution, tracking progress and ensuring systematic completion. The roadmap is flexible, allowing us to incorporate users feedback and refine the plan based on community input.</p>"},{"location":"about-us/complete-roadmap/#milestones","title":"Milestones","text":"<p>Legend for milestones status:</p> <p> \u00a0 Completed</p> <p> \u00a0 Ongoing </p> <p> \u00a0 Planned date</p> <p>At this stage, we have identified and set six major milestones for the openhdemg project. These milestones are divided into two categories: three on the development side and three on the engagement side.</p>"},{"location":"about-us/complete-roadmap/#development-milestones","title":"Development milestones","text":"<p>The development milestones focus on advancing the framework's functionality, improving existing features, and introducing new algorithms and analysis techniques. These milestones aim to enhance the capabilities and performance of openhdemg, providing a more powerful and comprehensive tool for analyzing High-Density Electromyography (HD-EMG) recordings.</p> <p>Going public </p> <p>On 04/07/2023 the openhdemg project was released to the public with a beta release on PyPI, a public GitHub repository, a website and a Twitter page. This milestone marks the beginning of openhdemg as an open-source project.</p> <p>Stable release v0.1 </p> <p>Planned by end of 2023. While a beta release is meant for testing purpose, a stable release represents the transition to a production-ready version of the framework. The primary objective of this milestone is to ensure the reliability, robustness, and usability of openhdemg for a wide range of users.</p> <p>Release v1.0 </p> <p>The release of Version 1.0 is undoubtedly the most significant achievement for an open-source project like openhdemg, signifying a substantial enhancement in the project's completeness and usability. With this release, the project has achieved a level of maturity that fulfills the needs of a wide range of users in the field of HD-EMG.</p>"},{"location":"about-us/complete-roadmap/#engagement-milestones","title":"Engagement milestones","text":"<p>On the engagement side, the milestones aim to enhance the reach and outreach of openhdemg and to bring new contributors in the project. These milestones focus on expanding the visibility and impact of openhdemg within the HD-EMG community and beyond.</p> <p>Reach 1 </p> <p>Planned by end of 2023. By leveraging preferred channels such as Twitter and congresses, we aim to engage with new individuals and organizations interested in HD-EMG analysis. Target to complete 'Reach 1' = 100 Twitter followers.</p> <p>Outreach 1 </p> <p>Planned by end of 2023. This milestone involves improving documentation, providing tutorials and educational resources, and enhancing user support. By achieving these milestones, we aim to empower users with the knowledge and tools they need to effectively utilize openhdemg and conduct their own HD-EMG analyses. Target to complete 'Outreach 1' = cover all the functionalities of the openhdemg framework with specific tutorials.</p> <p>Increase contributors 1 </p> <p>Bringing new contributors to the openhdemg project is fundamental to increase the functionalities of the framework and to build a collaborative community of experts. Target to complete 'Increase contributors 1' = 5 external contributors</p>"},{"location":"about-us/complete-roadmap/#tasks","title":"Tasks","text":""},{"location":"about-us/complete-roadmap/#development-tasks","title":"Development tasks","text":"<p>Stable release v0.1</p> <ul> <li>Identify and address any critical bugs or issues reported during the beta testing phase.</li> <li>Conduct extensive testing on different platforms and configurations to ensure the stability and reliability of the framework.</li> <li>Incorporate user feedback and suggestions to improve the user interface, features, and overall user experience.</li> <li>Create comprehensive documentation for installation, usage, and troubleshooting of openhdemg.</li> </ul> <p>Release v1.0</p> <ul> <li>Enhance the framework's performance and efficiency to handle larger datasets and complex analyses.</li> <li>Implement additional algorithms and analysis techniques to broaden the capabilities of openhdemg.</li> <li>Conduct thorough testing and validation of the framework's functionalities to ensure accuracy and reliability.</li> <li>Document and communicate the major updates and improvements in the release to the user community.</li> </ul>"},{"location":"about-us/complete-roadmap/#engagement-tasks","title":"Engagement tasks","text":"<p>Reach 1</p> <ul> <li>Develop a social media strategy for openhdemg, including regular posting, engaging with relevant hashtags, and connecting with HD-EMG researchers and practitioners.</li> <li>Share success stories, case studies, and relevant content about openhdemg on Twitter to attract a wider audience and increase followers.</li> <li>Actively participate in HD-EMG-related congresses, conferences, and events to network with professionals in the field and promote openhdemg.</li> </ul> <p>Outreach 1</p> <ul> <li>Create comprehensive tutorials and educational resources that cover various aspects of HD-EMG analysis using openhdemg.</li> <li>Improve the documentation to provide clear instructions, examples, and explanations of the framework's functionalities.</li> <li>Establish a user support system, such as a forum or mailing list and promote the use of the openhdemg discussion section.</li> </ul> <p>Increase contributors 1</p> <ul> <li>Actively encourage contributions from the community by creating a contributor-friendly environment and providing guidance on how to get involved.</li> <li>Identify specific areas where external contributors can make meaningful contributions, such as implementing new algorithms, improving existing features, or conducting performance optimizations.</li> <li>Collaborate with potential contributors through issue discussions, pull request reviews, and effective communication channels to onboard them into the openhdemg community.</li> </ul>"},{"location":"tutorials/convert_old_json_files/","title":"Convert old .json files","text":"<p>As openhdemg evolves and introduces new features, migrating to the latest version becomes essential for leveraging optimized functions and improved capabilities. However, it is not always possible to implement new or optimized functionalities without altering the utilized data structure.</p> <p>When the data structure is changed, the users of previous versions of openhdemg will not be able to access the newer functionalities with the files they saved in the older data structure. To overcome this limitation, we created the <code>convert_json_output</code> class which facilitates a seamless transition by converting older .json files to the format compatible with the latest openhdemg version.</p> <p>This tutorial guides you through the process, ensuring a smooth upgrade while maintaining data integrity.</p> <p>Why should you convert your files to the newer openhdemg versions?</p> <ul> <li>Optimized Functionality: Newer openhdemg versions come with optimized functions, enhancing performance and providing a more efficient user experience.</li> <li>Compatibility: Ensure your data remains compatible with the latest features and improvements introduced in openhdemg.</li> </ul>"},{"location":"tutorials/convert_old_json_files/#from-010-b2-to-010-b3","title":"From 0.1.0-b2 to 0.1.0-b3","text":"<p>The openhdemg version 0.1.0-beta.3 introduced noticeable changes and improvements, particularly regarding the speed of saving and loading of .json files. Furthermore, these files are efficiently compressed, so that they occupy less space in your storage. However, to achieve this goal, it was necessary to optimise the default data structure used by openhdemg and, as a consequence, the newer openhdemg version is not compatible with the files saved from previous openhdemg versions.</p> <p>In this section of the tutorial we explain how to easily convert the files you saved from openhdemg version 0.1.0-beta.2 to make them compatible with openhdemg version 0.1.0-beta.3.</p> <p>The class necessary to perform this conversion is stored in the conversions module inside the compatibility subpackage and can be imported as</p> <pre><code># Import the necessary libraries\nfrom openhdemg.compatibility import convert_json_output\n</code></pre> <p>With this class, we can select different methods for converting our files.</p> <p>Let's start from the easiest one. Indeed, we can convert one file (or perform a batch conversion of multiple files) with a simple graphical user interface (GUI). If you want to convert one file, select the desired file, if you want to convert more files, select more of them.</p> <pre><code># Import the necessary libraries\nfrom openhdemg.compatibility import convert_json_output\n\n# Convert file/s appending \"converted\" to the name of the converted file.\nconvert_json_output(gui=True, append_name=\"converted\")\n</code></pre> <p>Alternatively, you can perform the tasks without GUI. In the following example you will convert all the files in a folder and save them in the same location with a different name.</p> <pre><code># Import the necessary libraries\nfrom openhdemg.compatibility import convert_json_output\n\n# Specify the path to the folder where the original files are and where the\n# converted ones should be.\nold = \"C:/Users/.../test conversions/\"\nnew = \"C:/Users/.../test conversions/\"\n\n# Convert them\nconvert_json_output(\n    old=old,\n    new=new,\n    append_name=\"converted\",\n    gui=False,\n)\n</code></pre> <p>For more options, please refer to the documentation of the convert_json_output class.</p>"},{"location":"tutorials/convert_old_json_files/#more-questions","title":"More questions?","text":"<p>We hope that this tutorial was useful. If you need any additional information, do not hesitate to read the answers or ask a question in the openhdemg discussion section. If you are not familiar with GitHub discussions, please read this post. This will allow the openhdemg community to answer your questions.</p>"},{"location":"tutorials/emgfile_structure/","title":"Structure of the emgfile","text":""},{"location":"tutorials/emgfile_structure/#what-is-the-emgfile","title":"What is the emgfile","text":"<p>The <code>emgfile</code> is the basic data structure of the openhdemg framework. In practical terms, it is a Python object containing all the information of the decomposed HD-EMG file loaded in the working environment via the dedicated openhdemg functions.</p> <p>For example:</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file and assign it to the emgfile object\nemgfile = emg.emg_from_samplefile()\n</code></pre> <p>Loads the decomposed sample file provided with openhdemg and assigns its content to the object <code>emgfile</code>.</p>"},{"location":"tutorials/emgfile_structure/#structure-of-the-emgfile","title":"Structure of the emgfile","text":"<p>The <code>emgfile</code> has a simple structure. Indeed, it is a Python dictionary with keys:</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file and assign it to the emgfile object\nemgfile = emg.emg_from_samplefile()\n\n# Visualise the type of the emgfile\nprint(type(emgfile))\n\n\"\"\"Output\n&lt;class 'dict'&gt;\n\"\"\"\n\n# Visualise the keys of the emgfile dictionary\nprint(emgfile.keys())\n\n\"\"\"Output\ndict_keys(['SOURCE', 'FILENAME', 'RAW_SIGNAL', 'REF_SIGNAL', 'ACCURACY', 'IPTS', 'MUPULSES', 'FSAMP', 'IED', 'EMG_LENGTH', 'NUMBER_OF_MUS', 'BINARY_MUS_FIRING', 'EXTRAS'])\n\"\"\"\n</code></pre> <p>That means that the <code>emgfile</code> contains the following keys (or variables, in simpler terms):</p> <ul> <li>\"SOURCE\" : source of the file (i.e., \"CUSTOMCSV\", \"DEMUSE\", \"OTB\", \"DELSYS\")</li> <li>\"FILENAME\" : the name of the original file</li> <li>\"RAW_SIGNAL\" : the raw EMG signal</li> <li>\"REF_SIGNAL\" : the reference signal</li> <li>\"ACCURACY\" : accuracy score (depending on source file type)</li> <li>\"IPTS\" : pulse train (decomposed source)</li> <li>\"MUPULSES\" : instants of firing</li> <li>\"FSAMP\" : sampling frequency</li> <li>\"IED\" : interelectrode distance</li> <li>\"EMG_LENGTH\" : length of the emg file (in samples)</li> <li>\"NUMBER_OF_MUS\" : total number of MUs</li> <li>\"BINARY_MUS_FIRING\" : binary representation of MUs firings</li> <li>\"EXTRAS\" : additional custom values</li> </ul> <p>Each key has a specific content and structure that will be presented in the next code block.</p> <p>It must be noted that some of these keys might be empty (e.g., absence of a reference signal) and, therefore, the specific content of each key must be assessed from case to case. This can be simply done taking advantage of the info class:</p> <pre><code># Import the library with the short name 'emg'\nimport openhdemg.library as emg\n\n# Load the sample file and assign it to the emgfile object\nemgfile = emg.emg_from_samplefile()\n\n# Obtain info on the content of the emgfile\ninfo = emg.info()\ninfo.data(emgfile)\n\n\"\"\"Output\nData structure of the emgfile\n-----------------------------\n\nemgfile type is:\n&lt;class 'dict'&gt;\n\nemgfile keys are:\ndict_keys(['SOURCE', 'FILENAME', 'RAW_SIGNAL', 'REF_SIGNAL', 'ACCURACY', 'IPTS', 'MUPULSES', 'FSAMP', 'IED', 'EMG_LENGTH', 'NUMBER_OF_MUS', 'BINARY_MUS_FIRING', 'EXTRAS'])\n\nAny key can be acced as emgfile[key].\n\nemgfile['SOURCE'] is a &lt;class 'str'&gt; of value:\nOTB\n\nemgfile['FILENAME'] is a &lt;class 'str'&gt; of value:\notb_testfile.mat\n\nMUST NOTE: emgfile from OTB has 64 channels, from DEMUSE 65 (includes empty channel).\nemgfile['RAW_SIGNAL'] is a &lt;class 'pandas.core.frame.DataFrame'&gt; of value:\n              0          1          2          3          4          5          6          7          8   ...         55         56         57         58         59         60         61         62         63\n0      10.172526   5.086263  12.715657  11.189778   9.155273   8.138021   9.155273  13.224284   2.034505  ...   7.120768   6.612142  10.172526   8.138021  10.681152   2.034505  14.750163   4.577637  11.698405\n1      14.750163   8.138021  12.715657  12.715657  10.681152   6.612142  13.732910  16.276041   3.051758  ...   4.577637   3.560384  11.698405   7.120768  10.681152   0.508626  10.681152   4.069010  11.698405\n2       6.103516   1.017253   6.103516  15.767415   6.103516   3.051758   6.103516  11.698405   2.034505  ...   1.525879   1.525879   3.560384  -1.017253   4.069010  -4.577637   8.138021  -1.525879   5.086263\n3      -3.051758  -7.120768  -3.051758   4.577637  -4.069010  -8.138021  -2.543132   2.543132  -7.120768  ...  -8.646647  -9.155273  -3.560384  -9.155273  -6.103516 -13.732910  -1.017253 -11.698405  -2.543132\n4     -11.189778 -15.767415 -15.767415  -5.086263 -11.698405 -13.732910  -7.120768  -3.560384 -12.207031  ... -15.767415 -18.310547 -12.207031 -12.715657 -11.189778 -17.293295  -8.646647 -17.293295 -11.189778\n...          ...        ...        ...        ...        ...        ...        ...        ...        ...  ...        ...        ...        ...        ...        ...        ...        ...        ...        ...\n66555  11.189778  17.801920  16.276041  17.801920   2.034505  22.379557   8.646647  14.750163  14.750163  ...  -2.034505   0.508626   2.034505   2.034505  13.224284   0.000000  10.172526  10.172526  17.801920\n66556  12.715657  22.888184  21.362305  20.853678  10.172526  26.448568  12.207031  19.836426  16.276041  ...   2.034505   7.120768   4.577637   8.646647  14.241536   5.086263  18.819174  16.276041  16.276041\n66557   6.103516   7.120768  12.207031  12.715657   0.508626  16.276041   3.051758   9.663899   5.594889  ...  -5.594889  -1.525879  -6.103516  -1.525879   6.103516  -1.525879   7.629395   8.646647   8.646647\n66558  -9.663899  -9.663899  -7.120768  -7.629395 -14.241536  -1.017253 -14.750163  -7.629395 -10.681152  ... -23.905436 -17.801920 -22.888184 -20.853678 -10.681152 -17.801920 -13.224284  -8.646647  -9.155273\n66559   0.508626   1.017253   0.000000   4.577637  -2.543132   6.612142  -3.051758   1.525879  -2.034505  ... -12.715657  -6.612142 -14.750163 -10.172526   0.000000  -6.103516   1.017253  -3.051758  -2.543132\n\n[66560 rows x 64 columns]\n\nemgfile['REF_SIGNAL'] is a &lt;class 'pandas.core.frame.DataFrame'&gt; of value:\n              0\n0      1.640534\n1      1.660370\n2      1.700043\n3      1.719879\n4      1.739716\n...         ...\n66555  1.462006\n66556  1.481842\n66557  1.501679\n66558  1.481842\n66559  1.481842\n\n[66560 rows x 1 columns]\n\nemgfile['ACCURACY'] is a &lt;class 'pandas.core.frame.DataFrame'&gt; of value:\n          0\n0  0.879079\n1  0.955819\n2  0.917190\n3  0.899082\n4  0.919601\n\nemgfile['IPTS'] is a &lt;class 'pandas.core.frame.DataFrame'&gt; of value:\n                  0             1         2         3         4\n0     -1.208628e-04  3.242122e-09  0.000004  0.000186  0.000038\n1     -4.316778e-04 -8.801236e-05 -0.000053  0.000095 -0.000063\n2     -6.112677e-06 -1.158515e-04  0.000619 -0.000379  0.000035\n3      5.843681e-05 -1.308242e-05 -0.000033 -0.000001 -0.000168\n4      4.365258e-06  5.634868e-05 -0.000423 -0.000112  0.000001\n...             ...           ...       ...       ...       ...\n66555 -6.366898e-08  0.000000e+00  0.000000  0.000000  0.000000\n66556 -5.846209e-05  0.000000e+00  0.000000  0.000000  0.000000\n66557 -4.853265e-05  0.000000e+00  0.000000  0.000000  0.000000\n66558  1.100347e-05  0.000000e+00  0.000000  0.000000  0.000000\n66559  1.217465e-04  0.000000e+00  0.000000  0.000000  0.000000\n\n[66560 rows x 5 columns]\n\nemgfile['MUPULSES'] is a &lt;class 'list'&gt; of length depending on total MUs number.\nMUPULSES for each MU can be accessed as emgfile['MUPULSES'][MUnumber].\n\nemgfile['MUPULSES'][0] is a &lt;class 'numpy.ndarray'&gt; of value:\n[ 4990  6659  8310  8581  9424  9662  9905 10046 10200 10543 10762 11179\n 11469 11743 11973 12243 12580 12795 13038 13258 13396 13642 13890 14161\n 14357 14672 14975 15250 15564 15920 16281 16572 16837 17182 17321 17634\n 17973 18999 19388 19906 20178 20331 20523 20797 21020 21321 21705 21863\n 22190 22283 22656 23297 23397 23445 23598 24045 24206 24430 24678 24764\n 24982 25095 25277 25939 26581 26942 27652 28303 28515 28602 28893 29136\n 29363 30399 30604 31277 32005 32227 32780 33030 33255 33550 34239 34889\n 35261 37394 37932 38439 39061 39564 40393 41056 41919 43357 43742 44039\n 44335 44721 45182 45913 46083 46745 47076 47343 47635 47976 48147 48578\n 48880 49428 49742 49887 50516 50850 50957 51194 51350 51678 52110 52892\n 53161 53390 53795 54154 54386 54823 55032 55283 55653 56026 56282 56538\n 56931 57578 57871 58429 59077]\n\nemgfile['FSAMP'] is a &lt;class 'float'&gt; of value:\n2048.0\n\nemgfile['IED'] is a &lt;class 'float'&gt; of value:\n8.0\n\nemgfile['EMG_LENGTH'] is a &lt;class 'int'&gt; of value:\n66560\n\nemgfile['NUMBER_OF_MUS'] is a &lt;class 'int'&gt; of value:\n5\n\nemgfile['BINARY_MUS_FIRING'] is a &lt;class 'pandas.core.frame.DataFrame'&gt; of value:\n         0    1    2    3    4\n0      0.0  0.0  0.0  0.0  0.0\n1      0.0  0.0  0.0  0.0  0.0\n2      0.0  0.0  0.0  0.0  0.0\n3      0.0  0.0  0.0  0.0  0.0\n4      0.0  0.0  0.0  0.0  0.0\n...    ...  ...  ...  ...  ...\n66555  0.0  0.0  0.0  0.0  0.0\n66556  0.0  0.0  0.0  0.0  0.0\n66557  0.0  0.0  0.0  0.0  0.0\n66558  0.0  0.0  0.0  0.0  0.0\n66559  0.0  0.0  0.0  0.0  0.0\n\n[66560 rows x 5 columns]\n\nemgfile['EXTRAS'] is a &lt;class 'pandas.core.frame.DataFrame'&gt; of value:\nEmpty DataFrame\nColumns: [0]\nIndex: []\n\"\"\"\n</code></pre> <p>As you can see, <code>info.data(emgfile)</code> provides you with all the information regarding the content of the <code>emgfile</code>, on how it is structured and on how each element can be accessed. This information is crucial to interact with the <code>emgfile</code> and, understanding its structure, is fundamental to performed advanced customisation of the functions and to exploit the full flexibility/customisability of the openhdemg framework.</p> <p>Please take some time to learn this!</p>"},{"location":"tutorials/emgfile_structure/#alternative-structures-of-the-emgfile","title":"Alternative structures of the emgfile","text":"<p>At the moment, the only alternative to the basic <code>emgfile</code> structure is reserved for the loading of those files containing only the reference signal. This can be, for example, the case of the force signal used to calculate the maximum voluntary contraction (MVC) value.</p> <p>In this case, the <code>emg_refsig</code> is a Python dictionary with the following keys:</p> <ul> <li>\"SOURCE\": source of the file (i.e., \"CUSTOMCSV_REFSIG\", \"OTB_REFSIG\", \"DELSYS_REFSIG\")</li> <li>\"FSAMP\": sampling frequency</li> <li>\"REF_SIGNAL\": the reference signal</li> <li>\"EXTRAS\" : additional custom values</li> </ul>"},{"location":"tutorials/emgfile_structure/#modify-the-emgfile-to-fit-your-needs","title":"Modify the emgfile to fit your needs","text":"<p>This is a fundamental part of this tutorial. You can modify the <code>emgfile</code> as you wish, but there are 2 simple rules that must be followed to allow a seamless integration with the openhdemg functions.</p> <ol> <li>Do not alter the <code>emgfile</code> keys. You should not add or remove keys and you should not alter the data type under each key. If you need to do so, please remember that some of the built-in functions might not work anymore and you might encounter unexpected errors.</li> <li>Preserve data structures. If there is missing data you should fill the <code>emgfile</code> keys with the original data structure. The original data structure is the one presented in section Structure of the emgfile. For example, the reference signal is by default contained in a pd.DataFrame. Therefore, if the reference signal is absent, the dict key \"REF_SIGNAL\" should contain an empty pd.DataFrame.</li> </ol> <p>To modify the <code>emgfile</code> you can simply act as for modifying any Python dictionary:</p> <pre><code># Import the necessary libraries\nimport openhdemg.library as emg\n\nimport pandas as pd\nimport numpy as np\n\n# Load the sample file and assign it to the emgfile object\nemgfile = emg.emg_from_samplefile()\n\n# Visualise the keys of the emgfile dictionary\nprint(emgfile.keys())\n\n\"\"\"Output\ndict_keys(['SOURCE', 'FILENAME', 'RAW_SIGNAL', 'REF_SIGNAL', 'ACCURACY', 'IPTS', 'MUPULSES', 'FSAMP', 'IED', 'EMG_LENGTH', 'NUMBER_OF_MUS', 'BINARY_MUS_FIRING', 'EXTRAS'])\n\"\"\"\n\n# Visualise the original data structure contained in the 'REF_SIGNAL' key\nprint(type(emgfile['REF_SIGNAL']))\n\n\"\"\"Output\n&lt;class 'pandas.core.frame.DataFrame'&gt;\n\"\"\"\n\n# Replace the current 'REF_SIGNAL' with a random reference signal.\nrandom_data = np.random.randint(0 ,20, size=(emgfile['EMG_LENGTH'], 1))\nrand_ref = pd.DataFrame(random_data, columns=[0])\nemgfile['REF_SIGNAL'] = rand_ref\n\nprint(emgfile['REF_SIGNAL'])\n\n\"\"\"Output\n        0\n0       2\n1      15\n2      13\n3      18\n4       3\n...    ..\n66555  13\n66556  11\n66557  13\n66558   1\n66559   7\n\"\"\"\n</code></pre>"},{"location":"tutorials/emgfile_structure/#create-your-own-emgfile","title":"Create your own emgfile","text":"<p>openhdemg offers a number of built-in functions to load the data from different sources. However, there might be special circumnstances that require more flexibility. In this case, the user can create custom functions to load any type of decomposed HD-EMG files. However, in order to interact with the openhdemg functions, the <code>emgfile</code> loaded with any custom function must respect the original structure.</p> <p>In case your decomposed HD-EMG file does not contain a specific variable, you should mantain the original <code>emgfile</code> keys and the original data structure, although empty.</p>"},{"location":"tutorials/emgfile_structure/#more-questions","title":"More questions?","text":"<p>We hope that this tutorial was useful. If you need any additional information, do not hesitate to read the answers or ask a question in the openhdemg discussion section. If you are not familiar with GitHub discussions, please read this post. This will allow the openhdemg community to answer your questions.</p>"},{"location":"tutorials/import_from_other_software/","title":"Import from other software","text":"<p>openhdemg is designed to seamlessly interface with various software applications, enabling a smooth integration of data and workflows.</p> <p>In this article, we will explore how you can import EMG data from other software into openhdemg.</p> <p>The openhdemg team is committed to simplifying the data import process. Through continuous efforts, they regularly introduce new functions designed to automatically load files exported from third-party software. These efforts prioritize compatibility with the most commonly used software applications; however, it's important to note that the provided functions may not always fulfill every user's unique needs. If you cannot find a solution that fits your needs, you can always implement your own function to load any file with the openhdemg data structure. More info about the openhdemg data structure can be found in the tutorial Structure of the emgfile.</p>"},{"location":"tutorials/import_from_other_software/#from-csv-files","title":"From .csv files","text":"<p>Since it is not possible to predict any data format, we created dedicated functions to load any possible dataset from .csv files. Several considerations guided us in choosing the .csv format for loading custom files:</p> <ul> <li> <p>Ubiquitous Data Structure: .csv (Comma-Separated Values) stands out as one of the most widely used data structures in data analyses.</p> </li> <li> <p>Universal Export Compatibility: It can be exported from virtually any software, making it a versatile choice for compatibility with various data sources.</p> </li> <li> <p>Language and Software Agnosticism: .csv files can be read by any programming language, ensuring flexibility and ease of integration across diverse software environments, including popular tools like Microsoft Excel.</p> </li> <li> <p>Structured Layout: With its clear organization into columns and rows, .csv simplifies the storage of labeled information. This structured format not only enhances data interpretation but also facilitates seamless integration into analytical workflows.</p> </li> </ul> <p>Therefore, anybody developing scripts and algorithms for data analysis is familar with the .csv format. If you are not, just think that any table that you usually populate in Microsoft Excel, LibreOffice Calc, Google Sheets and many other tools, can be easily exported in .csv format.</p> <p>openhdemg currently has two functions dedicated to loading data from .csv files. Please refer to the API of the specific function to see what data your .csv file should contain to be opened in openhdemg:</p> <ul> <li>emg_from_customcsv(): This function is used to import the decomposition outcome from a custom .csv file.</li> <li>refsig_from_customcsv(): This function is used to import the reference signal from a custom .csv file.</li> </ul>"},{"location":"tutorials/import_from_other_software/#export-the-decomposition-outcome","title":"Export the decomposition outcome","text":"<p>The decomposition outcome can differ between decomposition algorithms and, therefore, the function emg_from_customcsv() is quite flexible, so that it can adapt to different user needs.</p> <p>However, some variables must always be present in the exported file. These include:</p> <ul> <li>The raw EMG signal.</li> <li>At least one of \"MUPULSES\" (instants of firing) or \"BINARY_MUS_FIRING\" (binary representation of MUs firings).</li> </ul> <p>If \"MUPULSES\" is absent, it will be calculated from \"BINARY_MUS_FIRING\" and viceversa.</p> <p>Other default variables that can be exported include:</p> <ul> <li>The reference signal.</li> <li>The decomposed source.</li> </ul> <p>All these variables should be stored in different columns because the import function detects the content of the .csv by parsing the .csv columns. When assigning a name to the columns, you can decide to simply use the openhdemg standard names or custom ones, as follows:</p> <p>Using the openhdemg standard names</p> <p>If you use openhdemg standard names for column labels, you won't need to specify these in the import function. Standard names include:</p> <ul> <li>Reference Signal: Label the column containing the reference signal \"REF_SIGNAL\".</li> <li>Raw EMG Signal: Label the columns containing the raw EMG signal with \"RAW_SIGNAL\" + channel number. For example, \"RAW_SIGNAL_0\", \"RAW_SIGNAL_1\", \"RAW_SIGNAL_2\", \"RAW_SIGNAL_n-1\".</li> <li>Pulse Train (decomposed source): Label the column(s) containing the decomposed source with \"IPTS\" + MU number. For example, \"IPTS_0\", \"IPTS_1\", \"IPTS_2\", \"IPTS_n-1\".</li> <li>Times of Firing (mupulses): Label the column(s) containing the times of firing with \"MUPULSES' + MU number. For example, \"MUPULSES_0\", \"MUPULSES_1\", \"MUPULSES_2\", \"MUPULSES_n-1\".</li> <li>Binary MUs Firing: Label the column(s) containing the binary representation of the MUs firings with \"BINARY_MUS_FIRING\" + MU number. For example, \"BINARY_MUS_FIRING_0\", \"BINARY_MUS_FIRING_1\", \"BINARY_MUS_FIRING_2\", \"BINARY_MUS_FIRING_n-1\".</li> <li>Accuracy Score: Label the column(s) containing the accuracy score of the MUs firings with \"ACCURACY\" + MU number. For example, \"ACCURACY_0\", \"ACCURACY_1\", \"ACCURACY_2\", \"ACCURACY_n-1\".</li> </ul> <p>Interestingly, this function allows also to import additional signals compared to what you saw before. Therefore, you could also export other signals together with what previously mentioned. Please note that files saved with \"extra\" information can only be loaded from the library (the use of \"EXTRAS\" is not supported in the graphical user interface) Please read the specific API for more information.</p> <ul> <li>Extras: Label the column containing custom values with \"EXTRAS\" or, if more columns are needed, with \"EXTRAS\" + n. For example, \"EXTRAS_0\", \"EXTRAS_1\", \"EXTRAS_2\", \"EXTRAS_n-1\".</li> </ul> <p>If some of the variables are not present, simply don't specify them in your .csv file.</p> <p>Once you structured your table in Excel or any other tool, you can easily save it as type: \"CSV (Comma delimited)\", and that's all it takes.</p> <p>Using custom names</p> <p>Obviously, you have the flexibility to decide any name you want for your columns. However, in this case, you should specify the label you used to describe each variable when calling the function emg_from_customcsv().</p> <p>Please remember that different representations of the same variable (e.g., the EMG signal from different channels or the accuracy of different MUs) must have the same basic label. For example, the column(s) containing the times of firing should be labeled with \"MYLABEL' + MU number (i.e., \"MYLABEL_0\", \"MYLABEL_1\", \"MYLABEL_2\", \"MYLABEL_n-1\").</p> <p>Although custom column labels can be used, the information that can be exported is the same described above in \"Using the openhdemg standard names\".</p> <p>If some of the possible variables are not present, simply don't specify them in your .csv file.</p> <p>Once you structured your table in Excel or any other tool, you can easily save it as type: \"CSV (Comma delimited)\", and that's all it takes.</p>"},{"location":"tutorials/import_from_other_software/#export-the-reference-signal","title":"Export the reference signal","text":"<p>In some cases, like for example for MVC trials, you might want to export only the reference signal. Exporting the reference signal is as simple as exporting a table with only one column. Also in this case, you can decide to label the column containing the refere signal with openhdemg standard names or with custom names. Please refer to the previous section for further details.</p> <p>Also the function refsig_from_customcsv() allows to import additional signals. Therefore, you could also export other signals together withthe reference signal. Please note that files saved with \"extra\" information can only be loaded from the library (the use of \"EXTRAS\" is not supported in the graphical user interface) and the parameter \"extras=\" must be specified when calling the function. Please read the specific API for more information and read the previous section of this tutorial.</p> <p>Once you structured your table in Excel or any other tool, you can easily save it as type: \"CSV (Comma delimited)\", and that's all it takes.</p>"},{"location":"tutorials/import_from_other_software/#from-demuse","title":"From DEMUSE","text":"<p>For years, DEMUSE has been the only commercially available tool for MUs decomposition non related to a specific acquisition device. DEMUSE is essentially a MATLAB-based application and it allows to export files in .mat format. Also in this case, it is quite easy to save files, as the only thing the user needs to do after decomposition and manual editing of the spike train, is to click: \"save results\".</p> <p>Once the results are saved, these can be loaded in openhdemg with the function:</p> <ul> <li>emg_from_demuse(): This function is used to import the decomposition outcome saved from the DEMUSE tool.</li> </ul>"},{"location":"tutorials/import_from_other_software/#from-otbiolab","title":"From OTBioLab+","text":"<p>OTBioLab+ is the software used to record EMG signals from the OTB \"Quattrocento\", \"Sessantaquattro+\" and other devices. However, it also allows to perform MUs decomposition and editing. Once the decomposition is done, the user can export the decomposition outcome in different file formats. Among them, the option to export .mat files is the one that provides the most convenient and easy way to export all the needed information.</p> <p>openhdemg currently has two functions dedicated to loading data from .mat files exported from OTBioLab+. Please refer to the API of the specific function for more information:</p> <ul> <li>emg_from_otb(): This function is used to import the decomposition outcome from a .mat file exported from the OTBioLab+ software.</li> <li>refsig_from_otb(): This function is used to import the reference signal from a .mat file exported from the OTBioLab+ software.</li> </ul> <p>Depending on whether you want to export all the decomposition outcome or only the reference signal, follow these steps:</p>"},{"location":"tutorials/import_from_other_software/#export-the-decomposition-outcome_1","title":"Export the decomposition outcome","text":"<p>Once the decomposition and manual editing is completed, the software saves the decomposition outcome in a new tab. The decomposition outcome includes:</p> <ul> <li>Binary firings: the binary representation of the MUs discharge times. This is usually named \"Decomposition of ...\".</li> <li>Decomposed source: the source signal used to detect the discharge times. This is usually named \"Source for decomposition ...\".</li> </ul> <p>Before exporting the decomposition outcome, copy in the new tab containing the decomposition outcome also:</p> <ul> <li>The EMG signal with all channels, without exception.</li> <li>The reference signal. This is usually named \"acquired data\".</li> </ul> <p>At this point:</p> <ol> <li>Select all the signals in the new tab (or a portion of them if that's all you need).</li> <li>Click on \"Export\".</li> <li>Click on \"As .mat file\".</li> <li>During the export process, you will be asked if you want to save the signal in different files. Click \"No\".</li> </ol> <p>Now that the .mat file has been created, it can be easily loaded in openhdemg with the function emg_from_otb().</p> <p>Interestingly, this function allows also to import additional signals compared to what you saw before. Therefore, you could also export other signals together with what previously mentioned. Please note that files saved with \"extra\" information can only be loaded from the library (the use of \"EXTRAS\" is not supported in the graphical user interface) and the parameter \"extras=\" must be specified when calling the function. Please read the specific API for more information.</p>"},{"location":"tutorials/import_from_other_software/#export-the-reference-signal_1","title":"Export the reference signal","text":"<p>In some cases, like for example for MVC trials, you might want to export only the reference signal. This can be simply done by:</p> <ol> <li>Select the reference signals, usually named \"acquired data\" (or a portion of it if that's all you need).</li> <li>Click on \"Export\".</li> <li>Click on \"As .mat file\".</li> </ol> <p>Now that the .mat file has been created, it can be easily loaded in openhdemg with the function refsig_from_otb().</p> <p>Interestingly, this function allows also to import additional signals. Therefore, you could also export other signals together withthe reference signal. Please note that files saved with \"extra\" information can only be loaded from the library (the use of \"EXTRAS\" is not supported in the graphical user interface) and the parameter \"extras=\" must be specified when calling the function. Please read the specific API for more information.</p>"},{"location":"tutorials/import_from_other_software/#from-delsys","title":"From Delsys","text":"<p>!!! Please note, the following two functions underwent limited testing. If they don't work, report to us the issue and we will try to make you load your files !!!</p> <p>Delsys has a number of software that can be used to record EMG signals from their acquisition systems. Additionally, some of them also allow to perform automatic MUs decomposition and some analyses.</p> <p>openhdemg currently has two functions dedicated to loading data from Delsys software. Please refer to the API of the specific function for more information:</p> <ul> <li>emg_from_delsys(): This function is used to import the decomposition outcome from the EMGworks and NeuroMap software.</li> <li>refsig_from_delsys(): This function is used to import the reference signal from the EMGworks software.</li> </ul> <p>Depending on whether you want to export all the decomposition outcome or only the reference signal, follow these steps:</p>"},{"location":"tutorials/import_from_other_software/#export-the-decomposition-outcome_2","title":"Export the decomposition outcome","text":"<p>For the raw EMG signal:</p> <ul> <li>Collect the data in EMGworks Analysis with the correct sensors settings to allow for decomposition in the NeuroMap software. (Correct sensor settings will be indicated by the NeuroMap symbol next to compatible options in the sampling rate, range, and bandwidth settings).</li> <li>The data will save as a .hpf file.</li> <li>Open the Delsys File Utility and convert the .hpf file to a .mat file.</li> <li>Ensure that you still have access to the original .hpf file for the decomposition process.</li> </ul> <p>For the decomposition outcome:</p> <ul> <li>Open the NeuroMap software.</li> <li>Import the .hpf file that was collected previously.</li> <li>Press decompose.</li> <li>This will produce a .dhpf file.</li> <li>Open the .dhpf file in NeuroMap Explorer.</li> <li>Export the files as .txt from the export options.</li> </ul> <p>At this point, you will have a .mat file containing the raw EMG signal and the reference signal, and a folder containing different .txt files. The .txt files contain the decomposition outcome, the MUAPs and some MUs statistics, including their accuracy score. Please, do not rename the .txt files or, if you rename them, do not alter the ending identifier (e.g., _MUAPs).</p> <p>Now that the .mat and .txt files have been created, they can be easily loaded in openhdemg with the function emg_from_delsys().</p> <p>Interestingly, this function allows also to import the MUAPs computed by Deslys during the decomposition. The computed MUAPs will be stored under the \"EXTRAS\" key and will be easily accessible with the function extract_delsys_muaps().</p>"},{"location":"tutorials/import_from_other_software/#export-the-reference-signal_2","title":"Export the reference signal","text":"<p>You can export the reference signal in a .mat file from the NeuroMap software by following the steps proposed in the previous section. Once the .mat file has been created, it can be easily loaded in openhdemg with the function refsig_from_delsys().</p>"},{"location":"tutorials/import_from_other_software/#more-questions","title":"More questions?","text":"<p>We hope that this tutorial was useful. If you need any additional information, do not hesitate to read the answers or ask a question in the openhdemg discussion section. If you are not familiar with GitHub discussions, please read this post. This will allow the openhdemg community to answer your questions.</p>"},{"location":"tutorials/setup_working_env/","title":"Setup working environment","text":""},{"location":"tutorials/setup_working_env/#introduction","title":"Introduction","text":"<p>Welcome to the tutorial on setting up your working environment.</p> <p>This is the first step necessary to start using openhdemg, both if you want to use the library's functions and develop your scripts, or if you only want to use the graphical user interface (GUI).</p> <p>The working environment refers to the set of resources necessary to carry out a particular task or job. In the context of this tutorial, we refer to the combination of a computer, a programming language, an integrated development environment and a set of algorithms.</p> <p>In order to use openhdemg, we will install the following:</p> <ul> <li>Programming language: Python 3</li> <li>Integrated development environment: Visual Studio Code</li> <li>Set of algorithms: openhdemg</li> </ul> <p>Python 3 is a powerful and versatile programming language known for its simplicity, readability, and extensive library support. With a focus on code readability, Python allows developers to express concepts in fewer lines of code compared to other programming languages. It is widely used for web development, scientific computing, data analysis, artificial intelligence, and more.</p> <p>The integrated development environment is a software that facilitates to write, test, and debug code. In this tutorial we will use Visual Studio Code (VS Code), a popular code editor that provides a seamless experience for Python programming.</p> <p>By following the steps outlined in this tutorial, you will be able to install Python, set up VS Code, and configure your environment to write clean and efficient Python code.</p> <p></p>"},{"location":"tutorials/setup_working_env/#install-python-and-vs-code-on-windows","title":"Install Python and VS Code on Windows","text":"<p>To install Python 3 on Windows:</p> <ol> <li>Visit the official Python website: https://www.python.org/downloads/</li> <li>Click on the \"Downloads\" tab.</li> <li>Scroll down to the section titled \"Windows\".</li> <li>Click on \"Windows installer\" under the latest compatible version of Python (i.e., Python 3.11.6). openhdemg is currently working with Python 3.11 or earlier versions (tested from Python 3.8.x to 3.11.x).</li> <li>Run the downloaded installer.</li> <li>On the installer, make sure to check the box \"Add Python to PATH\" and then click \"Install Now.\"</li> <li>Python will be installed to your system (optionally, you can verify the installation by opening a command prompt and typing python --version).</li> </ol> <p>To install VS Code on Windows:</p> <ol> <li>Visit the official Visual Studio Code website: https://code.visualstudio.com/</li> <li>Click on the \"Download for Windows\" button.</li> <li>Once the download is complete, run the installer.</li> <li>Follow the instructions on the installer to complete the installation.</li> <li>Visual Studio Code will be installed to your system.</li> </ol>"},{"location":"tutorials/setup_working_env/#install-python-and-vs-code-on-mac","title":"Install Python and VS Code on Mac","text":"<p>To install Python 3 on Mac:</p> <ol> <li>Visit the official Python website: https://www.python.org/downloads/</li> <li>Click on the \"Downloads\" tab.</li> <li>Scroll down to the section titled \"Python Releases for macOS.\"</li> <li>Click on \"macOS 64-bit universal2 installer\" under the latest compatible version of Python (i.e., Python 3.11.6). openhdemg is currently working with Python 3.11 or earlier versions (tested from Python 3.8.x to 3.11.x).</li> <li>Run the downloaded installer package.</li> <li>Follow the instructions on the installer to complete the installation.</li> <li>Python will be installed to your system. (optionally, you can verify the installation by opening a terminal and typing python3 --version).</li> </ol> <p>To install VS Code on Mac:</p> <ol> <li>Visit the official Visual Studio Code website: https://code.visualstudio.com/</li> <li>Click on the \"Download for Mac\" button.</li> <li>Once the download is complete, open the downloaded .dmg file.</li> <li>Drag and drop the Visual Studio Code application into the \"Applications\" folder.</li> <li>Visual Studio Code will be installed to your system.</li> </ol>"},{"location":"tutorials/setup_working_env/#configure-vs-code-for-python","title":"Configure VS Code for Python:","text":"<p>Now that VS Code is installed, you need to set it up to code in Python and to install openhdemg:</p> <ol> <li>Open Visual Studio Code.</li> <li>Install the \"Python\" extension by Microsoft. To do so, click on the Extensions view on the left sidebar, search for \"Python\" in the search bar, and click the \"Install\" button next to the \"Python\" extension by Microsoft.</li> </ol> <p></p> <p>Once the extension is installed, you need to create a folder where you will place all the scripts that you will write. You can create this folder with any name an in any location in your computer, but make it simple to find! In this tutorial the folder was placed in the Desktop and named <code>Test_folder</code>.</p> <p>Once the folder is created:</p> <ol> <li>In VS Code click on 'File' and then on 'Add Folder to Workspace'.</li> <li>In VS Code click on 'Terminal' and then on 'New Terminal'.</li> <li>Select your folder in the window that pops up.</li> </ol> <p></p> <p>With your powershell terminal that is pointing to your folder path, you can now create a Virtual environment.</p>"},{"location":"tutorials/setup_working_env/#create-a-virtual-environment","title":"Create a Virtual environment","text":"<p>The Virtual environments provide an isolated and controlled environment for your Python projects, allowing you to manage project-specific dependencies effectively.</p> <p>In order to create a virtual environment type in your terminal:</p> <p>For Windows users: <pre><code>python -m venv myvenv\n</code></pre></p> <p>For Mac users: <pre><code>python3 -m venv myvenv  \n</code></pre></p> <p></p> <p>This command will create a Virtual environment named <code>myvenv</code>.</p> <p>To activate <code>myvenv</code> type in the terminal:</p> <p>For Windows users: <pre><code>myvenv/Scripts/Activate   \n</code></pre></p> <p>For Mac users: <pre><code>source myvenv/bin/activate  \n</code></pre></p> <p></p> <p>If everything was successful, you should see the colourful name of your Virtual environment to the left of your folder path (as in the figure above).</p> <p>Great! You are all set up to install and use openhdemg.</p>"},{"location":"tutorials/setup_working_env/#install-and-use-openhdemg","title":"Install and use openhdemg","text":"<p>Now, installing openhdemg is super simple. Just type in the terminal:</p> <pre><code>pip install openhdemg \n</code></pre> <p>openhdemg will be installed. Once the installation process is completed, you will see in the terminal the message <code>Successfully installed openhdemg</code>.</p> <p>If you want to use the GUI, type in the terminal:</p> <pre><code>python -m openhdemg.gui.openhdemg_gui\n</code></pre> <p>And the GUI will start:</p> <p></p> <p>If you instead want to write your own script using the functions contained in openhdemg, follow these steps:</p> <ol> <li>click on the Explorer view on the left sidebar.</li> <li>Click on the icon to create a new file in your workspace folder (<code>Test_folder</code> in this case).</li> <li>Name the file as you wish but with a .py extension.</li> </ol> <p></p> <p>Now you can open your .py file, write your code and execute it.</p> <p></p>"},{"location":"tutorials/setup_working_env/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/setup_working_env/#python-installation-issues","title":"Python Installation Issues","text":"<p>Windows:</p> <ul> <li>Make sure you are running the installer with administrative privileges.</li> <li>Verify that the downloaded Python installer matches the architecture of your Windows system (32-bit or 64-bit).</li> <li>If the installation fails, try downloading a different version of Python from the official Python website.</li> </ul> <p>macOS:</p> <ul> <li>Ensure you have the necessary permissions to install software on your Mac.</li> <li>If the installation fails, try using a package manager like Homebrew to install Python instead. Instructions for Homebrew installation can be found on the Homebrew website.</li> </ul>"},{"location":"tutorials/setup_working_env/#issues-in-the-activation-of-the-virtual-environment","title":"Issues in the activation of the Virtual environment","text":"<p>Windows:</p> <p>If trying to activate the Virtual environment you see this (or a similar) message in the terminal:</p> <pre><code>the execution of scripts is disabled on this system\n</code></pre> <p>the problem might be due to the Execution Policy Settings that are too restrictive and do not allow you to execute scripts. This problemm can be solved with the following steps:</p> <ol> <li>Go to the Windos search bar.</li> <li>Type PowerShell and open it as Administrator.</li> <li>In the new PowerShell type:</li> </ol> <pre><code>Set-ExecutionPolicy Unrestricted -Force\n</code></pre> <p>This should solve the issue and you should now be able to activate your Virtual environment. For additional information on this topic visit the stackoverflow thread.</p>"},{"location":"tutorials/setup_working_env/#openhdemg-installation-issues","title":"openhdemg Installation Issues","text":"<p>Windows (1):</p> <p>If trying to install openhdemg via pip you see this (or a similar) message in the terminal:</p> <pre><code>ImportError: DLL load failed while importing _cext: The specified module could not be found.\n</code></pre> <p>the problem might be that you do not have the necessary Visual C++ Redistributable. This can be simply solved by visitng the Microsoft website and dowloading and installing the latest Visual Studio 2015, 2017, 2019 and 2022 redistributable. Please note, this is a single redistributable, you don't need to perform multiple dowloads. This should solve the issue and you should now be able to pip install openhdemg. If that's not the case, continue reading.</p> <p>Windows (2):</p> <p>If trying to install openhdemg via pip you see this (or a similar) message in the terminal:</p> <pre><code>Microsoft Visual C++ 14.0 or greater is required.\n</code></pre> <p>The problem might be that you are missing the C++ build tools necessary to compile some code present in libraries such as pandas. To solve this, follow the steps below:</p> <ol> <li>visit https://visualstudio.microsoft.com/visual-cpp-build-tools/</li> <li>click the button \"download build tools\"</li> <li>install the tools</li> <li>once the installation is completed, you should see a window like this:</li> </ol> <p></p> <p>If the window is different, there should be a button like \"install\". Clicking \"install\" or \"modify\", if present. This should bring you to the next window (it is also possible that you directly visualise the next window if no previous installation of these components is present in your computer):</p> <p></p> <p>Here, make sure that you select C++ build tool (as in the figure) and install them. If you have windows 10, you may want to select \"Windows 10 SDK 10.0.20348\" on the right panel.</p> <p>This should solve the issue and you should now be able to pip install openhdemg. If that's not the case, continue reading.</p>"},{"location":"tutorials/setup_working_env/#more-questions","title":"More questions?","text":"<p>We hope that this tutorial was useful. If you need any additional information, do not hesitate to read the answers or ask a question in the openhdemg discussion section. If you are not familiar with GitHub discussions, please read this post. This will allow the openhdemg community to answer your questions.</p>"}]}